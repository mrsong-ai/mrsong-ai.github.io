<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta name="description" content="Pi Network五子棋Web3游戏" />
    <!-- Pi Browser 兼容性配置 -->
    <meta name="pi-network-app" content="true" />
    <meta name="pi-browser-compatible" content="true" />
    <meta name="referrer" content="no-referrer-when-downgrade" />
    <title>Pi Network 五子棋</title>

    <!-- Pi Network SDK -->
    <script src="https://sdk.minepi.com/pi-sdk.js"></script>
    <script>
      // 初始化Pi SDK - 使用正式App ID
      Pi.init({
        version: "2.0",
        sandbox: false, // 使用正式环境
        appId: "gomoku-5d5b20e8b1d13f8", // 你的App ID
      });
    </script>

    <!-- 外部CSS文件 -->
    <link rel="stylesheet" href="styles.css?v=2024" />

    <style>
      /* 游戏界面特定样式 - 只保留必要的额外样式 */
    </style>
  </head>
  <body>
    <noscript data-i18n="noscript"
      >您需要启用JavaScript才能运行此应用程序。</noscript
    >

    <div id="root">
      <!-- 登录界面 -->
      <div class="login-screen">
        <div class="container">
          <div class="login-content">
            <div class="login-card card" style="position: relative">
              <!-- 语言切换器 -->
              <div class="language-selector">
                <span class="globe-icon">🌍</span>
                <select
                  id="language-selector"
                  onchange="changeLanguage(this.value)"
                >
                  <option value="zh" data-i18n="lang_zh">中文</option>
                  <option value="en" data-i18n="lang_en">English</option>
                  <option value="ko" data-i18n="lang_ko">한국어</option>
                  <option value="ja" data-i18n="lang_ja">日本語</option>
                  <option value="vi" data-i18n="lang_vi">Tiếng Việt</option>
                </select>
              </div>

              <div class="card-header text-center" style="padding-top: 25px">
                <div class="title-with-icon">
                  <div class="board-icon">
                    <div class="stones-container">
                      <div class="stone-jar black">
                        <div class="stone"></div>
                      </div>
                      <div class="stone-jar white">
                        <div class="stone"></div>
                      </div>
                    </div>
                  </div>
                  <h1 class="game-title" data-i18n="game_title">五子棋</h1>
                </div>
                <p class="game-subtitle" data-i18n="game_subtitle">
                  运行在pinetwork区块链之上的五子棋游戏
                </p>
              </div>

              <div class="card-content">
                <div class="game-modes">
                  <div class="game-mode-row">
                    <button class="game-mode-btn online-mode" onclick="handleOnlineMatch()">
                      <span class="mode-icon">🌐</span>
                      <span class="mode-text" data-i18n="online_match"
                        >在线匹配</span
                      >
                    </button>
                  </div>
                  <div class="game-mode-row">
                    <button class="game-mode-btn" onclick="showGlobalRanking()">
                      <span class="mode-icon">🏆</span>
                      <span class="mode-text" data-i18n="global_ranking"
                        >全球排行</span
                      >
                    </button>
                  </div>
                  <div class="game-mode-row">
                    <button
                      class="game-mode-btn ai-mode"
                      onclick="handleAIGame()"
                    >
                      <span class="mode-icon">🧠</span>
                      <span class="mode-text" data-i18n="ai_battle"
                        >AI对战</span
                      >
                    </button>
                  </div>
                  <div class="game-mode-row">
                    <button
                      class="game-mode-btn"
                      onclick="showPersonalCenter()"
                    >
                      <span class="mode-icon">👤</span>
                      <span class="mode-text" data-i18n="personal_center"
                        >个人中心</span
                      >
                    </button>
                  </div>
                  <div class="game-mode-row">
                    <button
                      class="game-mode-btn"
                      onclick="showGameInstructions()"
                    >
                      <span class="mode-icon">❓</span>
                      <span class="mode-text" data-i18n="game_instructions"
                        >游戏说明</span
                      >
                    </button>
                  </div>
                </div>

                <div
                  class="error-message"
                  id="error-message"
                  style="display: none"
                >
                  <p id="error-text" data-i18n="error_message">❌ 错误信息</p>
                </div>
              </div>

              <div class="card-footer">
                <button
                  class="btn btn-primary btn-lg pi-login-btn"
                  onclick="handleSignIn()"
                  id="login-btn"
                >
                  <span class="pi-icon">π</span>
                  <span data-i18n="login_with_pi">使用Pi Network登录</span>
                </button>

                <p class="login-note" data-i18n="login_note">
                  点击登录即表示您同意使用Pi Network账户进行身份验证
                </p>

                <!-- 隐私政策和服务条款链接 -->
                <div class="legal-links" style="margin-top: 20px; text-align: center;">
                  <a href="public/privacy-policy.html" target="_blank" style="color: #c77dff; text-decoration: none; margin: 0 10px; font-size: 14px;" data-i18n="privacy_policy">隐私政策</a>
                  <span style="color: #ffffff80;">|</span>
                  <a href="public/terms-of-service.html" target="_blank" style="color: #c77dff; text-decoration: none; margin: 0 10px; font-size: 14px;" data-i18n="terms_of_service">服务条款</a>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      // 多语言配置
      const LANGUAGES = {
        zh: {
          // 基础界面
          noscript: "您需要启用JavaScript才能运行此应用程序。",
          game_title: "五子棋",
          game_subtitle: "运行在pinetwork区块链之上的五子棋游戏",
          global_ranking: "全球排行",
          ai_battle: "AI对战",
          personal_center: "个人中心",
          game_instructions: "游戏说明",
          error_message: "❌ 错误信息",
          login_with_pi: "使用Pi Network登录",
          login_note: "点击登录即表示您同意使用Pi Network账户进行身份验证",
          privacy_policy: "隐私政策",
          terms_of_service: "服务条款",

          // 语言选项
          lang_zh: "中文",
          lang_en: "English",
          lang_ko: "한국어",
          lang_ja: "日本語",
          lang_vi: "Tiếng Việt",

          // 游戏相关
          current_player: "当前玩家",
          your_turn: "轮到我方落子",
          opponent_turn: "轮到对方落子",
          ai_thinking: "🤖 AI正在思考中...",
          thinking_time: "⏱️ 思考时间：{0}秒",
          remaining_time: "⚠️ 剩余时间：{0}秒",
          timeout_warning: "🚨 即将超时：{0}秒",
          timeout: "⏰ 思考超时",

          // 游戏结果
          you_win: "🎉 恭喜您获胜！",
          you_lose: "😔 很遗憾，您败了",
          draw: "🤝 平局",
          game_over: "游戏结束",

          // 按钮和操作
          new_game: "新游戏",
          undo: "悔棋",
          restart: "重新开始",
          back_to_menu: "返回主菜单",
          confirm: "确认",
          cancel: "取消",
          close: "关闭",
          save: "保存",
          update: "更新",
          enter_game: "进入游戏",

          // 个人中心
          personal_info: "个人信息",
          game_stats: "游戏统计",
          total_games: "总局数",
          wins: "胜利",
          losses: "失败",
          win_rate: "胜率",
          current_rank: "当前排名",
          wallet_address: "钱包地址",
          balance: "余额",
          nickname: "昵称",
          avatar: "头像",

          // 错误和提示
          connection_failed: "连接失败",
          network_error: "网络错误，请检查网络连接后重试",
          login_failed: "登录失败",
          insufficient_balance: "余额不足",
          invalid_move: "无效落子",
          game_not_started: "游戏未开始",

          // 支付相关
          payment_confirm: "确认支付",
          payment_success: "支付成功",
          payment_failed: "支付失败",
          payment_cancelled: "支付已取消",
          recharge: "充值",

          // 排行榜
          leaderboard: "排行榜",
          rank: "排名",
          player: "玩家",
          score: "积分",
          games_played: "游戏局数",

          // 其他
          loading: "加载中...",
          connecting: "正在连接...",
          please_wait: "请稍候...",
          success: "成功",
          failed: "失败",
          connecting_pi_network: "正在连接Pi Network...",
          entering_game: "正在进入游戏...",

          // 弹窗和提示
          hint: "提示",
          confirm_purchase: "确认购买",
          confirm_payment: "确认支付",
          payment_amount: "{0} π",
          enter_nickname: "请输入昵称",
          nickname_too_long: "昵称不能超过20个字符",
          nickname_forbidden: "昵称包含敏感词，请重新输入",
          logout_confirm: "退出确认",
          logout_message: "确定要退出账户吗？您的游戏数据将被保留。",
          logout_success: "退出成功",
          logout_success_message: "已成功退出账户！",
          please_login_first: "请先登录",

          // 游戏说明
          game_instructions_title: "游戏说明",
          game_history_title: "五子棋历史渊源",
          game_history_desc:
            '相传五子棋诞生于4000多年前的尧帝时期。尧为教育儿子丹朱，发明了石子棋，后经舜改良为"五星连珠"玩法，逐渐形成现代五子棋的雏形。\n从尧舜时期的民间游戏，到南北朝传播至东亚，再经日本改良为竞技运动，最终成为全球性棋类项目。',

          // 个人中心
          personal_center_title: "个人中心",
          wallet_address_placeholder: "输入50位钱包地址 (大写字母和数字)",
          wallet_address_format: "钱包地址格式：50位大写字母和数字",

          // 支付相关
          insufficient_balance_title: "余额不足",
          insufficient_balance_message:
            "悔棋需要消费 0.1 π，当前余额 {0} π，余额不足。\n\n是否要充值？",
          recharge_prompt: "为您的游戏账户充值Pi币，享受更多游戏功能！",
          continue_without_recharge:
            "您可以继续当前游戏，但无法重新开始。充值后即可解锁此功能。",
          undo_success: "悔棋成功",
          undo_success_message: "已消费 0.1 π，余额：{0} π",
          undo_failed: "悔棋失败",
          network_error_retry: "网络错误，请稍后重试",
          invalid_amount: "请输入有效的充值金额（最低0.1π）",

          // 道具名称
          item_hint: "提示道具",
          item_undo: "悔棋券",
          item_theme: "主题包",
          item_vip: "VIP会员",
          item_unknown: "未知道具",

          // 排行榜和统计
          current_ranking: "🎯 当前排名：第{0}名 | ({1}胜{2}负) | 胜率：{3}%",
          leaderboard_update_tip: "排行榜实时更新，继续游戏提升您的排名！",
          ranking_header_rank: "排名",
          ranking_header_nickname: "昵称",
          ranking_header_games: "总对局",
          ranking_header_winrate: "胜率",
          current_rank_not_listed: "当前排名：未上榜",
          current_rank_label: "当前排名",
          not_listed: "未上榜",
          play_one_game_to_rank:
            "🎮 完成1局游戏即可上榜！开始您的五子棋之旅吧！",

          // 个人中心详细内容
          personal_profile: "个人档案",
          avatar_nickname: "头像和昵称",
          click_to_edit: "点击编辑",
          account_info: "账户信息",
          game_statistics: "游戏统计",
          account_balance_label: "账户余额",
          refresh_balance: "刷新余额",
          logout_account: "退出账户",

          // 游戏说明详细内容
          game_history_section: "五子棋历史渊源",
          game_rules_section: "游戏规则",
          game_rules_title: "🎯 基本规则",
          game_rules_desc: "两人轮流在15×15棋盘上落子，率先连成5子者获胜",
          game_features_title: "🌟 游戏特色",
          game_features_desc:
            "• 支持人机对战，AI智能强大\n• 实时排行榜系统\n• Pi币奖励机制\n• 多语言支持",
          game_controls_title: "🎮 操作说明",
          game_controls_desc:
            "• 点击棋盘空位落子\n• 支持悔棋功能（需消费Pi币）\n• 可随时重新开始游戏",

          // 充值和支付
          recharge_title: "💰 账户充值",
          payment_title: "💳 Pi币支付",
          recharge_amount: "充值 {0} π",
          order_number: "订单号：{0}",
          quick_recharge: "快速充值",
          custom_amount: "自定义金额",
          min_amount_note: "最低充值0.1π",
          recharge_benefits: "充值后可享受：",
          recharge_benefit_1: "• 无限次悔棋",
          recharge_benefit_2: "• 游戏重新开始",
          recharge_benefit_3: "• 专属道具购买",
          recharge_benefit_4: "• 参与月度奖励",

          // 错误和状态
          error_title: "错误",
          loading_text: "正在加载...",
          connecting_text: "正在连接...",
          balance_query: "查询中...",
          balance_query_failed: "查询失败",
          pi_login_failed: "Pi Network 登录失败",
          login_error: "登录过程中发生错误",
          pi_sdk_not_loaded: "Pi Network SDK未加载，无法使用支付功能",
          pi_sdk_not_available: "Pi Network SDK不可用",
          pi_sdk_required_message: "此游戏需要Pi Network环境才能正常运行。\n\n请在Pi浏览器中打开此游戏，或确保Pi Network SDK已正确加载。",
          create_payment_failed: "创建支付失败",

          // 游戏说明详细规则
          basic_rules_detail_1: "在15×15的棋盘上，玩家执黑子，AI执白子",
          basic_rules_detail_2: "双方轮流落子，先连成五子一线者获胜",
          basic_rules_detail_3: "五子可以是横、竖、斜任意方向的连线",
          basic_rules_detail_4: "棋盘填满且无人获胜则为平局",

          // 回合时间规则
          turn_time_rules: "⏱️ 回合时间规则",
          thinking_time_rule: "思考时间：每回合60秒思考时间",
          time_warning_rule: "时间提醒：剩余30秒时黄色警告",
          urgent_warning_rule: "紧急提醒：最后10秒红色闪烁",
          timeout_rule: "超时判负：超时自动记录为失败",

          // 游戏操作详细
          game_operations: "🎮 游戏操作",
          place_stone: "落子：点击空白格子下棋",
          undo_move: "悔棋：可撤销最近一步（玩家+AI各一步）",
          new_game_op: "新游戏：重新开始，进行中的游戏记录为失败",
          return_op: "返回：退出游戏，进行中的游戏记录为失败",

          // 胜率排行系统
          score_system: "🏆 胜率排行系统",
          initial_score: "排行依据：按胜率排序",
          win_score: "获胜：提升胜率",
          draw_score: "平局：影响胜率",
          lose_score: "失败：降低胜率",
          quit_score: "放弃/超时：记为失败",

          // 月度排名规则
          monthly_ranking_rules: "🎯 月度排名规则：",
          ranking_requirement: "• 需要至少1局对局才能参与排名",
          ranking_criteria: "• 按剩余分数高低排名，分数相同按胜率排序",
          ranking_rewards: "• 月底根据排名发放奖励",
          anti_farming: "⚠️ 防刷分机制：不对局或对局太少的玩家不参与排名",

          // 月度奖励规则
          monthly_rewards: "🏆 月度奖励规则",
          reward_pool_allocation: "💰 奖励池分配",
          reward_settlement: "每月月底最后一天最后一小时进行结算",
          reward_pool_percentage: "奖励池为当月平台总盈利的 50%",
          reward_example: "例：本月盈利100π，奖励池为50π",

          // 前三名分配
          top_three_distribution: "🥇 前三名分配比例",
          first_place: "🥇 第一名",
          second_place: "🥈 第二名",
          third_place: "🥉 第三名",

          // 发放方式
          distribution_method: "📋 发放方式",
          wallet_distribution: "按照个人中心保存的钱包地址手动发放",
          valid_wallet_required: "获奖者需确保钱包地址正确有效",
          next_day_distribution: "奖励将在结算次日发放",
          invalid_wallet_rollover: "如钱包地址无效，奖励将顺延至下月",

          // 排行榜规则
          leaderboard_rules: "📊 排行榜规则",
          ranking_condition: "上榜条件：完成1局游戏即可上榜",
          ranking_basis: "排名依据：按胜率排序（胜率相同时按总局数排序）",
          data_statistics: "数据统计：月度排行榜，每月1日重置",
          realtime_update: "实时更新：每局结束后立即更新",

          // 温馨提示
          warm_tips:
            "🎋 传承千年智慧，体验古典棋艺之美\n💡 合理安排时间，享受思考乐趣",

          // 游戏结果相关
          game_result: "游戏结果",
          congratulations_win: "🎉 恭喜获胜！",
          sorry_lose: "😔 很遗憾失败了",
          draw_result: "🤝 平局",
          current_score: "当前积分",
          win_rate_display: "胜率",
          total_games_display: "总对局",
          current_rank_display: "当前排名",
          not_ranked: "未上榜",
          guest_mode: "游客模式",
          guest_mode_desc: "您当前以游客身份游戏，游戏结果不会记录到排行榜中。",
          login_benefits: "登录后可享受：",
          benefit_stats: "• 📊 游戏数据统计",
          benefit_leaderboard: "• 🏆 参与排行榜竞争",
          benefit_pi_service: "• 💰 Pi币增值服务",
          benefit_monthly_rewards: "• 🎁 月度奖励活动",
          play_again: "再来一局",
          view_leaderboard: "查看排行榜",
          login_now: "立即登录",
          monthly_games: "本月对局",
          rank_position: "第{0}名",

          // 游戏界面
          return_to_menu: "返回",
          guest_mode_short: "🎮 游客模式",
          ai_battle_title: "🧠 AI对战",
          player_label: "玩家",
          ai_label: "AI",
          vs_label: "VS",
          undo_button: "悔棋",
          new_game_button: "新游戏",

          // 悔棋相关
          undo_confirm: "悔棋确认",
          undo_confirm_message:
            "悔棋需要消费 0.1 π\n当前余额：{0} π\n\n确定要悔棋吗？",
          undo_success_title: "悔棋成功",
          undo_success_detail: "已消费 0.1 π，余额：{0} π",
          undo_failed_title: "悔棋失败",
          undo_failed_message: "扣费失败",
          insufficient_balance_undo:
            "悔棋需要消费 0.1 π，当前余额 {0} π，余额不足。\n\n是否要充值？",
          continue_game_tip:
            "您可以继续当前游戏，但无法重新开始。充值后即可解锁此功能。",

          // 充值相关
          recharge_dialog_title: "💰 账户充值",
          payment_dialog_title: "💳 Pi币支付",
          recharge_amount_display: "充值 {0} π",
          order_id_display: "订单号：{0}",
          custom_amount_error: "请输入有效的充值金额（最低0.1π）",

          // 个人中心详细内容
          monthly_reward_reminder: "🏆 月度奖励提醒",
          monthly_reward_desc: "每月利润的50%将分配给排名前三的玩家作为奖励",

          // 月度重置系统
          monthly_reset_system: "📅 月度重置系统",
          monthly_reset_desc: "每月1日自动重置排行榜，开始新的月度竞赛",
          historical_data_preserved: "历史总对局数据永久保存，不会清零",
          monthly_ranking_only: "仅月度排行榜数据重置，个人历史记录保留",

          // 全球排行榜
          global_ranking_title: "全球排行",
          ranking_subtitle: "📊 基于月度胜率的排名",
          ranking_header_rank: "排名",
          ranking_header_nickname: "昵称",
          ranking_header_games: "总对局",
          ranking_header_winrate: "胜率",

          // 个人中心详细标签
          personal_profile_section: "个人档案",
          avatar_nickname_section: "头像和昵称",
          click_avatar_edit: "点击头像编辑",
          click_nickname_edit: "点击昵称编辑",
          account_info_section: "账户信息",
          game_stats_section: "游戏统计",
          wallet_address_label: "钱包地址",
          account_balance_display: "账户余额",
          refresh_balance_btn: "刷新余额",
          logout_btn: "退出账户",

          // 游戏统计标签
          total_games_label: "总对局",
          wins_label: "胜利",
          win_rate_label: "胜率",
          current_score_label: "当前积分",
          current_rank_label: "当前排名",

          // 余额查询状态
          balance_querying: "查询中...",
          balance_query_failed_display: "查询失败",
          balance_tooltip: "总充值：{0} π\n总消费：{1} π",

          // 支付成功信息
          payment_success_title: "支付成功",
          payment_success_message: "支付成功！",
          purchase_success_message: "您已成功购买 {0}",
          transaction_id: "交易ID: {0}",

          // 个人中心输入提示
          enter_avatar_emoji: "输入emoji头像 (如: 😊)",
          click_to_set_nickname: "点击设置昵称",
          enter_your_nickname: "输入您的昵称",
          loading_text_display: "加载中...",
          refresh_balance_text: "🔄 刷新余额",
          recharge_text: "💰 充值",
          wallet_format_hint: "钱包地址格式：50位大写字母和数字",
          save_wallet: "💾 保存",
          edit_wallet: "✏️ 编辑",
          logout_account_text: "↩️ 退出账户",

          // 个人中心提示信息
          enter_avatar_hint: "请输入头像emoji",
          single_emoji_hint: "请输入单个emoji表情",
          avatar_updated: "头像已更新！",
          nickname_updated: "昵称已更新！",
          enter_wallet_hint: "请输入钱包地址",
          wallet_length_error:
            "❌ 这不是标准钱包地址！\n\n当前长度：{0}位\n标准长度：50位\n\n请输入完整的50位钱包地址",
          wallet_format_error:
            "❌ 钱包地址格式错误！\n\n只能包含大写字母(A-Z)和数字(0-9)\n请检查输入内容",
          wallet_saved_success: "✅ 钱包地址已保存成功！",
          edit_mode_title: "编辑模式",
          edit_mode_message: "💡 编辑模式已启用\n\n请修改钱包地址后点击保存",
          success_title: "成功",

          // 游戏结束相关
          you_win: "🎉 恭喜您获胜！",
          you_lose: "😔 AI获胜，再接再厉！",
          draw: "🤝 平局！",
          game_over: "游戏结束",

          // 主界面按钮
          online_match: "在线匹配",
          global_ranking: "全球排行",
          ai_battle: "AI对战",
          personal_center: "个人中心",
          game_instructions: "游戏说明",

          // 在线匹配相关
          searching_opponent: "正在寻找对手...",
          online_players: "当前在线玩家",
          people_suffix: "人",
          match_description: "系统将为您匹配实力相近的对手",
          estimated_wait: "预计等待时间：30-60秒",
          match_found: "找到对手！",
          ai_opponent_name: "AI智能对手",
          black_stone: "黑子",
          white_stone: "白子",
          opponent_label: "对手：",
          your_color: "您的棋子",
          your_turn: "轮到您了",
          opponent_turn: "对手回合",
          not_your_turn: "还没轮到您",
          game_not_ready: "游戏未准备就绪",
          waiting_for_game: "等待游戏开始...",
          connection_failed: "连接服务器失败",
          please_login_first: "请先登录",
          surrender: "投降",
          surrender_confirm_title: "确认投降",
          surrender_confirm_message: "您确定要投降吗？",
          opponent_surrendered: "🎉 对手投降，您获胜！",
          you_surrendered: "😔 您已投降",
          opponent_disconnected: "对手已断开连接",
          cancel_match: "取消匹配",
          match_found: "✅ 找到对手！",
          opponent_label: "对手：",
          level_label: "等级：⭐⭐⭐",
          start_game: "开始游戏",
          rematch: "重新匹配",
          cancel_match_confirm: "确定要取消当前匹配吗？",
          cancel_match_title: "取消匹配",
          cancel_match_options: "您可以选择：",
          rematch_option: "重新匹配",
          return_main_option: "返回主界面",
          continue_match_option: "继续匹配",
          online_game_info: "在线对战需要后端服务器支持：\n\n• WebSocket实时通信\n• 玩家匹配算法\n• 游戏房间管理\n• 实时棋局同步\n\n后端代码已完成，正在部署服务器...\n目前可体验AI对战模式！",

          // 连接错误
          connection_failed: "连接失败",
          connection_error_detail: "无法连接到Pi Network，请检查网络连接后重试",
          login_with_pi: "使用Pi账号登录",
          login_benefits_note: "登录后可享受完整游戏功能和Pi币奖励",

          // 充值对话框
          recharge_amount_selection: "充值金额选择",
          custom_amount_placeholder: "自定义金额",
          custom_recharge: "自定义充值",
          cancel: "取消",

          // 错误提示
          please_login_first: "请先登录",
          create_order_failed: "创建订单失败",
          network_error_retry: "网络错误，请稍后重试",

          // 支付对话框
          payment_method: "支付方式",
          pi_wallet_transfer: "📱 Pi钱包转账",
          transfer_instruction: "请使用Pi钱包向以下地址转账：",
          transfer_amount_warning: "⚠️ 请确保转账金额为 <strong>{0} π</strong>",
          transfer_memo: "转账备注：{0}",
          transaction_hash_placeholder: "请输入转账交易哈希",
          transaction_hash_instruction:
            "转账完成后，请在Pi钱包中复制交易哈希并粘贴到上方输入框",
          verify_payment: "验证支付",
          order_validity: "订单有效期：30分钟",

          // 支付验证
          please_enter_transaction_hash: "请输入交易哈希",
          recharge_success: "充值成功",
          recharge_success_message: "恭喜！充值 {0} π 成功！\n当前余额：{1} π",
          verification_failed: "验证失败",

          // 游戏流程确认
          timeout_game_over: "⏰ 思考超时，游戏失败！",
          login_success: "登录成功",
          welcome_user: "欢迎，{0}",
          abandon_current_game: "放弃当前游戏",
          abandon_game_warning:
            "当前游戏正在进行中，重新开始将记录为失败。\n\n确定要放弃当前游戏吗？",
          restart_game: "重新开始游戏",
          restart_game_confirm: "确定要重新开始吗？",
          abandon_game_return_warning:
            "当前游戏正在进行中，返回主界面将记录为失败。\n\n确定要放弃当前游戏吗？",

          // 胜负显示格式
          wins_losses_format: "({0}胜{1}负)",

          // 月度奖励详细说明
          reward_settlement_detail: "每月月底最后一天最后一小时进行结算",
          reward_pool_50_percent: "奖励池为当月平台总盈利的 50%",
          reward_example_detail: "例：本月盈利100π，奖励池为50π",
          reward_distribution_manual: "按照个人中心保存的钱包地址手动发放",
          reward_wallet_valid: "获奖者需确保钱包地址正确有效",
          reward_next_day: "奖励将在结算次日发放",
          reward_invalid_rollover: "如钱包地址无效，奖励将顺延至下月",
          reward_example_calculation: "💡 示例：本月盈利100π，奖励池50π",
          first_place_reward: "🥇第一名：25π",
          second_place_reward: "🥈第二名：15π",
          third_place_reward: "🥉第三名：10π",
        },

        en: {
          // 基础界面
          noscript: "You need to enable JavaScript to run this application.",
          game_title: "Gomoku",
          game_subtitle: "Gomoku game running on pinetwork blockchain",
          online_match: "Online Match",
          global_ranking: "Global Ranking",
          ai_battle: "AI Battle",
          personal_center: "Personal Center",
          game_instructions: "Game Instructions",

          // Online match related
          searching_opponent: "Searching for opponent...",
          online_players: "Online players",
          people_suffix: "people",
          match_description: "System will match you with players of similar skill",
          estimated_wait: "Estimated wait time: 30-60 seconds",
          match_found: "Match found!",
          ai_opponent_name: "AI Smart Opponent",
          black_stone: "Black",
          white_stone: "White",
          opponent_label: "Opponent: ",
          your_color: "Your pieces",
          your_turn: "Your turn",
          opponent_turn: "Opponent's turn",
          not_your_turn: "Not your turn",
          game_not_ready: "Game not ready",
          waiting_for_game: "Waiting for game to start...",
          connection_failed: "Failed to connect to server",
          please_login_first: "Please login first",
          surrender: "Surrender",
          surrender_confirm_title: "Confirm Surrender",
          surrender_confirm_message: "Are you sure you want to surrender?",
          opponent_surrendered: "🎉 Opponent surrendered, you win!",
          you_surrendered: "😔 You surrendered",
          opponent_disconnected: "Opponent disconnected",
          cancel_match_confirm: "Are you sure you want to cancel current matching?",
          cancel_match_title: "Cancel Match",
          cancel_match_options: "You can choose:",
          rematch_option: "Rematch",
          return_main_option: "Return to Main",
          continue_match_option: "Continue Matching",
          online_game_info: "Online battle requires backend server support:\n\n• WebSocket real-time communication\n• Player matching algorithm\n• Game room management\n• Real-time game synchronization\n\nBackend code is ready, deploying server...\nCurrently you can experience AI battle mode!",
          error_message: "❌ Error Message",
          login_with_pi: "Login with Pi Network",
          login_note:
            "By clicking login, you agree to use Pi Network account for authentication",
          privacy_policy: "Privacy Policy",
          terms_of_service: "Terms of Service",

          // 语言选项
          lang_zh: "中文",
          lang_en: "English",
          lang_ko: "한국어",
          lang_ja: "日本語",
          lang_vi: "Tiếng Việt",

          // 游戏相关
          current_player: "Current Player",
          your_turn: "Your Turn",
          opponent_turn: "Opponent's Turn",
          ai_thinking: "🤖 AI is thinking...",
          thinking_time: "⏱️ Thinking time: {0}s",
          remaining_time: "⚠️ Time remaining: {0}s",
          timeout_warning: "🚨 Timeout warning: {0}s",
          timeout: "⏰ Timeout",

          // 游戏结果
          you_win: "🎉 Congratulations! You Win!",
          you_lose: "😔 Sorry, You Lose",
          draw: "🤝 Draw",
          game_over: "Game Over",

          // 按钮和操作
          new_game: "New Game",
          undo: "Undo",
          restart: "Restart",
          back_to_menu: "Back to Menu",
          confirm: "Confirm",
          cancel: "Cancel",
          close: "Close",
          save: "Save",
          update: "Update",
          enter_game: "Enter Game",

          // 个人中心
          personal_info: "Personal Info",
          game_stats: "Game Statistics",
          total_games: "Total Games",
          wins: "Wins",
          losses: "Losses",
          win_rate: "Win Rate",
          current_rank: "Current Rank",
          wallet_address: "Wallet Address",
          balance: "Balance",
          nickname: "Nickname",
          avatar: "Avatar",

          // 错误和提示
          connection_failed: "Connection Failed",
          network_error:
            "Network error, please check your connection and try again",
          login_failed: "Login Failed",
          insufficient_balance: "Insufficient Balance",
          invalid_move: "Invalid Move",
          game_not_started: "Game Not Started",

          // 支付相关
          payment_confirm: "Confirm Payment",
          payment_success: "Payment Successful",
          payment_failed: "Payment Failed",
          payment_cancelled: "Payment Cancelled",
          recharge: "Recharge",

          // 排行榜
          leaderboard: "Leaderboard",
          rank: "Rank",
          player: "Player",
          score: "Score",
          games_played: "Games Played",

          // 其他
          loading: "Loading...",
          connecting: "Connecting...",
          please_wait: "Please wait...",
          success: "Success",
          failed: "Failed",
          connecting_pi_network: "Connecting to Pi Network...",
          entering_game: "Entering game...",

          // 弹窗和提示
          hint: "Hint",
          confirm_purchase: "Confirm Purchase",
          confirm_payment: "Confirm Payment",
          payment_amount: "{0} π",
          enter_nickname: "Please enter nickname",
          nickname_too_long: "Nickname cannot exceed 20 characters",
          nickname_forbidden:
            "Nickname contains forbidden words, please re-enter",
          logout_confirm: "Logout Confirmation",
          logout_message:
            "Are you sure you want to logout? This will clear all locally saved data.",
          logout_success: "Logout Successful",
          logout_success_message: "Successfully logged out!",
          please_login_first: "Please login first",

          // 游戏说明
          game_instructions_title: "Game Instructions",
          game_history_title: "Gomoku History",
          game_history_desc:
            'Legend says Gomoku was born over 4000 years ago during Emperor Yao\'s era. Yao invented stone chess to educate his son Danzhu, later improved by Shun into the "Five Stars in a Row" gameplay, gradually forming the prototype of modern Gomoku.\nFrom folk games in the Yao-Shun era, to spreading to East Asia during the Northern and Southern Dynasties, then refined by Japan into competitive sports, finally becoming a global chess project.',

          // 个人中心
          personal_center_title: "Personal Center",
          wallet_address_placeholder:
            "Enter 50-character wallet address (uppercase letters and numbers)",
          wallet_address_format:
            "Wallet address format: 50 uppercase letters and numbers",

          // 支付相关
          insufficient_balance_title: "Insufficient Balance",
          insufficient_balance_message:
            "Undo requires 0.1 π, current balance {0} π, insufficient balance.\n\nWould you like to recharge?",
          recharge_prompt:
            "Recharge Pi coins for your gaming account and enjoy more game features!",
          continue_without_recharge:
            "You can continue the current game, but cannot restart. Unlock this feature after recharging.",
          undo_success: "Undo Successful",
          undo_success_message: "Consumed 0.1 π, balance: {0} π",
          undo_failed: "Undo Failed",
          network_error_retry: "Network error, please try again later",
          invalid_amount: "Please enter a valid recharge amount (minimum 0.1π)",

          // 道具名称
          item_hint: "Hint Item",
          item_undo: "Undo Ticket",
          item_theme: "Theme Pack",
          item_vip: "VIP Membership",
          item_unknown: "Unknown Item",

          // 排行榜和统计
          current_ranking:
            "🎯 Current Rank: #{0} | ({1}W {2}L) | Win Rate: {3}%",
          leaderboard_update_tip:
            "Leaderboard updates in real-time, keep playing to improve your ranking!",
          ranking_header_rank: "Rank",
          ranking_header_nickname: "Nickname",
          ranking_header_games: "Total Games",
          ranking_header_winrate: "Win Rate",
          current_rank_not_listed: "Current Rank: Not Listed",
          current_rank_label: "Current Rank",
          not_listed: "Not Listed",
          play_one_game_to_rank:
            "🎮 Complete 1 game to get on the leaderboard! Start your Gomoku journey!",

          // 个人中心详细内容
          personal_profile: "Personal Profile",
          avatar_nickname: "Avatar & Nickname",
          click_to_edit: "Click to Edit",
          account_info: "Account Information",
          game_statistics: "Game Statistics",
          account_balance_label: "Account Balance",
          refresh_balance: "Refresh Balance",
          logout_account: "Logout Account",

          // 游戏说明详细内容
          game_history_section: "Gomoku History",
          game_rules_section: "Game Rules",
          game_rules_title: "🎯 Basic Rules",
          game_rules_desc:
            "Two players take turns placing stones on a 15×15 board, first to connect 5 wins",
          game_features_title: "🌟 Game Features",
          game_features_desc:
            "• AI battle with intelligent opponent\n• Real-time leaderboard system\n• Pi coin reward mechanism\n• Multi-language support",
          game_controls_title: "🎮 Controls",
          game_controls_desc:
            "• Click empty board position to place stone\n• Undo function available (costs Pi coins)\n• Restart game anytime",

          // 充值和支付
          recharge_title: "💰 Account Recharge",
          payment_title: "💳 Pi Coin Payment",
          recharge_amount: "Recharge {0} π",
          order_number: "Order Number: {0}",
          quick_recharge: "Quick Recharge",
          custom_amount: "Custom Amount",
          min_amount_note: "Minimum recharge 0.1π",
          recharge_benefits: "After recharge, enjoy:",
          recharge_benefit_1: "• Unlimited undo moves",
          recharge_benefit_2: "• Game restart function",
          recharge_benefit_3: "• Exclusive item purchases",
          recharge_benefit_4: "• Monthly reward participation",

          // 错误和状态
          error_title: "Error",
          loading_text: "Loading...",
          connecting_text: "Connecting...",
          balance_query: "Querying...",
          balance_query_failed: "Query Failed",
          pi_login_failed: "Pi Network login failed",
          login_error: "Error occurred during login",
          pi_sdk_not_loaded:
            "Pi Network SDK not loaded, payment features unavailable",
          pi_sdk_not_available: "Pi Network SDK not available",
          pi_sdk_required_message: "This game requires Pi Network environment to run properly.\n\nPlease open this game in Pi Browser, or ensure Pi Network SDK is properly loaded.",
          create_payment_failed: "Failed to create payment",

          // 游戏说明详细规则
          basic_rules_detail_1:
            "On a 15×15 board, player uses black stones, AI uses white stones",
          basic_rules_detail_2:
            "Players take turns placing stones, first to connect five wins",
          basic_rules_detail_3:
            "Five stones can be connected horizontally, vertically, or diagonally",
          basic_rules_detail_4:
            "If the board is full with no winner, it's a draw",

          // 回合时间规则
          turn_time_rules: "⏱️ Turn Time Rules",
          thinking_time_rule: "Thinking time: 60 seconds per turn",
          time_warning_rule:
            "Time warning: Yellow warning at 30 seconds remaining",
          urgent_warning_rule:
            "Urgent warning: Red flashing in last 10 seconds",
          timeout_rule:
            "Timeout penalty: Timeout automatically recorded as loss",

          // 游戏操作详细
          game_operations: "🎮 Game Operations",
          place_stone: "Place stone: Click empty grid to play",
          undo_move: "Undo: Can retract last move (player + AI each one step)",
          new_game_op: "New game: Restart, ongoing game recorded as loss",
          return_op: "Return: Exit game, ongoing game recorded as loss",

          // 胜率排行系统
          score_system: "🏆 Win Rate Ranking System",
          initial_score: "Ranking basis: Sorted by win rate",
          win_score: "Win: Improves win rate",
          draw_score: "Draw: Affects win rate",
          lose_score: "Loss: Reduces win rate",
          quit_score: "Quit/Timeout: Counts as loss",

          // 月度排名规则
          monthly_ranking_rules: "🎯 Monthly Ranking Rules:",
          ranking_requirement:
            "• At least 1 game required to participate in ranking",
          ranking_criteria:
            "• Ranked by remaining points, same points sorted by win rate",
          ranking_rewards:
            "• Rewards distributed at month end based on ranking",
          anti_farming:
            "⚠️ Anti-farming mechanism: Players with no games or too few games don't participate in ranking",

          // 月度奖励规则
          monthly_rewards: "🏆 Monthly Reward Rules",
          reward_pool_allocation: "💰 Reward Pool Allocation",
          reward_settlement:
            "Settlement on the last hour of the last day of each month",
          reward_pool_percentage:
            "Reward pool is 50% of platform's monthly profit",
          reward_example: "Example: Monthly profit 100π, reward pool 50π",

          // 前三名分配
          top_three_distribution: "🥇 Top Three Distribution",
          first_place: "🥇 First Place",
          second_place: "🥈 Second Place",
          third_place: "🥉 Third Place",

          // 发放方式
          distribution_method: "📋 Distribution Method",
          wallet_distribution:
            "Distributed manually according to wallet address saved in personal center",
          valid_wallet_required:
            "Winners must ensure wallet address is correct and valid",
          next_day_distribution:
            "Rewards will be distributed the day after settlement",
          invalid_wallet_rollover:
            "If wallet address is invalid, rewards will be rolled over to next month",

          // 排行榜规则
          leaderboard_rules: "📊 Leaderboard Rules",
          ranking_condition:
            "Ranking condition: Complete 60 games to be listed",
          ranking_basis: "Ranking basis: Sorted by cumulative points",
          data_statistics:
            "Data statistics: Based on historical cumulative data",
          realtime_update:
            "Real-time update: Updated immediately after each game",

          // 温馨提示
          warm_tips:
            "🎋 Inherit thousand-year wisdom, experience classical chess beauty\n💡 Manage time wisely, enjoy thinking pleasure",

          // 游戏结果相关
          game_result: "Game Result",
          congratulations_win: "🎉 Congratulations! You Win!",
          sorry_lose: "😔 Sorry, You Lost",
          draw_result: "🤝 Draw",
          current_score: "Current Score",
          win_rate_display: "Win Rate",
          total_games_display: "Total Games",
          current_rank_display: "Current Rank",
          not_ranked: "Not Ranked",
          guest_mode: "Guest Mode",
          guest_mode_desc:
            "You are currently playing as a guest, game results will not be recorded in leaderboard.",
          login_benefits: "After login, enjoy:",
          benefit_stats: "• 📊 Game data statistics",
          benefit_leaderboard: "• 🏆 Participate in leaderboard competition",
          benefit_pi_service: "• 💰 Pi coin value-added services",
          benefit_monthly_rewards: "• 🎁 Monthly reward activities",
          play_again: "Play Again",
          view_leaderboard: "View Leaderboard",
          login_now: "Login Now",

          // 游戏界面
          return_to_menu: "Return",
          guest_mode_short: "🎮 Guest Mode",
          ai_battle_title: "🧠 AI Battle",
          player_label: "Player",
          ai_label: "AI",
          vs_label: "VS",
          undo_button: "Undo",
          new_game_button: "New Game",

          // 悔棋相关
          undo_confirm: "Undo Confirmation",
          undo_confirm_message:
            "Undo requires 0.1 π\nCurrent balance: {0} π\n\nConfirm undo?",
          undo_success_title: "Undo Successful",
          undo_success_detail: "Consumed 0.1 π, balance: {0} π",
          undo_failed_title: "Undo Failed",
          undo_failed_message: "Payment failed",
          insufficient_balance_undo:
            "Undo requires 0.1 π, current balance {0} π, insufficient balance.\n\nWould you like to recharge?",
          continue_game_tip:
            "You can continue the current game, but cannot restart. Unlock this feature after recharging.",

          // 充值相关
          recharge_dialog_title: "💰 Account Recharge",
          payment_dialog_title: "💳 Pi Coin Payment",
          recharge_amount_display: "Recharge {0} π",
          order_id_display: "Order ID: {0}",
          custom_amount_error:
            "Please enter a valid recharge amount (minimum 0.1π)",

          // 个人中心详细内容
          monthly_reward_reminder: "🏆 Monthly Reward Reminder",
          monthly_reward_desc:
            "50% of monthly profits will be distributed to the top three players as rewards",

          // 月度奖励详细说明
          reward_settlement_detail:
            "Settlement on the last hour of the last day of each month",
          reward_pool_50_percent:
            "Reward pool is 50% of platform's monthly profit",
          reward_example_detail:
            "Example: Monthly profit 100π, reward pool 50π",
          reward_distribution_manual:
            "Distributed manually according to wallet address saved in personal center",
          reward_wallet_valid:
            "Winners must ensure wallet address is correct and valid",
          reward_next_day:
            "Rewards will be distributed the day after settlement",
          reward_invalid_rollover:
            "If wallet address is invalid, rewards will be rolled over to next month",
          reward_example_calculation:
            "💡 Example: Monthly profit 100π, reward pool 50π",
          first_place_reward: "🥇First place: 25π",
          second_place_reward: "🥈Second place: 15π",
          third_place_reward: "🥉Third place: 10π",

          // 全球排行榜
          global_ranking_title: "Global Ranking",
          ranking_subtitle: "📊 Ranking based on monthly win rate",
          ranking_header_rank: "Rank",
          ranking_header_nickname: "Nickname",
          ranking_header_games: "Total Games",
          ranking_header_winrate: "Win Rate",

          // 个人中心详细标签
          personal_profile_section: "Personal Profile",
          avatar_nickname_section: "Avatar and Nickname",
          click_avatar_edit: "Click avatar to edit",
          click_nickname_edit: "Click nickname to edit",
          account_info_section: "Account Information",
          game_stats_section: "Game Statistics",
          wallet_address_label: "Wallet Address",
          account_balance_display: "Account Balance",
          refresh_balance_btn: "Refresh Balance",
          logout_btn: "Logout",

          // 游戏统计标签
          total_games_label: "Total Games",
          wins_label: "Wins",
          win_rate_label: "Win Rate",
          current_score_label: "Current Score",
          current_rank_label: "Current Rank",

          // 余额查询状态
          balance_querying: "Querying...",
          balance_query_failed_display: "Query Failed",
          balance_tooltip: "Total Recharged: {0} π\nTotal Spent: {1} π",

          // 支付成功信息
          payment_success_title: "Payment Successful",
          payment_success_message: "Payment Successful!",
          purchase_success_message: "You have successfully purchased {0}",
          transaction_id: "Transaction ID: {0}",

          // 个人中心输入提示
          enter_avatar_emoji: "Enter emoji avatar (e.g.: 😊)",
          click_to_set_nickname: "Click to set nickname",
          enter_your_nickname: "Enter your nickname",
          loading_text_display: "Loading...",
          refresh_balance_text: "🔄 Refresh Balance",
          recharge_text: "💰 Recharge",
          wallet_format_hint:
            "Wallet address format: 50 uppercase letters and numbers",
          save_wallet: "💾 Save",
          edit_wallet: "✏️ Edit",
          logout_account_text: "↩️ Logout",

          // 个人中心提示信息
          enter_avatar_hint: "Please enter avatar emoji",
          single_emoji_hint: "Please enter a single emoji",
          avatar_updated: "Avatar updated!",
          nickname_updated: "Nickname updated!",
          enter_wallet_hint: "Please enter wallet address",
          wallet_length_error:
            "❌ This is not a standard wallet address!\n\nCurrent length: {0} characters\nStandard length: 50 characters\n\nPlease enter a complete 50-character wallet address",
          wallet_format_error:
            "❌ Wallet address format error!\n\nOnly uppercase letters (A-Z) and numbers (0-9) are allowed\nPlease check your input",
          wallet_saved_success: "✅ Wallet address saved successfully!",
          edit_mode_title: "Edit Mode",
          edit_mode_message:
            "💡 Edit mode enabled\n\nPlease modify the wallet address and click save",
          success_title: "Success",
          error_title: "Error",

          // 游戏结束相关
          you_win: "🎉 Congratulations! You win!",
          you_lose: "😔 AI wins, keep trying!",
          draw: "🤝 Draw!",
          game_over: "Game Over",

          // 主界面按钮
          global_ranking: "Global Ranking",
          ai_battle: "AI Battle",
          personal_center: "Personal Center",
          game_instructions: "Game Instructions",

          // 连接错误
          connection_failed: "Connection Failed",
          connection_error_detail:
            "Unable to connect to Pi Network, please check your network connection and try again",
          login_with_pi: "Login with Pi Account",
          login_benefits_note:
            "Login to enjoy full game features and Pi coin rewards",

          // 充值对话框
          recharge_amount_selection: "Recharge Amount Selection",
          custom_amount_placeholder: "Custom Amount",
          custom_recharge: "Custom Recharge",
          cancel: "Cancel",

          // 错误提示
          please_login_first: "Please login first",
          create_order_failed: "Failed to create order",
          network_error_retry: "Network error, please try again later",

          // 支付对话框
          payment_method: "Payment Method",
          pi_wallet_transfer: "📱 Pi Wallet Transfer",
          transfer_instruction:
            "Please use Pi wallet to transfer to the following address:",
          transfer_amount_warning:
            "⚠️ Please ensure the transfer amount is <strong>{0} π</strong>",
          transfer_memo: "Transfer memo: {0}",
          transaction_hash_placeholder: "Please enter transaction hash",
          transaction_hash_instruction:
            "After transfer completion, please copy the transaction hash from Pi wallet and paste it in the input box above",
          verify_payment: "Verify Payment",
          order_validity: "Order validity: 30 minutes",

          // 支付验证
          please_enter_transaction_hash: "Please enter transaction hash",
          recharge_success: "Recharge Successful",
          recharge_success_message:
            "Congratulations! Recharge {0} π successful!\nCurrent balance: {1} π",
          verification_failed: "Verification Failed",

          // 游戏流程确认
          timeout_game_over: "⏰ Thinking timeout, game failed!",
          login_success: "Login Successful",
          welcome_user: "Welcome, {0}",
          abandon_current_game: "Abandon Current Game",
          abandon_game_warning:
            "Current game is in progress, restarting will be recorded as a loss.\n\nAre you sure you want to abandon the current game?",
          restart_game: "Restart Game",
          restart_game_confirm: "Are you sure you want to restart?",
          abandon_game_return_warning:
            "Current game is in progress, returning to main menu will be recorded as a loss.\n\nAre you sure you want to abandon the current game?",

          // 胜负显示格式
          wins_losses_format: "({0}W {1}L)",
          monthly_games: "Monthly Games",
          play_again: "Play Again",
          view_leaderboard: "View Leaderboard",
          login_now: "Login Now",
          guest_mode: "Guest Mode",
          guest_mode_desc:
            "You are currently playing as a guest, game results will not be recorded on the leaderboard.",
          login_benefits: "Benefits after login:",
          benefit_stats: "• 📊 Game statistics",
          benefit_leaderboard: "• 🏆 Participate in leaderboard competition",
          benefit_pi_service: "• 💰 Pi coin value-added services",
          benefit_monthly_rewards: "• 🎁 Monthly reward activities",
          rank_position: "#{0}",
        },

        ko: {
          // 기본 인터페이스
          noscript:
            "이 애플리케이션을 실행하려면 JavaScript를 활성화해야 합니다.",
          game_title: "오목",
          game_subtitle: "pinetwork 블록체인에서 실행되는 오목 게임",
          online_match: "온라인 매칭",
          global_ranking: "글로벌 순위",
          ai_battle: "AI 대전",
          personal_center: "개인 센터",
          game_instructions: "게임 설명",
          error_message: "❌ 오류 메시지",
          login_with_pi: "Pi Network로 로그인",
          login_note:
            "로그인을 클릭하면 Pi Network 계정을 사용한 인증에 동의하는 것입니다",

          // 언어 옵션
          lang_zh: "中文",
          lang_en: "English",
          lang_ko: "한국어",
          lang_ja: "日本語",
          lang_vi: "Tiếng Việt",

          // 게임 관련
          current_player: "현재 플레이어",
          your_turn: "당신의 차례",
          opponent_turn: "상대방의 차례",
          ai_thinking: "🤖 AI가 생각 중...",
          thinking_time: "⏱️ 생각 시간: {0}초",
          remaining_time: "⚠️ 남은 시간: {0}초",
          timeout_warning: "🚨 시간 초과 경고: {0}초",
          timeout: "⏰ 시간 초과",

          // 게임 결과
          you_win: "🎉 축하합니다! 승리!",
          you_lose: "😔 죄송합니다, 패배",
          draw: "🤝 무승부",
          game_over: "게임 종료",

          // 버튼 및 작업
          new_game: "새 게임",
          undo: "무르기",
          restart: "다시 시작",
          back_to_menu: "메뉴로 돌아가기",
          confirm: "확인",
          cancel: "취소",
          close: "닫기",
          save: "저장",
          update: "업데이트",
          enter_game: "게임 시작",

          // 개인 센터
          personal_info: "개인 정보",
          game_stats: "게임 통계",
          total_games: "총 게임 수",
          wins: "승리",
          losses: "패배",
          win_rate: "승률",
          current_rank: "현재 순위",
          wallet_address: "지갑 주소",
          balance: "잔액",
          nickname: "닉네임",
          avatar: "아바타",

          // 오류 및 알림
          connection_failed: "연결 실패",
          network_error: "네트워크 오류, 연결을 확인하고 다시 시도하세요",
          login_failed: "로그인 실패",
          insufficient_balance: "잔액 부족",
          invalid_move: "유효하지 않은 수",
          game_not_started: "게임이 시작되지 않음",

          // 결제 관련
          payment_confirm: "결제 확인",
          payment_success: "결제 성공",
          payment_failed: "결제 실패",
          payment_cancelled: "결제 취소됨",
          recharge: "충전",

          // 순위표
          leaderboard: "순위표",
          rank: "순위",
          player: "플레이어",
          score: "점수",
          games_played: "플레이한 게임",

          // 기타
          loading: "로딩 중...",
          connecting: "연결 중...",
          please_wait: "잠시 기다려 주세요...",
          success: "성공",
          failed: "실패",
          connecting_pi_network: "Pi Network 연결 중...",
          entering_game: "게임 진입 중...",

          // 팝업 및 알림
          hint: "힌트",
          confirm_purchase: "구매 확인",
          confirm_payment: "결제 확인",
          payment_amount: "{0} π",
          enter_nickname: "닉네임을 입력하세요",
          nickname_too_long: "닉네임은 20자를 초과할 수 없습니다",
          nickname_forbidden:
            "닉네임에 금지된 단어가 포함되어 있습니다. 다시 입력하세요",
          logout_confirm: "로그아웃 확인",
          logout_message:
            "정말 로그아웃하시겠습니까? 모든 로컬 저장 데이터가 삭제됩니다.",
          logout_success: "로그아웃 성공",
          logout_success_message: "성공적으로 로그아웃되었습니다!",
          please_login_first: "먼저 로그인하세요",

          // 게임 설명
          game_instructions_title: "게임 설명",
          game_history_title: "오목 역사",
          game_history_desc:
            '전설에 따르면 오목은 4000여 년 전 요 황제 시대에 탄생했습니다. 요 황제가 아들 단주를 교육하기 위해 돌바둑을 발명했고, 후에 순 황제가 "오성연주" 놀이로 개량하여 점차 현대 오목의 원형을 형성했습니다.\n요순 시대의 민속 게임에서 남북조 시대 동아시아로 전파되고, 일본에서 경기 스포츠로 개량되어 최종적으로 세계적인 바둑 프로젝트가 되었습니다.',

          // 게임 설명 상세 내용
          game_history_section: "오목 역사 유래",
          game_rules_section: "게임 규칙",
          game_rules_title: "🎯 기본 규칙",

          // 개인 센터
          personal_center_title: "개인 센터",
          wallet_address_placeholder: "50자 지갑 주소 입력 (대문자와 숫자)",
          wallet_address_format: "지갑 주소 형식: 50자 대문자와 숫자",

          // 결제 관련
          insufficient_balance_title: "잔액 부족",
          insufficient_balance_message:
            "무르기에는 0.1 π가 필요하며, 현재 잔액 {0} π, 잔액이 부족합니다.\n\n충전하시겠습니까?",
          recharge_prompt:
            "게임 계정에 Pi 코인을 충전하고 더 많은 게임 기능을 즐기세요!",
          continue_without_recharge:
            "현재 게임을 계속할 수 있지만 다시 시작할 수 없습니다. 충전 후 이 기능을 잠금 해제하세요.",
          undo_success: "무르기 성공",
          undo_success_message: "0.1 π 소모, 잔액: {0} π",
          undo_failed: "무르기 실패",
          network_error_retry: "네트워크 오류, 나중에 다시 시도하세요",
          invalid_amount: "유효한 충전 금액을 입력하세요 (최소 0.1π)",

          // 아이템 이름
          item_hint: "힌트 아이템",
          item_undo: "무르기 티켓",
          item_theme: "테마 팩",
          item_vip: "VIP 멤버십",
          item_unknown: "알 수 없는 아이템",

          // 순위표 및 통계
          current_ranking: "🎯 현재 순위: #{0} | ({1}승{2}패) | 승률: {3}%",
          leaderboard_update_tip:
            "순위표가 실시간으로 업데이트됩니다. 계속 게임하여 순위를 올리세요!",

          // 승률 순위 시스템
          score_system: "🏆 승률 순위 시스템",
          initial_score: "순위 기준: 승률 순으로 정렬",
          win_score: "승리: 승률 향상",
          draw_score: "무승부: 승률에 영향",
          lose_score: "패배: 승률 감소",
          quit_score: "포기/타임아웃: 패배로 기록",

          // 월간 순위 규칙
          monthly_ranking_rules: "🎯 월간 순위 규칙:",
          ranking_requirement: "• 순위 참여에는 최소 1게임 필요",
          ranking_criteria: "• 승률 순으로 순위 결정, 동률 시 승수로 정렬",

          // 게임 설명 상세 규칙
          basic_rules_detail_1:
            "15×15 바둑판에서 플레이어는 흑돌, AI는 백돌을 사용합니다",
          basic_rules_detail_2:
            "양측이 번갈아 돌을 놓으며, 먼저 5개를 연결하는 쪽이 승리합니다",
          basic_rules_detail_3:
            "5개 돌은 가로, 세로, 대각선 어느 방향이든 연결 가능합니다",
          basic_rules_detail_4:
            "바둑판이 가득 차도 승부가 나지 않으면 무승부입니다",

          // 턴 시간 규칙
          turn_time_rules: "⏱️ 턴 시간 규칙",
          thinking_time_rule: "사고 시간: 턴당 60초 사고 시간",
          time_warning_rule: "시간 알림: 30초 남으면 노란색 경고",
          urgent_warning_rule: "긴급 알림: 마지막 10초에 빨간색 깜빡임",
          timeout_rule: "시간 초과 패배: 시간 초과 시 자동으로 패배 기록",

          // 게임 조작 상세
          game_operations: "🎮 게임 조작",
          place_stone: "돌 놓기: 빈 칸을 클릭하여 돌 놓기",
          undo_move:
            "무르기: 최근 한 수를 취소할 수 있음 (플레이어+AI 각각 한 수)",
          new_game_op: "새 게임: 다시 시작, 진행 중인 게임은 패배로 기록",
          return_op: "돌아가기: 게임 종료, 진행 중인 게임은 패배로 기록",

          // 점수 시스템
          score_system: "🏆 100점 생명력 시스템",
          initial_score: "초기 점수: 100점",
          win_score: "승리: +1점",
          draw_score: "무승부: 변화 없음",
          lose_score: "패배: -1점 (0점까지 차감)",
          quit_score: "포기/시간 초과: -1점",

          // 월간 순위 규칙
          monthly_ranking_rules: "🎯 월간 순위 규칙:",
          ranking_requirement: "• 순위 참여를 위해 최소 60게임 필요",
          ranking_criteria: "• 남은 점수 순으로 순위 결정, 동점 시 승률로 정렬",
          ranking_rewards: "• 월말 순위에 따라 보상 지급",
          anti_farming:
            "⚠️ 점수 조작 방지: 게임을 하지 않거나 너무 적게 한 플레이어는 순위에서 제외",

          // 월간 보상 규칙
          monthly_rewards: "🏆 월간 보상 규칙",
          reward_pool_allocation: "💰 보상 풀 배분",
          reward_settlement: "매월 마지막 날 마지막 시간에 정산",
          reward_pool_percentage: "보상 풀은 플랫폼 월간 수익의 50%",
          reward_example: "예: 월간 수익 100π, 보상 풀 50π",

          // 상위 3명 배분
          top_three_distribution: "🥇 상위 3명 배분 비율",
          first_place: "🥇 1등",
          second_place: "🥈 2등",
          third_place: "🥉 3등",

          // 지급 방식
          distribution_method: "📋 지급 방식",
          wallet_distribution: "개인 센터에 저장된 지갑 주소로 수동 지급",
          valid_wallet_required:
            "수상자는 지갑 주소가 정확하고 유효한지 확인해야 함",
          next_day_distribution: "보상은 정산 다음 날 지급됩니다",
          invalid_wallet_rollover:
            "지갑 주소가 유효하지 않으면 보상은 다음 달로 이월됩니다",

          // 순위표 규칙
          leaderboard_rules: "📊 순위표 규칙",
          ranking_condition: "순위 조건: 60게임 완료 시 순위표 등재",
          ranking_basis: "순위 기준: 누적 점수 순으로 정렬",
          data_statistics: "데이터 통계: 역사적 누적 데이터 기반",
          realtime_update: "실시간 업데이트: 각 게임 종료 후 즉시 업데이트",

          // 따뜻한 팁
          warm_tips:
            "🎋 천년의 지혜를 계승하고, 고전 바둑의 아름다움을 경험하세요\n💡 시간을 합리적으로 배분하고, 사고의 즐거움을 만끽하세요",

          // 게임 결과 관련
          game_result: "게임 결과",
          congratulations_win: "🎉 축하합니다! 승리!",
          sorry_lose: "😔 죄송합니다, 패배했습니다",
          draw_result: "🤝 무승부",
          current_score: "현재 점수",
          win_rate_display: "승률",
          total_games_display: "총 게임 수",
          current_rank_display: "현재 순위",
          not_ranked: "순위 없음",
          guest_mode: "게스트 모드",
          guest_mode_desc:
            "현재 게스트로 게임 중이며, 게임 결과는 순위표에 기록되지 않습니다.",
          login_benefits: "로그인 후 혜택:",
          benefit_stats: "• 📊 게임 데이터 통계",
          benefit_leaderboard: "• 🏆 순위표 경쟁 참여",
          benefit_pi_service: "• 💰 Pi 코인 부가 서비스",
          benefit_monthly_rewards: "• 🎁 월간 보상 활동",
          play_again: "다시 플레이",
          view_leaderboard: "순위표 보기",
          login_now: "지금 로그인",

          // 게임 인터페이스
          return_to_menu: "돌아가기",
          guest_mode_short: "🎮 게스트 모드",
          ai_battle_title: "🧠 AI 대전",
          player_label: "플레이어",
          ai_label: "AI",
          vs_label: "VS",
          undo_button: "무르기",
          new_game_button: "새 게임",

          // 무르기 관련
          undo_confirm: "무르기 확인",
          undo_confirm_message:
            "무르기에는 0.1 π가 필요합니다\n현재 잔액: {0} π\n\n무르기를 확인하시겠습니까?",
          undo_success_title: "무르기 성공",
          undo_success_detail: "0.1 π 소모, 잔액: {0} π",
          undo_failed_title: "무르기 실패",
          undo_failed_message: "결제 실패",
          insufficient_balance_undo:
            "무르기에는 0.1 π가 필요하며, 현재 잔액 {0} π, 잔액이 부족합니다.\n\n충전하시겠습니까?",
          continue_game_tip:
            "현재 게임을 계속할 수 있지만 다시 시작할 수 없습니다. 충전 후 이 기능을 잠금 해제하세요.",

          // 충전 관련
          recharge_dialog_title: "💰 계정 충전",
          payment_dialog_title: "💳 Pi 코인 결제",
          recharge_amount_display: "충전 {0} π",
          order_id_display: "주문 번호: {0}",
          custom_amount_error: "유효한 충전 금액을 입력하세요 (최소 0.1π)",

          // 개인 센터 상세 내용
          monthly_reward_reminder: "🏆 월간 보상 알림",
          monthly_reward_desc:
            "월간 수익의 50%가 상위 3명 플레이어에게 보상으로 배분됩니다",

          // 월간 보상 상세 설명
          reward_settlement_detail: "매월 마지막 날 마지막 시간에 정산",
          reward_pool_50_percent: "보상 풀은 플랫폼 월간 수익의 50%",
          reward_example_detail: "예: 월간 수익 100π, 보상 풀 50π",
          reward_distribution_manual:
            "개인 센터에 저장된 지갑 주소로 수동 지급",
          reward_wallet_valid:
            "수상자는 지갑 주소가 정확하고 유효한지 확인해야 함",
          reward_next_day: "보상은 정산 다음 날 지급됩니다",
          reward_invalid_rollover:
            "지갑 주소가 유효하지 않으면 보상은 다음 달로 이월됩니다",
          reward_example_calculation: "💡 예시: 월간 수익 100π, 보상 풀 50π",
          first_place_reward: "🥇1등: 25π",
          second_place_reward: "🥈2등: 15π",
          third_place_reward: "🥉3등: 10π",

          // 전역 순위표
          global_ranking_title: "글로벌 순위",
          ranking_subtitle: "📊 월간 승률 기반 순위",
          ranking_header_rank: "순위",
          ranking_header_nickname: "닉네임",
          ranking_header_games: "총 게임",
          ranking_header_winrate: "승률",
          current_rank_not_listed: "현재 순위: 미등재",
          current_rank_label: "현재 순위",
          not_listed: "미등재",
          play_one_game_to_rank:
            "🎮 1게임 완료하면 순위표에 등재됩니다! 오목 여행을 시작하세요!",

          // 개인 센터 상세 라벨
          personal_profile_section: "개인 프로필",
          avatar_nickname_section: "아바타와 닉네임",
          click_avatar_edit: "아바타 클릭하여 편집",
          click_nickname_edit: "닉네임 클릭하여 편집",
          account_info_section: "계정 정보",
          game_stats_section: "게임 통계",
          wallet_address_label: "지갑 주소",
          account_balance_display: "계정 잔액",
          refresh_balance_btn: "잔액 새로고침",
          logout_btn: "로그아웃",

          // 게임 통계 라벨
          total_games_label: "총 게임",
          wins_label: "승리",
          win_rate_label: "승률",
          current_score_label: "현재 점수",
          current_rank_label: "현재 순위",

          // 잔액 조회 상태
          balance_querying: "조회 중...",
          balance_query_failed_display: "조회 실패",
          balance_tooltip: "총 충전: {0} π\n총 소비: {1} π",

          // 결제 성공 정보
          payment_success_title: "결제 성공",
          payment_success_message: "결제 성공!",
          purchase_success_message: "{0}을(를) 성공적으로 구매했습니다",
          transaction_id: "거래 ID: {0}",

          // 개인 센터 입력 힌트
          enter_avatar_emoji: "이모지 아바타 입력 (예: 😊)",
          click_to_set_nickname: "닉네임 설정하려면 클릭",
          enter_your_nickname: "닉네임을 입력하세요",
          loading_text_display: "로딩 중...",
          refresh_balance_text: "🔄 잔액 새로고침",
          recharge_text: "💰 충전",
          wallet_format_hint: "지갑 주소 형식: 50자 대문자와 숫자",
          save_wallet: "💾 저장",
          edit_wallet: "✏️ 편집",
          logout_account_text: "↩️ 계정 로그아웃",

          // 개인 센터 힌트 정보
          enter_avatar_hint: "아바타 이모지를 입력하세요",
          single_emoji_hint: "단일 이모지를 입력하세요",
          avatar_updated: "아바타가 업데이트되었습니다!",
          nickname_updated: "닉네임이 업데이트되었습니다!",
          enter_wallet_hint: "지갑 주소를 입력하세요",
          wallet_length_error:
            "❌ 표준 지갑 주소가 아닙니다!\n\n현재 길이: {0}자\n표준 길이: 50자\n\n완전한 50자 지갑 주소를 입력하세요",
          wallet_format_error:
            "❌ 지갑 주소 형식 오류!\n\n대문자(A-Z)와 숫자(0-9)만 허용됩니다\n입력 내용을 확인하세요",
          wallet_saved_success: "✅ 지갑 주소가 성공적으로 저장되었습니다!",
          edit_mode_title: "편집 모드",
          edit_mode_message:
            "💡 편집 모드가 활성화되었습니다\n\n지갑 주소를 수정한 후 저장을 클릭하세요",
          success_title: "성공",
          error_title: "오류",

          // 게임 종료 관련
          you_win: "🎉 축하합니다! 승리!",
          you_lose: "😔 AI가 승리했습니다, 다시 도전하세요!",
          draw: "🤝 무승부!",
          game_over: "게임 종료",

          // 메인 인터페이스 버튼
          global_ranking: "글로벌 순위",
          ai_battle: "AI 대전",
          personal_center: "개인 센터",
          game_instructions: "게임 설명",

          // 연결 오류
          connection_failed: "연결 실패",
          connection_error_detail:
            "Pi Network에 연결할 수 없습니다. 네트워크 연결을 확인한 후 다시 시도하세요",
          login_with_pi: "Pi 계정으로 로그인",
          login_benefits_note:
            "로그인 후 완전한 게임 기능과 Pi 코인 보상을 즐기세요",

          // 충전 대화상자
          recharge_amount_selection: "충전 금액 선택",
          custom_amount_placeholder: "사용자 정의 금액",
          custom_recharge: "사용자 정의 충전",
          cancel: "취소",

          // 오류 알림
          please_login_first: "먼저 로그인하세요",
          create_order_failed: "주문 생성 실패",
          network_error_retry: "네트워크 오류, 나중에 다시 시도하세요",
          pi_login_failed: "Pi Network 로그인 실패",
          login_error: "로그인 중 오류 발생",
          pi_sdk_not_loaded:
            "Pi Network SDK가 로드되지 않아 결제 기능을 사용할 수 없습니다",
          create_payment_failed: "결제 생성 실패",

          // 결제 대화상자
          payment_method: "결제 방법",
          pi_wallet_transfer: "📱 Pi 지갑 송금",
          transfer_instruction: "Pi 지갑을 사용하여 다음 주소로 송금하세요:",
          transfer_amount_warning:
            "⚠️ 송금 금액이 <strong>{0} π</strong>인지 확인하세요",
          transfer_memo: "송금 메모: {0}",
          transaction_hash_placeholder: "거래 해시를 입력하세요",
          transaction_hash_instruction:
            "송금 완료 후 Pi 지갑에서 거래 해시를 복사하여 위 입력란에 붙여넣으세요",
          verify_payment: "결제 확인",
          order_validity: "주문 유효기간: 30분",

          // 결제 확인
          please_enter_transaction_hash: "거래 해시를 입력하세요",
          recharge_success: "충전 성공",
          recharge_success_message:
            "축하합니다! {0} π 충전 성공!\n현재 잔액: {1} π",
          verification_failed: "확인 실패",

          // 게임 흐름 확인
          timeout_game_over: "⏰ 사고 시간 초과, 게임 실패!",
          login_success: "로그인 성공",
          welcome_user: "환영합니다, {0}",
          abandon_current_game: "현재 게임 포기",
          abandon_game_warning:
            "현재 게임이 진행 중입니다. 다시 시작하면 패배로 기록됩니다.\n\n현재 게임을 포기하시겠습니까?",
          restart_game: "게임 다시 시작",
          restart_game_confirm: "다시 시작하시겠습니까?",
          abandon_game_return_warning:
            "현재 게임이 진행 중입니다. 메인 메뉴로 돌아가면 패배로 기록됩니다.\n\n현재 게임을 포기하시겠습니까?",

          // 승부 표시 형식
          wins_losses_format: "({0}승{1}패)",
          monthly_games: "월간 게임",
          play_again: "다시 플레이",
          view_leaderboard: "순위표 보기",
          login_now: "지금 로그인",
          guest_mode: "게스트 모드",
          guest_mode_desc:
            "현재 게스트로 게임 중이며, 게임 결과는 순위표에 기록되지 않습니다.",
          login_benefits: "로그인 후 혜택:",
          benefit_stats: "• 📊 게임 통계",
          benefit_leaderboard: "• 🏆 순위표 경쟁 참여",
          benefit_pi_service: "• 💰 Pi 코인 부가가치 서비스",
          benefit_monthly_rewards: "• 🎁 월간 보상 활동",
          rank_position: "#{0}위",

          // 온라인 매칭 관련
          searching_opponent: "상대방을 찾는 중...",
          online_players: "현재 온라인 플레이어",
          people_suffix: "명",
          match_description: "시스템이 실력이 비슷한 상대방을 매칭해드립니다",
          estimated_wait: "예상 대기 시간: 30-60초",
          match_found: "상대방을 찾았습니다!",
          ai_opponent_name: "AI 스마트 상대",
          black_stone: "흑돌",
          white_stone: "백돌",
        },

        ja: {
          // 基本インターフェース
          noscript:
            "このアプリケーションを実行するにはJavaScriptを有効にする必要があります。",
          game_title: "五目並べ",
          game_subtitle: "pinetworkブロックチェーン上で動作する五目並べゲーム",
          online_match: "オンラインマッチ",
          global_ranking: "グローバルランキング",
          ai_battle: "AI対戦",
          personal_center: "個人センター",
          game_instructions: "ゲーム説明",
          error_message: "❌ エラーメッセージ",
          login_with_pi: "Pi Networkでログイン",
          login_note:
            "ログインをクリックすると、Pi Networkアカウントを使用した認証に同意したことになります",

          // 言語オプション
          lang_zh: "中文",
          lang_en: "English",
          lang_ko: "한국어",
          lang_ja: "日本語",
          lang_vi: "Tiếng Việt",

          // ゲーム関連
          current_player: "現在のプレイヤー",
          your_turn: "あなたの番",
          opponent_turn: "相手の番",
          ai_thinking: "🤖 AIが考え中...",
          thinking_time: "⏱️ 思考時間: {0}秒",
          remaining_time: "⚠️ 残り時間: {0}秒",
          timeout_warning: "🚨 タイムアウト警告: {0}秒",
          timeout: "⏰ タイムアウト",

          // ゲーム結果
          you_win: "🎉 おめでとうございます！勝利！",
          you_lose: "😔 残念、敗北",
          draw: "🤝 引き分け",
          game_over: "ゲーム終了",

          // ボタンと操作
          new_game: "新しいゲーム",
          undo: "待った",
          restart: "再開",
          back_to_menu: "メニューに戻る",
          confirm: "確認",
          cancel: "キャンセル",
          close: "閉じる",
          save: "保存",
          update: "更新",
          enter_game: "ゲーム開始",

          // 個人センター
          personal_info: "個人情報",
          game_stats: "ゲーム統計",
          total_games: "総ゲーム数",
          wins: "勝利",
          losses: "敗北",
          win_rate: "勝率",
          current_rank: "現在のランク",
          wallet_address: "ウォレットアドレス",
          balance: "残高",
          nickname: "ニックネーム",
          avatar: "アバター",

          // エラーと通知
          connection_failed: "接続失敗",
          network_error: "ネットワークエラー、接続を確認して再試行してください",
          login_failed: "ログイン失敗",
          insufficient_balance: "残高不足",
          invalid_move: "無効な手",
          game_not_started: "ゲームが開始されていません",

          // 支払い関連
          payment_confirm: "支払い確認",
          payment_success: "支払い成功",
          payment_failed: "支払い失敗",
          payment_cancelled: "支払いキャンセル",
          recharge: "チャージ",

          // ランキング
          leaderboard: "ランキング",
          rank: "ランク",
          player: "プレイヤー",
          score: "スコア",
          games_played: "プレイしたゲーム",

          // その他
          loading: "読み込み中...",
          connecting: "接続中...",
          please_wait: "お待ちください...",
          success: "成功",
          failed: "失敗",
          connecting_pi_network: "Pi Networkに接続中...",
          entering_game: "ゲーム開始中...",

          // ポップアップと通知
          hint: "ヒント",
          confirm_purchase: "購入確認",
          confirm_payment: "支払い確認",
          payment_amount: "{0} π",
          enter_nickname: "ニックネームを入力してください",
          nickname_too_long: "ニックネームは20文字を超えることはできません",
          nickname_forbidden:
            "ニックネームに禁止された単語が含まれています。再入力してください",
          logout_confirm: "ログアウト確認",
          logout_message:
            "本当にログアウトしますか？すべてのローカル保存データが削除されます。",
          logout_success: "ログアウト成功",
          logout_success_message: "正常にログアウトしました！",
          please_login_first: "まずログインしてください",

          // ゲーム説明
          game_instructions_title: "ゲーム説明",
          game_history_title: "五目並べの歴史",
          game_history_desc:
            "伝説によると、五目並べは4000年以上前の堯帝時代に誕生しました。堯帝が息子の丹朱を教育するために石子棋を発明し、後に舜帝が「五星連珠」の遊び方に改良して、徐々に現代五目並べの原型を形成しました。\n堯舜時代の民俗ゲームから、南北朝時代に東アジアに伝播し、日本で競技スポーツに改良され、最終的に世界的な棋類プロジェクトとなりました。",

          // ゲーム説明詳細内容
          game_history_section: "五目並べ歴史の由来",
          game_rules_section: "ゲームルール",
          game_rules_title: "🎯 基本ルール",

          // 個人センター
          personal_center_title: "個人センター",
          wallet_address_placeholder:
            "50文字のウォレットアドレスを入力（大文字と数字）",
          wallet_address_format: "ウォレットアドレス形式：50文字の大文字と数字",

          // 支払い関連
          insufficient_balance_title: "残高不足",
          insufficient_balance_message:
            "待ったには0.1 πが必要で、現在の残高{0} π、残高が不足しています。\n\nチャージしますか？",
          recharge_prompt:
            "ゲームアカウントにPiコインをチャージして、より多くのゲーム機能をお楽しみください！",
          continue_without_recharge:
            "現在のゲームを続けることはできますが、再開はできません。チャージ後にこの機能のロックを解除してください。",
          undo_success: "待った成功",
          undo_success_message: "0.1 π消費、残高：{0} π",
          undo_failed: "待った失敗",
          network_error_retry: "ネットワークエラー、後でもう一度お試しください",
          invalid_amount: "有効なチャージ金額を入力してください（最低0.1π）",

          // アイテム名
          item_hint: "ヒントアイテム",
          item_undo: "待ったチケット",
          item_theme: "テーマパック",
          item_vip: "VIPメンバーシップ",
          item_unknown: "不明なアイテム",

          // ランキングと統計
          current_ranking: "🎯 現在のランク: #{0} | ({1}勝{2}敗) | 勝率: {3}%",
          leaderboard_update_tip:
            "ランキングはリアルタイムで更新されます。ゲームを続けてランクを上げましょう！",

          // ゲーム説明詳細ルール
          basic_rules_detail_1:
            "15×15の盤面で、プレイヤーは黒石、AIは白石を使用します",
          basic_rules_detail_2:
            "両者が交互に石を置き、先に5つを連結した方が勝利です",
          basic_rules_detail_3:
            "5つの石は横、縦、斜めのいずれの方向でも連結可能です",
          basic_rules_detail_4:
            "盤面が満杯になっても勝負がつかない場合は引き分けです",

          // ターン時間ルール
          turn_time_rules: "⏱️ ターン時間ルール",
          thinking_time_rule: "思考時間：ターンごとに60秒の思考時間",
          time_warning_rule: "時間警告：残り30秒で黄色警告",
          urgent_warning_rule: "緊急警告：最後の10秒で赤色点滅",
          timeout_rule: "タイムアウト敗北：タイムアウト時は自動的に敗北記録",

          // ゲーム操作詳細
          game_operations: "🎮 ゲーム操作",
          place_stone: "石を置く：空いているマスをクリックして石を置く",
          undo_move:
            "待った：最近の一手を取り消すことができます（プレイヤー+AI各一手）",
          new_game_op: "新しいゲーム：再開始、進行中のゲームは敗北として記録",
          return_op: "戻る：ゲーム終了、進行中のゲームは敗北として記録",

          // スコアシステム
          score_system: "🏆 勝率ランキングシステム",
          initial_score: "ランキング基準：勝率順でソート",
          win_score: "勝利：勝率向上",
          draw_score: "引き分け：勝率に影響",
          lose_score: "敗北：勝率低下",
          quit_score: "放棄/タイムアウト：敗北として記録",

          // 月間ランキングルール
          monthly_ranking_rules: "🎯 月間ランキングルール：",
          ranking_requirement: "• ランキング参加には最低1ゲームが必要",
          ranking_criteria:
            "• 残りポイント順でランキング決定、同点時は勝率でソート",
          ranking_rewards: "• 月末にランキングに応じて報酬配布",
          anti_farming:
            "⚠️ スコア操作防止：ゲームをしないか少なすぎるプレイヤーはランキングから除外",

          // 月間報酬ルール
          monthly_rewards: "🏆 月間報酬ルール",
          reward_pool_allocation: "💰 報酬プール配分",
          reward_settlement: "毎月最終日の最終時間に決算",
          reward_pool_percentage: "報酬プールはプラットフォーム月間利益の50%",
          reward_example: "例：月間利益100π、報酬プール50π",

          // トップ3配分
          top_three_distribution: "🥇 トップ3配分比率",
          first_place: "🥇 1位",
          second_place: "🥈 2位",
          third_place: "🥉 3位",

          // 配布方式
          distribution_method: "📋 配布方式",
          wallet_distribution:
            "個人センターに保存されたウォレットアドレスに手動配布",
          valid_wallet_required:
            "受賞者はウォレットアドレスが正確で有効であることを確認する必要があります",
          next_day_distribution: "報酬は決算翌日に配布されます",
          invalid_wallet_rollover:
            "ウォレットアドレスが無効な場合、報酬は翌月に繰り越されます",

          // ランキングルール
          leaderboard_rules: "📊 ランキングルール",
          ranking_condition: "ランキング条件：60ゲーム完了でランキング掲載",
          ranking_basis: "ランキング基準：累積ポイント順でソート",
          data_statistics: "データ統計：歴史的累積データに基づく",
          realtime_update: "リアルタイム更新：各ゲーム終了後即座に更新",

          // 温かいヒント
          warm_tips:
            "🎋 千年の知恵を継承し、古典的な棋芸の美しさを体験してください\n💡 時間を合理的に配分し、思考の楽しさを満喫してください",

          // ゲーム結果関連
          game_result: "ゲーム結果",
          congratulations_win: "🎉 おめでとうございます！勝利！",
          sorry_lose: "😔 申し訳ございません、敗北しました",
          draw_result: "🤝 引き分け",
          current_score: "現在のスコア",
          win_rate_display: "勝率",
          total_games_display: "総ゲーム数",
          current_rank_display: "現在のランク",
          not_ranked: "ランク外",
          guest_mode: "ゲストモード",
          guest_mode_desc:
            "現在ゲストとしてゲーム中で、ゲーム結果はランキングに記録されません。",
          login_benefits: "ログイン後の特典：",
          benefit_stats: "• 📊 ゲームデータ統計",
          benefit_leaderboard: "• 🏆 ランキング競争参加",
          benefit_pi_service: "• 💰 Piコイン付加価値サービス",
          benefit_monthly_rewards: "• 🎁 月間報酬活動",
          play_again: "もう一度プレイ",
          view_leaderboard: "ランキングを見る",
          login_now: "今すぐログイン",

          // ゲームインターフェース
          return_to_menu: "戻る",
          guest_mode_short: "🎮 ゲストモード",
          ai_battle_title: "🧠 AI対戦",
          player_label: "プレイヤー",
          ai_label: "AI",
          vs_label: "VS",
          undo_button: "待った",
          new_game_button: "新しいゲーム",

          // 待った関連
          undo_confirm: "待った確認",
          undo_confirm_message:
            "待ったには0.1 πが必要です\n現在の残高：{0} π\n\n待ったを確認しますか？",
          undo_success_title: "待った成功",
          undo_success_detail: "0.1 π消費、残高：{0} π",
          undo_failed_title: "待った失敗",
          undo_failed_message: "支払い失敗",
          insufficient_balance_undo:
            "待ったには0.1 πが必要で、現在の残高{0} π、残高が不足しています。\n\nチャージしますか？",
          continue_game_tip:
            "現在のゲームを続けることはできますが、再開はできません。チャージ後にこの機能のロックを解除してください。",

          // チャージ関連
          recharge_dialog_title: "💰 アカウントチャージ",
          payment_dialog_title: "💳 Piコイン支払い",
          recharge_amount_display: "チャージ {0} π",
          order_id_display: "注文番号：{0}",
          custom_amount_error:
            "有効なチャージ金額を入力してください（最低0.1π）",

          // 個人センター詳細内容
          monthly_reward_reminder: "🏆 月間報酬リマインダー",
          monthly_reward_desc:
            "月間利益の50%がトップ3プレイヤーに報酬として配分されます",

          // 月間報酬詳細説明
          reward_settlement_detail: "毎月最終日の最終時間に決算",
          reward_pool_50_percent: "報酬プールはプラットフォーム月間利益の50%",
          reward_example_detail: "例：月間利益100π、報酬プール50π",
          reward_distribution_manual:
            "個人センターに保存されたウォレットアドレスに手動配布",
          reward_wallet_valid:
            "受賞者はウォレットアドレスが正確で有効であることを確認する必要があります",
          reward_next_day: "報酬は決算翌日に配布されます",
          reward_invalid_rollover:
            "ウォレットアドレスが無効な場合、報酬は翌月に繰り越されます",
          reward_example_calculation: "💡 例：月間利益100π、報酬プール50π",
          first_place_reward: "🥇1位：25π",
          second_place_reward: "🥈2位：15π",
          third_place_reward: "🥉3位：10π",

          // グローバルランキング
          global_ranking_title: "グローバルランキング",
          ranking_subtitle: "📊 月間勝率に基づくランキング",
          ranking_header_rank: "ランク",
          ranking_header_nickname: "ニックネーム",
          ranking_header_games: "総ゲーム数",
          ranking_header_winrate: "勝率",
          current_rank_not_listed: "現在のランク：未掲載",
          current_rank_label: "現在のランク",
          not_listed: "未掲載",
          play_one_game_to_rank:
            "🎮 1ゲーム完了でランキング掲載！五目並べの旅を始めましょう！",

          // 個人センター詳細ラベル
          personal_profile_section: "個人プロフィール",
          avatar_nickname_section: "アバターとニックネーム",
          click_avatar_edit: "アバターをクリックして編集",
          click_nickname_edit: "ニックネームをクリックして編集",
          account_info_section: "アカウント情報",
          game_stats_section: "ゲーム統計",
          wallet_address_label: "ウォレットアドレス",
          account_balance_display: "アカウント残高",
          refresh_balance_btn: "残高更新",
          logout_btn: "ログアウト",

          // ゲーム統計ラベル
          total_games_label: "総ゲーム数",
          wins_label: "勝利",
          win_rate_label: "勝率",
          current_score_label: "現在のスコア",
          current_rank_label: "現在のランク",

          // 残高照会状態
          balance_querying: "照会中...",
          balance_query_failed_display: "照会失敗",
          balance_tooltip: "総チャージ：{0} π\n総消費：{1} π",

          // 支払い成功情報
          payment_success_title: "支払い成功",
          payment_success_message: "支払い成功！",
          purchase_success_message: "{0}を正常に購入しました",
          transaction_id: "取引ID：{0}",

          // 個人センター入力ヒント
          enter_avatar_emoji: "絵文字アバターを入力（例：😊）",
          click_to_set_nickname: "ニックネーム設定はクリック",
          enter_your_nickname: "ニックネームを入力してください",
          loading_text_display: "読み込み中...",
          refresh_balance_text: "🔄 残高更新",
          recharge_text: "💰 チャージ",
          wallet_format_hint: "ウォレットアドレス形式：50文字の大文字と数字",
          save_wallet: "💾 保存",
          edit_wallet: "✏️ 編集",
          logout_account_text: "↩️ アカウントログアウト",

          // 個人センターヒント情報
          enter_avatar_hint: "アバター絵文字を入力してください",
          single_emoji_hint: "単一の絵文字を入力してください",
          avatar_updated: "アバターが更新されました！",
          nickname_updated: "ニックネームが更新されました！",
          enter_wallet_hint: "ウォレットアドレスを入力してください",
          wallet_length_error:
            "❌ これは標準ウォレットアドレスではありません！\n\n現在の長さ：{0}文字\n標準長さ：50文字\n\n完全な50文字のウォレットアドレスを入力してください",
          wallet_format_error:
            "❌ ウォレットアドレス形式エラー！\n\n大文字（A-Z）と数字（0-9）のみ許可されています\n入力内容を確認してください",
          wallet_saved_success: "✅ ウォレットアドレスが正常に保存されました！",
          edit_mode_title: "編集モード",
          edit_mode_message:
            "💡 編集モードが有効になりました\n\nウォレットアドレスを修正後、保存をクリックしてください",
          success_title: "成功",
          error_title: "エラー",

          // ゲーム終了関連
          you_win: "🎉 おめでとうございます！勝利！",
          you_lose: "😔 AIの勝利です、頑張って！",
          draw: "🤝 引き分け！",
          game_over: "ゲーム終了",

          // メインインターフェースボタン
          global_ranking: "グローバルランキング",
          ai_battle: "AI対戦",
          personal_center: "個人センター",
          game_instructions: "ゲーム説明",

          // 接続エラー
          connection_failed: "接続失敗",
          connection_error_detail:
            "Pi Networkに接続できません。ネットワーク接続を確認して再試行してください",
          login_with_pi: "Piアカウントでログイン",
          login_benefits_note:
            "ログイン後、完全なゲーム機能とPiコイン報酬をお楽しみください",

          // チャージダイアログ
          recharge_amount_selection: "チャージ金額選択",
          custom_amount_placeholder: "カスタム金額",
          custom_recharge: "カスタムチャージ",
          cancel: "キャンセル",

          // エラー通知
          please_login_first: "まずログインしてください",
          create_order_failed: "注文作成失敗",
          network_error_retry: "ネットワークエラー、後でもう一度お試しください",
          pi_login_failed: "Pi Networkログイン失敗",
          login_error: "ログイン中にエラーが発生しました",
          pi_sdk_not_loaded:
            "Pi Network SDKが読み込まれていないため、支払い機能が利用できません",
          create_payment_failed: "支払い作成失敗",

          // 支払いダイアログ
          payment_method: "支払い方法",
          pi_wallet_transfer: "📱 Piウォレット送金",
          transfer_instruction:
            "Piウォレットを使用して以下のアドレスに送金してください：",
          transfer_amount_warning:
            "⚠️ 送金金額が<strong>{0} π</strong>であることを確認してください",
          transfer_memo: "送金メモ：{0}",
          transaction_hash_placeholder: "取引ハッシュを入力してください",
          transaction_hash_instruction:
            "送金完了後、Piウォレットから取引ハッシュをコピーして上記の入力欄に貼り付けてください",
          verify_payment: "支払い確認",
          order_validity: "注文有効期限：30分",

          // 支払い確認
          please_enter_transaction_hash: "取引ハッシュを入力してください",
          recharge_success: "チャージ成功",
          recharge_success_message:
            "おめでとうございます！{0} π チャージ成功！\n現在の残高：{1} π",
          verification_failed: "確認失敗",

          // ゲームフロー確認
          timeout_game_over: "⏰ 思考時間超過、ゲーム失敗！",
          login_success: "ログイン成功",
          welcome_user: "ようこそ、{0}",
          abandon_current_game: "現在のゲームを放棄",
          abandon_game_warning:
            "現在のゲームが進行中です。再開始すると敗北として記録されます。\n\n現在のゲームを放棄しますか？",
          restart_game: "ゲーム再開始",
          restart_game_confirm: "再開始しますか？",
          abandon_game_return_warning:
            "現在のゲームが進行中です。メインメニューに戻ると敗北として記録されます。\n\n現在のゲームを放棄しますか？",

          // 勝敗表示形式
          wins_losses_format: "({0}勝{1}敗)",
          monthly_games: "月間ゲーム",
          play_again: "もう一度プレイ",
          view_leaderboard: "ランキングを見る",
          login_now: "今すぐログイン",
          guest_mode: "ゲストモード",
          guest_mode_desc:
            "現在ゲストとしてプレイしており、ゲーム結果はランキングに記録されません。",
          login_benefits: "ログイン後の特典:",
          benefit_stats: "• 📊 ゲーム統計",
          benefit_leaderboard: "• 🏆 ランキング競争への参加",
          benefit_pi_service: "• 💰 Piコイン付加価値サービス",
          benefit_monthly_rewards: "• 🎁 月間報酬活動",
          rank_position: "#{0}位",

          // オンラインマッチ関連
          searching_opponent: "対戦相手を検索中...",
          online_players: "現在のオンラインプレイヤー",
          people_suffix: "人",
          match_description: "システムが同レベルの対戦相手をマッチングします",
          estimated_wait: "予想待機時間：30-60秒",
          match_found: "対戦相手が見つかりました！",
          ai_opponent_name: "AIスマート対戦相手",
          black_stone: "黒石",
          white_stone: "白石",
        },

        vi: {
          // Giao diện cơ bản
          noscript: "Bạn cần bật JavaScript để chạy ứng dụng này.",
          game_title: "Cờ Carô",
          game_subtitle: "Trò chơi cờ carô chạy trên blockchain pinetwork",
          online_match: "Ghép Đôi Trực Tuyến",
          global_ranking: "Bảng Xếp Hạng Toàn Cầu",
          ai_battle: "Đấu với AI",
          personal_center: "Trung Tâm Cá Nhân",
          game_instructions: "Hướng Dẫn Trò Chơi",
          error_message: "❌ Thông Báo Lỗi",
          login_with_pi: "Đăng nhập bằng Pi Network",
          login_note:
            "Bằng cách nhấp đăng nhập, bạn đồng ý sử dụng tài khoản Pi Network để xác thực",

          // Tùy chọn ngôn ngữ
          lang_zh: "中文",
          lang_en: "English",
          lang_ko: "한국어",
          lang_ja: "日本語",
          lang_vi: "Tiếng Việt",

          // Liên quan đến trò chơi
          current_player: "Người Chơi Hiện Tại",
          your_turn: "Lượt Của Bạn",
          opponent_turn: "Lượt Của Đối Thủ",
          ai_thinking: "🤖 AI đang suy nghĩ...",
          thinking_time: "⏱️ Thời gian suy nghĩ: {0}s",
          remaining_time: "⚠️ Thời gian còn lại: {0}s",
          timeout_warning: "🚨 Cảnh báo hết thời gian: {0}s",
          timeout: "⏰ Hết thời gian",

          // Kết quả trò chơi
          you_win: "🎉 Chúc mừng! Bạn thắng!",
          you_lose: "😔 Tiếc quá, bạn thua",
          draw: "🤝 Hòa",
          game_over: "Kết Thúc Trò Chơi",

          // Nút và thao tác
          new_game: "Trò Chơi Mới",
          undo: "Hoàn Tác",
          restart: "Khởi Động Lại",
          back_to_menu: "Về Menu",
          confirm: "Xác Nhận",
          cancel: "Hủy",
          close: "Đóng",
          save: "Lưu",
          update: "Cập Nhật",
          enter_game: "Vào Game",

          // Trung tâm cá nhân
          personal_info: "Thông Tin Cá Nhân",
          game_stats: "Thống Kê Trò Chơi",
          total_games: "Tổng Số Trận",
          wins: "Thắng",
          losses: "Thua",
          win_rate: "Tỷ Lệ Thắng",
          current_rank: "Xếp Hạng Hiện Tại",
          wallet_address: "Địa Chỉ Ví",
          balance: "Số Dư",
          nickname: "Biệt Danh",
          avatar: "Hình Đại Diện",

          // Lỗi và thông báo
          connection_failed: "Kết Nối Thất Bại",
          network_error: "Lỗi mạng, vui lòng kiểm tra kết nối và thử lại",
          login_failed: "Đăng Nhập Thất Bại",
          insufficient_balance: "Số Dư Không Đủ",
          invalid_move: "Nước Đi Không Hợp Lệ",
          game_not_started: "Trò Chơi Chưa Bắt Đầu",

          // Liên quan đến thanh toán
          payment_confirm: "Xác Nhận Thanh Toán",
          payment_success: "Thanh Toán Thành Công",
          payment_failed: "Thanh Toán Thất Bại",
          payment_cancelled: "Thanh Toán Đã Hủy",
          recharge: "Nạp Tiền",

          // Bảng xếp hạng
          leaderboard: "Bảng Xếp Hạng",
          rank: "Xếp Hạng",
          player: "Người Chơi",
          score: "Điểm",
          games_played: "Trận Đã Chơi",

          // Khác
          loading: "Đang tải...",
          connecting: "Đang kết nối...",
          please_wait: "Vui lòng đợi...",
          success: "Thành Công",
          failed: "Thất Bại",
          connecting_pi_network: "Đang kết nối Pi Network...",
          entering_game: "Đang vào game...",

          // Popup và thông báo
          hint: "Gợi Ý",
          confirm_purchase: "Xác Nhận Mua",
          confirm_payment: "Xác Nhận Thanh Toán",
          payment_amount: "{0} π",
          enter_nickname: "Vui lòng nhập biệt danh",
          nickname_too_long: "Biệt danh không được vượt quá 20 ký tự",
          nickname_forbidden: "Biệt danh chứa từ bị cấm, vui lòng nhập lại",
          logout_confirm: "Xác Nhận Đăng Xuất",
          logout_message:
            "Bạn có chắc chắn muốn đăng xuất? Điều này sẽ xóa tất cả dữ liệu được lưu cục bộ.",
          logout_success: "Đăng Xuất Thành Công",
          logout_success_message: "Đã đăng xuất thành công!",
          please_login_first: "Vui lòng đăng nhập trước",

          // Hướng dẫn trò chơi
          game_instructions_title: "Hướng Dẫn Trò Chơi",
          game_history_title: "Lịch Sử Cờ Carô",
          game_history_desc:
            'Truyền thuyết kể rằng cờ carô ra đời cách đây hơn 4000 năm vào thời Hoàng đế Nghiêu. Nghiêu đã phát minh ra cờ đá để giáo dục con trai Đan Chu, sau đó được Thuấn cải tiến thành trò chơi "Ngũ tinh liên châu", dần hình thành nguyên mẫu của cờ carô hiện đại.\nTừ trò chơi dân gian thời Nghiêu-Thuấn, đến việc lan truyền sang Đông Á vào thời Nam Bắc triều, rồi được Nhật Bản cải tiến thành môn thể thao thi đấu, cuối cùng trở thành dự án cờ vua toàn cầu.',

          // Nội dung chi tiết hướng dẫn trò chơi
          game_history_section: "Nguồn Gốc Lịch Sử Cờ Carô",
          game_rules_section: "Luật Chơi",
          game_rules_title: "🎯 Quy Tắc Cơ Bản",

          // Trung tâm cá nhân
          personal_center_title: "Trung Tâm Cá Nhân",
          wallet_address_placeholder:
            "Nhập địa chỉ ví 50 ký tự (chữ hoa và số)",
          wallet_address_format: "Định dạng địa chỉ ví: 50 chữ hoa và số",

          // Liên quan đến thanh toán
          insufficient_balance_title: "Số Dư Không Đủ",
          insufficient_balance_message:
            "Hoàn tác cần 0.1 π, số dư hiện tại {0} π, số dư không đủ.\n\nBạn có muốn nạp tiền không?",
          recharge_prompt:
            "Nạp Pi coin vào tài khoản game của bạn và tận hưởng nhiều tính năng game hơn!",
          continue_without_recharge:
            "Bạn có thể tiếp tục trò chơi hiện tại nhưng không thể khởi động lại. Mở khóa tính năng này sau khi nạp tiền.",
          undo_success: "Hoàn Tác Thành Công",
          undo_success_message: "Đã tiêu thụ 0.1 π, số dư: {0} π",
          undo_failed: "Hoàn Tác Thất Bại",
          network_error_retry: "Lỗi mạng, vui lòng thử lại sau",
          invalid_amount: "Vui lòng nhập số tiền nạp hợp lệ (tối thiểu 0.1π)",

          // Tên vật phẩm
          item_hint: "Vật Phẩm Gợi Ý",
          item_undo: "Vé Hoàn Tác",
          item_theme: "Gói Chủ Đề",
          item_vip: "Thành Viên VIP",
          item_unknown: "Vật Phẩm Không Xác Định",

          // Bảng xếp hạng và thống kê
          current_ranking:
            "🎯 Xếp hạng hiện tại: #{0} | ({1}T {2}B) | Tỷ lệ thắng: {3}%",
          leaderboard_update_tip:
            "Bảng xếp hạng cập nhật theo thời gian thực, tiếp tục chơi để cải thiện xếp hạng của bạn!",

          // Quy tắc chi tiết trò chơi
          basic_rules_detail_1:
            "Trên bàn cờ 15×15, người chơi dùng quân đen, AI dùng quân trắng",
          basic_rules_detail_2:
            "Hai bên luân phiên đặt quân, ai nối được 5 quân trước sẽ thắng",
          basic_rules_detail_3:
            "5 quân có thể nối theo hướng ngang, dọc hoặc chéo",
          basic_rules_detail_4:
            "Nếu bàn cờ đầy mà không có ai thắng thì là hòa",

          // Quy tắc thời gian lượt
          turn_time_rules: "⏱️ Quy Tắc Thời Gian Lượt",
          thinking_time_rule: "Thời gian suy nghĩ: 60 giây mỗi lượt",
          time_warning_rule:
            "Cảnh báo thời gian: Cảnh báo màu vàng khi còn 30 giây",
          urgent_warning_rule:
            "Cảnh báo khẩn cấp: Nhấp nháy màu đỏ trong 10 giây cuối",
          timeout_rule:
            "Thua do hết thời gian: Hết thời gian sẽ tự động ghi nhận là thua",

          // Chi tiết thao tác trò chơi
          game_operations: "🎮 Thao Tác Trò Chơi",
          place_stone: "Đặt quân: Nhấp vào ô trống để đặt quân",
          undo_move:
            "Hoàn tác: Có thể hủy nước đi gần nhất (người chơi + AI mỗi bên một nước)",
          new_game_op:
            "Trò chơi mới: Bắt đầu lại, trò chơi đang diễn ra sẽ được ghi là thua",
          return_op:
            "Quay lại: Thoát trò chơi, trò chơi đang diễn ra sẽ được ghi là thua",

          // Hệ thống điểm số
          score_system: "🏆 Hệ Thống Xếp Hạng Tỷ Lệ Thắng",
          initial_score: "Cơ sở xếp hạng: Sắp xếp theo tỷ lệ thắng",
          win_score: "Thắng: Cải thiện tỷ lệ thắng",
          draw_score: "Hòa: Ảnh hưởng tỷ lệ thắng",
          lose_score: "Thua: Giảm tỷ lệ thắng",
          quit_score: "Bỏ cuộc/Hết thời gian: Ghi nhận là thua",

          // Quy tắc xếp hạng hàng tháng
          monthly_ranking_rules: "🎯 Quy Tắc Xếp Hạng Hàng Tháng:",
          ranking_requirement: "• Cần tối thiểu 1 trận để tham gia xếp hạng",
          ranking_criteria:
            "• Xếp hạng theo điểm còn lại, điểm bằng nhau thì sắp xếp theo tỷ lệ thắng",
          ranking_rewards: "• Phát thưởng cuối tháng dựa trên xếp hạng",
          anti_farming:
            "⚠️ Cơ chế chống gian lận: Người chơi không chơi hoặc chơi quá ít sẽ không tham gia xếp hạng",

          // Quy tắc thưởng hàng tháng
          monthly_rewards: "🏆 Quy Tắc Thưởng Hàng Tháng",
          reward_pool_allocation: "💰 Phân Bổ Quỹ Thưởng",
          reward_settlement: "Quyết toán vào giờ cuối của ngày cuối mỗi tháng",
          reward_pool_percentage:
            "Quỹ thưởng là 50% lợi nhuận hàng tháng của nền tảng",
          reward_example: "Ví dụ: Lợi nhuận tháng 100π, quỹ thưởng 50π",

          // Phân bổ top 3
          top_three_distribution: "🥇 Tỷ Lệ Phân Bổ Top 3",
          first_place: "🥇 Hạng Nhất",
          second_place: "🥈 Hạng Nhì",
          third_place: "🥉 Hạng Ba",

          // Phương thức phát thưởng
          distribution_method: "📋 Phương Thức Phát Thưởng",
          wallet_distribution:
            "Phát thưởng thủ công theo địa chỉ ví được lưu trong trung tâm cá nhân",
          valid_wallet_required:
            "Người thắng giải phải đảm bảo địa chỉ ví chính xác và hợp lệ",
          next_day_distribution:
            "Thưởng sẽ được phát vào ngày sau khi quyết toán",
          invalid_wallet_rollover:
            "Nếu địa chỉ ví không hợp lệ, thưởng sẽ được chuyển sang tháng sau",

          // Quy tắc bảng xếp hạng
          leaderboard_rules: "📊 Quy Tắc Bảng Xếp Hạng",
          ranking_condition:
            "Điều kiện xếp hạng: Hoàn thành 60 trận để được lên bảng",
          ranking_basis: "Cơ sở xếp hạng: Sắp xếp theo điểm tích lũy",
          data_statistics:
            "Thống kê dữ liệu: Dựa trên dữ liệu tích lũy lịch sử",
          realtime_update:
            "Cập nhật thời gian thực: Cập nhật ngay sau mỗi trận đấu",

          // Lời khuyên ấm áp
          warm_tips:
            "🎋 Kế thừa trí tuệ ngàn năm, trải nghiệm vẻ đẹp cờ cổ điển\n💡 Sắp xếp thời gian hợp lý, tận hưởng niềm vui suy nghĩ",

          // Liên quan đến kết quả trò chơi
          game_result: "Kết Quả Trò Chơi",
          congratulations_win: "🎉 Chúc mừng! Bạn thắng!",
          sorry_lose: "😔 Xin lỗi, bạn đã thua",
          draw_result: "🤝 Hòa",
          current_score: "Điểm Hiện Tại",
          win_rate_display: "Tỷ Lệ Thắng",
          total_games_display: "Tổng Số Trận",
          current_rank_display: "Xếp Hạng Hiện Tại",
          not_ranked: "Chưa Có Xếp Hạng",
          guest_mode: "Chế Độ Khách",
          guest_mode_desc:
            "Bạn hiện đang chơi với tư cách khách, kết quả trò chơi sẽ không được ghi vào bảng xếp hạng.",
          login_benefits: "Sau khi đăng nhập, tận hưởng:",
          benefit_stats: "• 📊 Thống kê dữ liệu trò chơi",
          benefit_leaderboard: "• 🏆 Tham gia cạnh tranh bảng xếp hạng",
          benefit_pi_service: "• 💰 Dịch vụ giá trị gia tăng Pi coin",
          benefit_monthly_rewards: "• 🎁 Hoạt động thưởng hàng tháng",
          play_again: "Chơi Lại",
          view_leaderboard: "Xem Bảng Xếp Hạng",
          login_now: "Đăng Nhập Ngay",

          // Giao diện trò chơi
          return_to_menu: "Quay Lại",
          guest_mode_short: "🎮 Chế Độ Khách",
          ai_battle_title: "🧠 Đấu Với AI",
          player_label: "Người Chơi",
          ai_label: "AI",
          vs_label: "VS",
          undo_button: "Hoàn Tác",
          new_game_button: "Trò Chơi Mới",

          // Liên quan đến hoàn tác
          undo_confirm: "Xác Nhận Hoàn Tác",
          undo_confirm_message:
            "Hoàn tác cần 0.1 π\nSố dư hiện tại: {0} π\n\nXác nhận hoàn tác?",
          undo_success_title: "Hoàn Tác Thành Công",
          undo_success_detail: "Đã tiêu thụ 0.1 π, số dư: {0} π",
          undo_failed_title: "Hoàn Tác Thất Bại",
          undo_failed_message: "Thanh toán thất bại",
          insufficient_balance_undo:
            "Hoàn tác cần 0.1 π, số dư hiện tại {0} π, số dư không đủ.\n\nBạn có muốn nạp tiền không?",
          continue_game_tip:
            "Bạn có thể tiếp tục trò chơi hiện tại nhưng không thể khởi động lại. Mở khóa tính năng này sau khi nạp tiền.",

          // Liên quan đến nạp tiền
          recharge_dialog_title: "💰 Nạp Tiền Tài Khoản",
          payment_dialog_title: "💳 Thanh Toán Pi Coin",
          recharge_amount_display: "Nạp {0} π",
          order_id_display: "Mã đơn hàng: {0}",
          custom_amount_error:
            "Vui lòng nhập số tiền nạp hợp lệ (tối thiểu 0.1π)",

          // Nội dung chi tiết trung tâm cá nhân
          monthly_reward_reminder: "🏆 Nhắc Nhở Thưởng Hàng Tháng",
          monthly_reward_desc:
            "50% lợi nhuận hàng tháng sẽ được phân phối cho 3 người chơi hàng đầu làm phần thưởng",

          // Giải thích chi tiết thưởng hàng tháng
          reward_settlement_detail:
            "Quyết toán vào giờ cuối của ngày cuối mỗi tháng",
          reward_pool_50_percent:
            "Quỹ thưởng là 50% lợi nhuận hàng tháng của nền tảng",
          reward_example_detail: "Ví dụ: Lợi nhuận tháng 100π, quỹ thưởng 50π",
          reward_distribution_manual:
            "Phát thưởng thủ công theo địa chỉ ví được lưu trong trung tâm cá nhân",
          reward_wallet_valid:
            "Người thắng giải phải đảm bảo địa chỉ ví chính xác và hợp lệ",
          reward_next_day: "Thưởng sẽ được phát vào ngày sau khi quyết toán",
          reward_invalid_rollover:
            "Nếu địa chỉ ví không hợp lệ, thưởng sẽ được chuyển sang tháng sau",
          reward_example_calculation:
            "💡 Ví dụ: Lợi nhuận tháng 100π, quỹ thưởng 50π",
          first_place_reward: "🥇Hạng nhất: 25π",
          second_place_reward: "🥈Hạng nhì: 15π",
          third_place_reward: "🥉Hạng ba: 10π",

          // Bảng xếp hạng toàn cầu
          global_ranking_title: "Bảng Xếp Hạng Toàn Cầu",
          ranking_subtitle: "📊 Xếp hạng dựa trên tỷ lệ thắng hàng tháng",
          ranking_header_rank: "Hạng",
          ranking_header_nickname: "Biệt danh",
          ranking_header_games: "Tổng trận",
          ranking_header_winrate: "Tỷ lệ thắng",
          current_rank_not_listed: "Xếp hạng hiện tại: Chưa có",
          current_rank_label: "Xếp hạng hiện tại",
          not_listed: "Chưa có",
          play_one_game_to_rank:
            "🎮 Hoàn thành 1 trận để lên bảng xếp hạng! Bắt đầu hành trình Cờ Carô của bạn!",

          // Nhãn chi tiết trung tâm cá nhân
          personal_profile_section: "Hồ sơ cá nhân",
          avatar_nickname_section: "Avatar và biệt danh",
          click_avatar_edit: "Nhấp avatar để chỉnh sửa",
          click_nickname_edit: "Nhấp biệt danh để chỉnh sửa",
          account_info_section: "Thông tin tài khoản",
          game_stats_section: "Thống kê trò chơi",
          wallet_address_label: "Địa chỉ ví",
          account_balance_display: "Số dư tài khoản",
          refresh_balance_btn: "Làm mới số dư",
          logout_btn: "Đăng xuất",

          // Nhãn thống kê trò chơi
          total_games_label: "Tổng trận",
          wins_label: "Thắng",
          win_rate_label: "Tỷ lệ thắng",
          current_score_label: "Điểm hiện tại",
          current_rank_label: "Hạng hiện tại",

          // Trạng thái truy vấn số dư
          balance_querying: "Đang truy vấn...",
          balance_query_failed_display: "Truy vấn thất bại",
          balance_tooltip: "Tổng nạp: {0} π\nTổng chi: {1} π",

          // Thông tin thanh toán thành công
          payment_success_title: "Thanh toán thành công",
          payment_success_message: "Thanh toán thành công!",
          purchase_success_message: "Bạn đã mua thành công {0}",
          transaction_id: "ID giao dịch: {0}",

          // Gợi ý nhập trung tâm cá nhân
          enter_avatar_emoji: "Nhập emoji avatar (ví dụ: 😊)",
          click_to_set_nickname: "Nhấp để đặt biệt danh",
          enter_your_nickname: "Nhập biệt danh của bạn",
          loading_text_display: "Đang tải...",
          refresh_balance_text: "🔄 Làm mới số dư",
          recharge_text: "💰 Nạp tiền",
          wallet_format_hint: "Định dạng địa chỉ ví: 50 chữ cái viết hoa và số",
          save_wallet: "💾 Lưu",
          edit_wallet: "✏️ Chỉnh sửa",
          logout_account_text: "↩️ Đăng xuất tài khoản",

          // Thông tin gợi ý trung tâm cá nhân
          enter_avatar_hint: "Vui lòng nhập emoji avatar",
          single_emoji_hint: "Vui lòng nhập một emoji duy nhất",
          avatar_updated: "Avatar đã được cập nhật!",
          nickname_updated: "Biệt danh đã được cập nhật!",
          enter_wallet_hint: "Vui lòng nhập địa chỉ ví",
          wallet_length_error:
            "❌ Đây không phải là địa chỉ ví tiêu chuẩn!\n\nĐộ dài hiện tại: {0} ký tự\nĐộ dài tiêu chuẩn: 50 ký tự\n\nVui lòng nhập địa chỉ ví đầy đủ 50 ký tự",
          wallet_format_error:
            "❌ Lỗi định dạng địa chỉ ví!\n\nChỉ cho phép chữ cái viết hoa (A-Z) và số (0-9)\nVui lòng kiểm tra nội dung nhập",
          wallet_saved_success: "✅ Địa chỉ ví đã được lưu thành công!",
          edit_mode_title: "Chế độ chỉnh sửa",
          edit_mode_message:
            "💡 Chế độ chỉnh sửa đã được kích hoạt\n\nVui lòng sửa đổi địa chỉ ví và nhấp lưu",
          success_title: "Thành công",
          error_title: "Lỗi",

          // Liên quan đến kết thúc trò chơi
          you_win: "🎉 Chúc mừng! Bạn thắng!",
          you_lose: "😔 AI thắng, hãy cố gắng lần sau!",
          draw: "🤝 Hòa!",
          game_over: "Kết thúc trò chơi",

          // Nút giao diện chính
          global_ranking: "Bảng xếp hạng toàn cầu",
          ai_battle: "Đấu với AI",
          personal_center: "Trung tâm cá nhân",
          game_instructions: "Hướng dẫn trò chơi",

          // Lỗi kết nối
          connection_failed: "Kết nối thất bại",
          connection_error_detail:
            "Không thể kết nối với Pi Network, vui lòng kiểm tra kết nối mạng và thử lại",
          login_with_pi: "Đăng nhập bằng tài khoản Pi",
          login_benefits_note:
            "Đăng nhập để tận hưởng đầy đủ tính năng trò chơi và phần thưởng Pi coin",

          // Hộp thoại nạp tiền
          recharge_amount_selection: "Lựa chọn số tiền nạp",
          custom_amount_placeholder: "Số tiền tùy chỉnh",
          custom_recharge: "Nạp tiền tùy chỉnh",
          cancel: "Hủy",

          // Thông báo lỗi
          please_login_first: "Vui lòng đăng nhập trước",
          create_order_failed: "Tạo đơn hàng thất bại",
          network_error_retry: "Lỗi mạng, vui lòng thử lại sau",
          pi_login_failed: "Đăng nhập Pi Network thất bại",
          login_error: "Lỗi xảy ra trong quá trình đăng nhập",
          pi_sdk_not_loaded:
            "Pi Network SDK chưa được tải, không thể sử dụng tính năng thanh toán",
          create_payment_failed: "Tạo thanh toán thất bại",

          // Hộp thoại thanh toán
          payment_method: "Phương thức thanh toán",
          pi_wallet_transfer: "📱 Chuyển khoản ví Pi",
          transfer_instruction:
            "Vui lòng sử dụng ví Pi để chuyển khoản đến địa chỉ sau:",
          transfer_amount_warning:
            "⚠️ Vui lòng đảm bảo số tiền chuyển khoản là <strong>{0} π</strong>",
          transfer_memo: "Ghi chú chuyển khoản: {0}",
          transaction_hash_placeholder: "Vui lòng nhập hash giao dịch",
          transaction_hash_instruction:
            "Sau khi hoàn tất chuyển khoản, vui lòng sao chép hash giao dịch từ ví Pi và dán vào ô nhập ở trên",
          verify_payment: "Xác minh thanh toán",
          order_validity: "Thời hạn đơn hàng: 30 phút",

          // Xác minh thanh toán
          please_enter_transaction_hash: "Vui lòng nhập hash giao dịch",
          recharge_success: "Nạp tiền thành công",
          recharge_success_message:
            "Chúc mừng! Nạp {0} π thành công!\nSố dư hiện tại: {1} π",
          verification_failed: "Xác minh thất bại",

          // Xác nhận luồng trò chơi
          timeout_game_over: "⏰ Hết thời gian suy nghĩ, trò chơi thất bại!",
          login_success: "Đăng nhập thành công",
          welcome_user: "Chào mừng, {0}",
          abandon_current_game: "Bỏ cuộc trò chơi hiện tại",
          abandon_game_warning:
            "Trò chơi hiện tại đang diễn ra, khởi động lại sẽ được ghi nhận là thua.\n\nBạn có chắc chắn muốn bỏ cuộc trò chơi hiện tại không?",
          restart_game: "Khởi động lại trò chơi",
          restart_game_confirm: "Bạn có chắc chắn muốn khởi động lại không?",
          abandon_game_return_warning:
            "Trò chơi hiện tại đang diễn ra, quay về menu chính sẽ được ghi nhận là thua.\n\nBạn có chắc chắn muốn bỏ cuộc trò chơi hiện tại không?",

          // Định dạng hiển thị thắng thua
          wins_losses_format: "({0}T {1}B)",
          monthly_games: "Trò chơi hàng tháng",
          play_again: "Chơi lại",
          view_leaderboard: "Xem bảng xếp hạng",
          login_now: "Đăng nhập ngay",
          guest_mode: "Chế độ khách",
          guest_mode_desc:
            "Bạn hiện đang chơi với tư cách khách, kết quả trò chơi sẽ không được ghi vào bảng xếp hạng.",
          login_benefits: "Lợi ích sau khi đăng nhập:",
          benefit_stats: "• 📊 Thống kê trò chơi",
          benefit_leaderboard: "• 🏆 Tham gia cạnh tranh bảng xếp hạng",
          benefit_pi_service: "• 💰 Dịch vụ giá trị gia tăng Pi coin",
          benefit_monthly_rewards: "• 🎁 Hoạt động thưởng hàng tháng",
          rank_position: "#{0}",

          // Liên quan đến ghép đôi trực tuyến
          searching_opponent: "Đang tìm đối thủ...",
          online_players: "Người chơi trực tuyến hiện tại",
          people_suffix: "người",
          match_description: "Hệ thống sẽ ghép đôi bạn với đối thủ có trình độ tương đương",
          estimated_wait: "Thời gian chờ dự kiến: 30-60 giây",
          match_found: "Đã tìm thấy đối thủ!",
          ai_opponent_name: "Đối Thủ AI Thông Minh",
          black_stone: "Quân Đen",
          white_stone: "Quân Trắng",
        },
      };

      // 当前语言
      let currentLanguage = localStorage.getItem("selectedLanguage") || "zh";

      // 翻译函数
      function t(key, ...args) {
        let text =
          LANGUAGES[currentLanguage]?.[key] || LANGUAGES["zh"][key] || key;

        // 处理参数替换 {0}, {1}, etc.
        if (args.length > 0) {
          args.forEach((arg, index) => {
            text = text.replace(`{${index}}`, arg);
          });
        }

        return text;
      }

      // 更新页面文本
      function updatePageTexts() {
        // 更新所有带有 data-i18n 属性的元素
        document.querySelectorAll("[data-i18n]").forEach((element) => {
          const key = element.getAttribute("data-i18n");
          const translatedText = t(key);

          // 特殊处理：保持 pinetwork 为英文
          const finalText = translatedText.replace(/pinetwork/gi, "pinetwork");

          if (element.tagName === "INPUT" && element.type === "text") {
            element.placeholder = finalText;
          } else {
            element.textContent = finalText;
          }
        });

        // 更新语言选择器
        const languageSelector = document.getElementById("language-selector");
        if (languageSelector) {
          languageSelector.value = currentLanguage;
        }

        // 更新游戏界面的语言选择器
        const languageSelectorGame = document.getElementById(
          "language-selector-game"
        );
        if (languageSelectorGame) {
          languageSelectorGame.value = currentLanguage;
        }

        // 动态调整副标题字体大小
        adjustSubtitleFontSize();
      }

      // 动态调整副标题字体大小以适应不同语言
      function adjustSubtitleFontSize() {
        const subtitle = document.querySelector(".game-subtitle");
        if (!subtitle) return;

        // 重置字体大小，确保使用CSS默认值
        subtitle.style.fontSize = "";

        // 强制重新计算布局
        subtitle.offsetHeight;

        // 不进行任何宽度相关的计算，避免影响布局
        // 让CSS的clamp()函数自动处理字体大小
      }

      // 切换语言
      function changeLanguage(lang) {
        currentLanguage = lang;
        localStorage.setItem("selectedLanguage", lang);
        updatePageTexts();

        // 如果有动态内容，也需要更新
        updateDynamicContent();
      }

      // 更新动态内容（游戏中的文本）
      function updateDynamicContent() {
        // 更新游戏状态显示
        const currentPlayerDisplay = document.getElementById(
          "current-player-display"
        );
        if (currentPlayerDisplay && typeof aiCurrentPlayer !== "undefined") {
          if (aiCurrentPlayer === "black") {
            currentPlayerDisplay.textContent = t("your_turn");
          } else {
            currentPlayerDisplay.textContent = t("ai_thinking");
          }
        }

        // 更新主页登录/进入游戏按钮的文本
        updateMainPageButtonState();

        // 更新其他动态元素...
      }

      // 全局变量
      let currentUser = null;
      let isLoading = false;
      let currentGame = null;

      // 后端API配置 - 根据环境自动检测
      const API_BASE_URL = (() => {
        const hostname = window.location.hostname;
        const protocol = window.location.protocol;

        if (hostname === "localhost" || hostname === "127.0.0.1") {
          // 本地开发环境
          return "http://localhost:3001";
        } else if (hostname === "mrsong-ai.github.io") {
          // GitHub Pages + 阿里云后端
          return "http://47.79.240.129:3001";
        } else {
          // 阿里云自部署环境 - 使用相同域名的/api路径
          return `${protocol}//${hostname}/api`;
        }
      })();

      // 用户统计数据
      let userStats = null;

      // 数据刷新相关变量
      let leaderboardRefreshInterval = null;
      let lastDataRefreshTime = 0;
      const DATA_REFRESH_COOLDOWN = 5000; // 5秒冷却时间

      // 检查Pi SDK是否可用
      function isPiAvailable() {
        return typeof window.Pi !== "undefined";
      }

      // 初始化页面
      function initializePage() {
        // 移除Pi Browser检查，始终允许使用
        const loginBtn = document.getElementById("login-btn");
        if (loginBtn) {
          loginBtn.disabled = false;
        }

        // 初始化多语言
        updatePageTexts();

        // 添加钱包地址输入验证
        setupWalletAddressValidation();

        // 检查并恢复登录状态
        checkAndRestoreLoginState();

        // 延迟更新主页按钮状态，确保DOM完全加载
        setTimeout(() => {
          updateMainPageButtonState();
        }, 200);

        // 注释掉测试数据创建，使用真实数据
        // 如果需要测试，可以在浏览器控制台手动设置数据
      }

      // 检查并恢复登录状态
      async function checkAndRestoreLoginState() {
        const restored = restoreLoginState();
        if (restored) {
          // 如果成功恢复登录状态，只更新按钮状态，不自动进入游戏
          try {
            // 尝试刷新后端数据（如果可用）
            if (currentUser.accessToken) {
              await authenticateWithBackend(currentUser.accessToken);
            }
          } catch (error) {
            console.error("自动登录时后端验证失败:", error);
            // 即使后端失败，也保持登录状态，使用本地数据
          }

          // 延迟更新按钮状态，确保DOM已加载
          setTimeout(() => {
            updateMainPageButtonState();
          }, 100);
        }
      }

      // 设置钱包地址输入验证
      function setupWalletAddressValidation() {
        // 使用事件委托，因为钱包输入框可能在模态框中动态创建
        document.addEventListener("input", function (e) {
          if (e.target && e.target.id === "wallet-address-input") {
            let value = e.target.value;
            // 只允许大写字母和数字
            value = value.replace(/[^A-Z0-9]/g, "");
            // 限制长度为50位
            if (value.length > 50) {
              value = value.substring(0, 50);
            }
            e.target.value = value;

            // 更新字符计数
            updateWalletCharCount(value.length);
          }
        });
      }

      // 更新钱包地址字符计数
      function updateWalletCharCount(length) {
        const countElement = document.getElementById("wallet-char-count");
        if (countElement) {
          countElement.textContent = `${length}/50`;
          // 根据长度改变颜色
          if (length === 50) {
            countElement.style.color = "#28a745"; // 绿色
          } else if (length > 40) {
            countElement.style.color = "#ffc107"; // 黄色
          } else {
            countElement.style.color = "#6c757d"; // 灰色
          }
        }
      }

      // 显示错误信息
      function showError(message) {
        const errorMessage = document.getElementById("error-message");
        const errorText = document.getElementById("error-text");
        errorText.textContent = "❌ " + message;
        errorMessage.style.display = "block";
      }

      // 隐藏错误信息
      function hideError() {
        const errorMessage = document.getElementById("error-message");
        errorMessage.style.display = "none";
      }

      // Pi Network 登录处理
      async function handleSignIn() {
        if (isLoading) return;

        // 如果已经登录，直接进入游戏
        if (currentUser) {
          showSimpleGameScreen();
          return;
        }

        isLoading = true;
        const loginBtn = document.getElementById("login-btn");
        loginBtn.disabled = true;

        // 检查是否在Pi Browser中来显示不同的提示
        const isInPiBrowser = isPiAvailable();
        const loadingText = isInPiBrowser
          ? t("connecting_pi_network")
          : t("entering_game");

        // 完全替换按钮内容为连接状态，隐藏原有的登录文本
        loginBtn.innerHTML = `
                <div class="loading">
                    <div class="spinner"></div>
                    <span>${loadingText}</span>
                </div>
            `;
        loginBtn.classList.add('loading');

        try {
          hideError();

          // 检查是否在Pi Browser中
          if (isPiAvailable()) {
            // 真实的Pi Network登录
            const scopes = ["username", "payments"];

            // 设置超时机制，避免无限等待
            const authPromise = Pi.authenticate(
              scopes,
              onIncompletePaymentFound
            );
            const timeoutPromise = new Promise((_, reject) =>
              setTimeout(() => reject(new Error("Pi Network连接超时")), 10000)
            );

            const authResult = await Promise.race([
              authPromise,
              timeoutPromise,
            ]);

            if (authResult.accessToken) {
              currentUser = authResult.user;
              currentUser.accessToken = authResult.accessToken; // 保存访问令牌

              // 保存登录状态到本地存储
              saveLoginState(currentUser);

              // 向后端验证用户并获取统计数据
              await authenticateWithBackend(authResult.accessToken);

              // 更新主页按钮状态
              updateMainPageButtonState();

              // 确保用户数据被保存到本地存储
              if (userStats) {
                saveUserGameDataToSpecificStorage();
                refreshLocalLeaderboardData();
              }

              // 触发数据刷新（延迟执行，确保后端数据已同步）
              setTimeout(() => {
                triggerDataRefresh();
              }, 2000);

              // 登录成功后保持在当前界面，不自动跳转到游戏
              showCustomAlert(
                t("login_success"),
                t("welcome_user", currentUser.username)
              );
            } else {
              showError(t("pi_login_failed"));
            }
          } else {
            // Pi SDK不可用，显示错误信息
            showError(t("pi_sdk_not_available"));
          }
        } catch (error) {
          console.error("Sign in failed:", error);
          showError(t("login_error") + ": " + error.message);
        } finally {
          isLoading = false;
          loginBtn.disabled = false;
          loginBtn.classList.remove('loading');

          // 恢复按钮原始状态
          if (!currentUser) {
            loginBtn.innerHTML = `
              <span class="pi-icon">π</span>
              <span data-i18n="login_with_pi">${t("login_with_pi")}</span>
            `;
          }
        }
      }

      // 后端认证函数
      async function authenticateWithBackend(accessToken) {
        try {
          const response = await fetch(`${API_BASE_URL}/api/auth/login`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              accessToken,
              userInfo: {
                uid: currentUser.uid,
                username: currentUser.username,
              },
            }),
          });

          if (response.ok) {
            const data = await response.json();
            // 保存用户ID用于后续API调用
            currentUser.piUserId =
              data.user.piUserId || data.user.uid || currentUser.uid;

            // 先尝试恢复用户专属的游戏数据
            const hasLocalData = restoreUserGameData();

            // 数据完整性检查：比较本地数据和后端数据
            const backendStats = data.user.stats;
            if (
              hasLocalData &&
              userStats &&
              userStats.totalGames > 0 &&
              backendStats.totalGames === 0
            ) {
              console.log(
                "[登录数据恢复] 检测到后端数据异常，保持使用本地数据"
              );
              // 异步同步本地数据到后端
              setTimeout(() => {
                syncLocalDataToBackend(userStats);
              }, 1000);
            } else if (!userStats || userStats.totalGames === 0) {
              // 如果没有本地数据，才使用后端返回的初始数据
              userStats = backendStats;
            }
          } else {
            // 如果后端认证失败，使用uid作为piUserId
            currentUser.piUserId = currentUser.uid;

            // 尝试恢复本地数据
            const restored = restoreUserGameData();
            if (!restored) {
              // 如果没有可恢复的数据，创建默认数据
              createDefaultUserStats();
            }
          }
        } catch (error) {
          // 如果后端连接失败，使用uid作为piUserId
          currentUser.piUserId = currentUser.uid;

          // 尝试恢复本地数据
          const restored = restoreUserGameData();
          if (!restored) {
            // 如果没有可恢复的数据，创建默认数据
            createDefaultUserStats();
          }
        }
      }

      // 恢复用户专属的游戏数据
      function restoreUserGameData() {
        if (!currentUser) return;

        const userId = currentUser.piUserId || currentUser.uid;
        const userDataKey = `piGomokuUserData_${userId}`;
        const savedUserData = localStorage.getItem(userDataKey);

        if (savedUserData) {
          try {
            const userData = JSON.parse(savedUserData);
            // 如果找到用户专属数据，使用它
            if (userData.gameStats) {
              userStats = userData.gameStats;
              // 更新用户名为最新的
              userStats.username =
                currentUser.username || userStats.username || "Pi用户";

              // 同时更新通用存储，保持兼容性
              localStorage.setItem(
                "piGomokuGameStats",
                JSON.stringify(userStats)
              );
              return true; // 表示成功恢复了数据
            }
          } catch (error) {
            console.error("恢复用户数据失败:", error);
          }
        }

        // 如果没有找到用户专属数据，尝试从通用存储恢复
        const generalStats = localStorage.getItem("piGomokuGameStats");
        if (generalStats) {
          try {
            const stats = JSON.parse(generalStats);
            if (stats && stats.totalGames > 0) {
              userStats = stats;
              userStats.username =
                currentUser.username || userStats.username || "Pi用户";
              return true; // 表示成功恢复了数据
            }
          } catch (error) {
            console.error("恢复通用数据失败:", error);
          }
        }

        return false; // 表示没有找到可恢复的数据
      }

      // 从本地存储初始化用户数据
      function initializeUserStatsFromLocal() {
        const localStats = localStorage.getItem("piGomokuGameStats");

        if (localStats) {
          try {
            userStats = JSON.parse(localStats);
            // 确保用户名是最新的
            userStats.username =
              currentUser.username || userStats.username || "Pi用户";
          } catch (error) {
            console.error("解析本地数据失败:", error);
            createDefaultUserStats();
          }
        } else {
          createDefaultUserStats();
        }
      }

      // 创建默认用户统计数据
      function createDefaultUserStats() {
        userStats = {
          username: currentUser.username || "Pi用户",
          totalGames: 0,
          wins: 0,
          losses: 0,
          draws: 0,
          winRate: 0,
          rank: 0,
        };
        // 立即保存到本地存储
        localStorage.setItem("piGomokuGameStats", JSON.stringify(userStats));
      }

      // 获取当前显示的用户名（与个人中心保持一致）
      function getCurrentDisplayUsername() {
        if (currentUser && userStats) {
          // Pi登录状态：优先使用Pi用户名，然后是userStats中的用户名
          return currentUser.username || userStats.username || "Pi用户";
        } else {
          // 未登录状态：使用本地昵称
          return localStorage.getItem("userNickname") || "游客";
        }
      }

      // 保存登录状态到本地存储
      function saveLoginState(user) {
        const loginState = {
          user: user,
          timestamp: Date.now(),
          expiresAt: Date.now() + 7 * 24 * 60 * 60 * 1000, // 7天过期
        };
        localStorage.setItem("piGomokuLoginState", JSON.stringify(loginState));
      }

      // 恢复登录状态
      function restoreLoginState() {
        try {
          const savedState = localStorage.getItem("piGomokuLoginState");
          if (!savedState) return false;

          const loginState = JSON.parse(savedState);

          // 检查是否过期
          if (Date.now() > loginState.expiresAt) {
            localStorage.removeItem("piGomokuLoginState");
            return false;
          }

          // 恢复用户状态
          currentUser = loginState.user;

          // 恢复用户数据
          const restored = restoreUserGameData();
          if (!restored) {
            createDefaultUserStats();
          }

          return true;
        } catch (error) {
          console.error("恢复登录状态失败:", error);
          localStorage.removeItem("piGomokuLoginState");
          return false;
        }
      }

      // 清除登录状态
      function clearLoginState() {
        localStorage.removeItem("piGomokuLoginState");
      }

      // 更新主页按钮显示状态
      function updateMainPageButtonState() {
        const loginBtn = document.getElementById("login-btn");
        if (!loginBtn) {
          return;
        }

        if (currentUser) {
          // 已登录状态：显示"进入游戏"按钮
          loginBtn.innerHTML = `
            <span class="pi-icon">🎮</span>
            <span>${t("enter_game")}</span>
          `;
          loginBtn.onclick = () => showSimpleGameScreen();
        } else {
          // 未登录状态：显示"登录"按钮
          loginBtn.innerHTML = `
            <span class="pi-icon">π</span>
            <span data-i18n="login_with_pi">${t("login_with_pi")}</span>
          `;
          loginBtn.onclick = handleSignIn;
        }
      }

      // Pi SDK不可用时的处理
      function handlePiSdkUnavailable() {
        showCustomAlert(
          t("error_title"),
          t("pi_sdk_required_message")
        );
      }

      // 处理未完成的支付
      function onIncompletePaymentFound(payment) {
        console.log("发现未完成的支付:", payment);
        // 这里可以处理未完成的支付，比如重新验证
        handleIncompletePayment(payment);
      }

      // Pi支付功能 - 购买道具
      async function buyItem(itemType, amount) {
        if (!currentUser) {
          showError(t("please_login_first"));
          return;
        }

        if (!isPiAvailable()) {
          showError(t("pi_sdk_not_loaded"));
          return;
        }

        try {
          // 显示支付确认
          const confirmed = await showPaymentConfirm(itemType, amount);
          if (!confirmed) return;

          // 创建支付请求
          const paymentData = {
            amount: amount,
            memo: `购买${getItemName(itemType)}`,
            metadata: {
              itemType: itemType,
              userId: currentUser.uid,
              timestamp: Date.now(),
            },
          };

          // 发起Pi支付
          const payment = await Pi.createPayment(paymentData, {
            onReadyForServerApproval: async function (paymentId) {
              console.log("支付等待服务器审批:", paymentId);
              try {
                const response = await fetch(
                  `${API_BASE_URL}/api/payment/approve`,
                  {
                    method: "POST",
                    headers: {
                      "Content-Type": "application/json",
                      Authorization: `Bearer ${currentUser.accessToken}`,
                    },
                    body: JSON.stringify({ paymentId, paymentData }),
                  }
                );

                if (response.ok) {
                  console.log("支付审批成功");
                } else {
                  console.error("支付审批失败");
                  // 即使后端失败，也继续流程（用于测试）
                }
              } catch (error) {
                console.error("支付审批请求失败:", error);
                // 即使后端失败，也继续流程（用于测试）
              }
            },
            onReadyForServerCompletion: async function (paymentId, txid) {
              console.log("支付等待服务器完成:", paymentId, txid);
              try {
                const response = await fetch(
                  `${API_BASE_URL}/api/payment/complete`,
                  {
                    method: "POST",
                    headers: {
                      "Content-Type": "application/json",
                      Authorization: `Bearer ${currentUser.accessToken}`,
                    },
                    body: JSON.stringify({ paymentId, txid, paymentData }),
                  }
                );

                if (response.ok) {
                  const data = await response.json();
                  console.log("支付完成验证成功:", data);
                } else {
                  console.error("支付完成验证失败");
                }
              } catch (error) {
                console.error("支付完成请求失败:", error);
              }

              // 显示支付成功消息
              setTimeout(() => {
                showCustomModal(
                  "支付成功",
                  `
                    <div style="text-align: center;">
                        <div style="font-size: 3em; margin-bottom: 15px;">✅</div>
                        <h3 style="color: #28a745;">支付成功！</h3>
                        <p style="color: #666; margin: 15px 0;">
                            您已成功购买 ${getItemName(
                              paymentData.metadata.itemType
                            )}
                        </p>
                        <p style="color: #007bff; font-weight: bold;">
                            交易ID: ${txid.substring(0, 16)}...
                        </p>
                    </div>
                  `
                );
              }, 1000);
            },
            onCancel: function (paymentId) {
              console.log("支付被取消:", paymentId);
              showError(t("payment_cancelled"));
            },
            onError: function (error, payment) {
              console.error("支付错误:", error, payment);
              showError(t("payment_failed") + ": " + error.message);
            },
          });
        } catch (error) {
          console.error("创建支付失败:", error);
          showError(t("create_payment_failed") + ": " + error.message);
        }
      }

      // 获取道具名称
      function getItemName(itemType) {
        const keys = {
          hint: "item_hint",
          undo: "item_undo",
          theme: "item_theme",
          vip: "item_vip",
        };
        return t(keys[itemType] || "item_unknown");
      }

      // 显示支付确认对话框
      function showPaymentConfirm(itemType, amount) {
        return new Promise((resolve) => {
          const itemName = getItemName(itemType);
          showCustomModal(
            t("confirm_purchase"),
            `
                    <div style="text-align: center;">
                        <div style="font-size: 3em; margin-bottom: 15px;">💰</div>
                        <h3 style="color: #333; margin-bottom: 15px;">${t(
                          "confirm_purchase"
                        )}</h3>
                        <div style="background: #f8f9fa; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                            <p style="font-size: 1.1em; margin-bottom: 10px; color: #333;">
                                <strong>${itemName}</strong>
                            </p>
                            <p style="font-size: 1.3em; color: #007bff; font-weight: bold;">
                                ${t("payment_amount", amount)}
                            </p>
                        </div>
                        <div style="display: flex; gap: 10px; justify-content: center;">
                            <button onclick="closeNewModal(); resolve(false)" style="background: #6c757d; color: white; border: none; border-radius: 6px; padding: 10px 20px; cursor: pointer;">
                                ${t("cancel")}
                            </button>
                            <button onclick="closeNewModal(); resolve(true)" style="background: #007bff; color: white; border: none; border-radius: 6px; padding: 10px 20px; cursor: pointer;">
                                ${t("confirm_payment")}
                            </button>
                        </div>
                    </div>
                `,
            resolve
          );
        });
      }

      // 处理未完成的支付
      async function handleIncompletePayment(payment) {
        try {
          // 检查支付状态并处理
          // 这里可以重新提交到服务器验证
        } catch (error) {
          console.error("处理未完成支付失败:", error);
        }
      }

      // 服务器端支付审批 (需要后端API)
      async function approvePaymentOnServer(paymentId, paymentData) {
        try {
          // 这里需要调用您的后端API
          // const response = await fetch('YOUR_BACKEND_URL/api/payments/approve', {
          //     method: 'POST',
          //     headers: { 'Content-Type': 'application/json' },
          //     body: JSON.stringify({ paymentId, paymentData })
          // });
          // 模拟审批成功
        } catch (error) {
          console.error("服务器审批失败:", error);
        }
      }

      // 服务器端支付完成 (需要后端API)
      async function completePaymentOnServer(paymentId, txid, paymentData) {
        try {
          // 这里需要调用您的后端API
          // const response = await fetch('YOUR_BACKEND_URL/api/payments/complete', {
          //     method: 'POST',
          //     headers: { 'Content-Type': 'application/json' },
          //     body: JSON.stringify({ paymentId, txid, paymentData })
          // });

          // 模拟支付成功
          setTimeout(() => {
            showCustomModal(
              t("payment_success_title"),
              `
                        <div style="text-align: center;">
                            <div style="font-size: 3em; margin-bottom: 15px;">✅</div>
                            <h3 style="color: #28a745;">${t(
                              "payment_success_message"
                            )}</h3>
                            <p style="color: #666; margin: 15px 0;">
                                ${t(
                                  "purchase_success_message",
                                  getItemName(paymentData.metadata.itemType)
                                )}
                            </p>
                            <p style="color: #007bff; font-weight: bold;">
                                ${t(
                                  "transaction_id",
                                  txid.substring(0, 16) + "..."
                                )}
                            </p>
                        </div>
                    `
            );
          }, 2000);
        } catch (error) {
          console.error("服务器完成支付失败:", error);
        }
      }

      // 显示主界面
      function showMainScreen() {
        performBackToLogin();
      }

      // 在线匹配处理
      function handleOnlineMatch() {
        showOnlineMatchScreen();
      }

      // AI对战处理
      function handleAIGame() {
        showSimpleGameScreen();
      }

      // 加载排行榜数据 - 支持本地数据降级
      async function loadLeaderboard(
        sortBy = "score",
        limit = 100,
        forceRefresh = false
      ) {
        try {
          const now = Date.now();
          const shouldRefresh =
            forceRefresh || now - lastDataRefreshTime > DATA_REFRESH_COOLDOWN;

          if (!shouldRefresh) {
            console.log("[排行榜] 跳过刷新，冷却时间未到");
            // 如果不需要刷新，返回本地排行榜数据
            return getLocalLeaderboard(limit);
          }

          // 首先尝试从后端获取数据
          try {
            const refreshParam = forceRefresh ? "&refresh=true" : "";
            const response = await fetch(
              `${API_BASE_URL}/api/leaderboard?limit=${limit}${refreshParam}`
            );
            if (response.ok) {
              const data = await response.json();
              lastDataRefreshTime = now;
              console.log(
                `[排行榜] 后端数据刷新成功，总用户数: ${data.totalUsers}, 排行榜条目: ${data.leaderboard.length}`
              );
              return data.leaderboard || [];
            } else {
              console.error("获取排行榜失败:", response.status);
              throw new Error("后端请求失败");
            }
          } catch (backendError) {
            console.log("[排行榜] 后端不可用，使用本地数据");
            return getLocalLeaderboard(limit);
          }
        } catch (error) {
          console.error("排行榜请求错误:", error);
          // 发生任何错误时，都返回本地排行榜数据
          return getLocalLeaderboard(limit);
        }
      }

      // 获取真实Pi Network用户排行榜数据（无模拟用户）
      function getLocalLeaderboard(limit = 100) {
        try {
          const allUsers = [];
          const userIdSet = new Set(); // 用于去重

          console.log("[排行榜] 开始收集真实Pi Network用户数据...");

          // 1. 收集localStorage中的所有真实Pi Network用户数据，过滤掉测试用户
          const userDataMap = new Map(); // userId -> 最佳用户数据

          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);

            // 查找用户专属数据
            if (key && key.startsWith('piGomokuUserData_')) {
              try {
                const userData = JSON.parse(localStorage.getItem(key));
                if (userData && userData.gameStats && userData.gameStats.totalGames > 0) {
                  const userId = userData.userId;

                  // 过滤掉测试用户和模拟用户
                  if (userId && !userId.startsWith('test_user_') && !userId.startsWith('mock_') && !userData.accessToken?.startsWith('mock_token_')) {
                    const userEntry = {
                      userId: userId,
                      username: userData.username || userData.gameStats.username || "Pi用户",
                      totalGames: userData.gameStats.totalGames,
                      wins: userData.gameStats.wins,
                      losses: userData.gameStats.losses,
                      draws: userData.gameStats.draws || 0,
                      winRate: userData.gameStats.winRate || 0,
                      lastUpdated: userData.lastUpdated || 0,
                      storageKey: key
                    };

                    // 如果用户已存在，比较并保留更好的数据
                    if (userDataMap.has(userId)) {
                      const existingEntry = userDataMap.get(userId);

                      // 优先保留游戏局数更多的数据，局数相同时保留时间更新的
                      if (userEntry.totalGames > existingEntry.totalGames ||
                          (userEntry.totalGames === existingEntry.totalGames &&
                           userEntry.lastUpdated > existingEntry.lastUpdated)) {
                        userDataMap.set(userId, userEntry);
                        console.log(`[排行榜] 更新Pi用户数据: ${userId} (${userEntry.username}) - 总局数: ${userEntry.totalGames} (${key})`);
                      } else {
                        console.log(`[排行榜] 保留现有Pi用户数据: ${userId} - 总局数: ${existingEntry.totalGames} >= ${userEntry.totalGames}`);
                      }
                    } else {
                      userDataMap.set(userId, userEntry);
                      console.log(`[排行榜] 添加新Pi用户: ${userId} (${userEntry.username}) - 总局数: ${userEntry.totalGames} (${key})`);
                    }
                  } else {
                    console.log(`[排行榜] 跳过测试用户: ${userId}`);
                  }
                }
              } catch (parseError) {
                console.error("解析用户数据失败:", parseError);
              }
            }
          }

          // 转换为数组
          userDataMap.forEach((userEntry) => {
            const isCurrentUser = currentUser &&
              (userEntry.userId === currentUser.piUserId || userEntry.userId === currentUser.uid);

            allUsers.push({
              userId: userEntry.userId,
              username: userEntry.username,
              totalGames: userEntry.totalGames,
              wins: userEntry.wins,
              losses: userEntry.losses,
              draws: userEntry.draws,
              winRate: userEntry.winRate,
              isCurrentUser: isCurrentUser
            });
            userIdSet.add(userEntry.userId);
          });

          // 2. 如果当前用户有数据但不在localStorage专属存储中，且是真实Pi用户，添加当前用户
          if (currentUser && userStats && userStats.totalGames > 0) {
            const currentUserId = currentUser.piUserId || currentUser.uid;
            // 只添加真实Pi Network用户，过滤掉测试用户
            if (currentUserId && !userIdSet.has(currentUserId) &&
                !currentUserId.startsWith('test_user_') &&
                !currentUserId.startsWith('mock_') &&
                !currentUser.accessToken?.startsWith('mock_token_')) {
              userIdSet.add(currentUserId);
              allUsers.push({
                userId: currentUserId,
                username: getCurrentDisplayUsername(),
                totalGames: userStats.totalGames,
                wins: userStats.wins,
                losses: userStats.losses,
                draws: userStats.draws || 0,
                winRate: userStats.winRate || 0,
                isCurrentUser: true
              });
              console.log(`[排行榜] 添加当前Pi用户数据: ${currentUserId} (${getCurrentDisplayUsername()})`);
            } else if (currentUserId?.startsWith('test_user_') || currentUserId?.startsWith('mock_') || currentUser.accessToken?.startsWith('mock_token_')) {
              console.log(`[排行榜] 跳过当前测试用户: ${currentUserId}`);
            }
          }

          // 按胜率排序，胜率相同时按胜场数排序，再按总局数排序
          const sortedUsers = allUsers
            .sort((a, b) => {
              // 1. 首先按胜率排序（高到低）
              if (b.winRate !== a.winRate) {
                return b.winRate - a.winRate;
              }
              // 2. 胜率相同时，按胜场数排序（高到低）
              if (b.wins !== a.wins) {
                return b.wins - a.wins;
              }
              // 3. 胜场数相同时，按总局数排序（高到低）
              if (b.totalGames !== a.totalGames) {
                return b.totalGames - a.totalGames;
              }
              // 4. 最后按用户名排序（确保稳定排序）
              return a.username.localeCompare(b.username);
            })
            .slice(0, limit)
            .map((user, index) => ({
              rank: index + 1,
              userId: user.userId,
              username: user.username,
              totalGames: user.totalGames,
              wins: user.wins,
              winRate: user.winRate,
              isCurrentUser: user.isCurrentUser || false
            }));

          console.log(`[本地排行榜] 生成排行榜数据，共 ${sortedUsers.length} 条记录:`, sortedUsers);
          return sortedUsers;
        } catch (error) {
          console.error("生成本地排行榜失败:", error);
          return [];
        }
      }

      // 获取用户排名 - 支持本地数据降级
      async function getUserRank(userId) {
        try {
          // 首先尝试从后端获取排名
          try {
            const response = await fetch(
              `${API_BASE_URL}/api/leaderboard/rank?userId=${userId}`
            );
            if (response.ok) {
              const data = await response.json();
              return data.rank || 0;
            } else {
              throw new Error("后端请求失败");
            }
          } catch (backendError) {
            console.log("[用户排名] 后端不可用，使用本地数据计算排名");
            return getLocalUserRank(userId);
          }
        } catch (error) {
          console.error("获取用户排名错误:", error);
          return getLocalUserRank(userId);
        }
      }

      // 从本地数据计算用户排名
      function getLocalUserRank(userId) {
        try {
          const leaderboard = getLocalLeaderboard(1000); // 获取完整排行榜
          const userEntry = leaderboard.find(entry => entry.userId === userId);
          return userEntry ? userEntry.rank : 0;
        } catch (error) {
          console.error("计算本地用户排名失败:", error);
          return 0;
        }
      }

      // 显示实时排行榜
      async function showRealTimeLeaderboard(forceRefresh = false) {
        const leaderboard = await loadLeaderboard("score", 100, forceRefresh);

        // 获取当前用户的真实排名
        let userRank = 0;
        if (currentUser && currentUser.piUserId) {
          userRank = await getUserRank(currentUser.piUserId);
        }

        // 启动自动刷新
        startLeaderboardAutoRefresh();

        let leaderboardHTML = "";
        if (leaderboard.length === 0) {
          // 检查当前用户是否有游戏数据但未显示在排行榜中
          const hasUserData = currentUser && userStats && userStats.totalGames > 0;

          leaderboardHTML = `
                    <div style="text-align: center; padding: 40px 20px; color: #666;">
                        <div style="font-size: 3em; margin-bottom: 15px;">🎯</div>
                        ${hasUserData ?
                          `<p style="margin: 0; font-size: 1.1em;">正在加载排行榜数据...</p>
                           <p style="margin: 5px 0 0 0; font-size: 0.9em;">您的游戏数据：${userStats.totalGames}局 (${userStats.wins}胜${userStats.losses}负) 胜率${userStats.winRate}%</p>` :
                          `<p style="margin: 0; font-size: 1.1em;">暂无排行榜数据</p>
                           <p style="margin: 5px 0 0 0; font-size: 0.9em;">${t("play_one_game_to_rank")}</p>`
                        }
                    </div>
                `;
        } else {
          leaderboard.forEach((player, index) => {
            const isCurrentUser =
              currentUser &&
              (player.userId === currentUser.uid ||
                player.userId === currentUser.piUserId);
            const rankIcon =
              index === 0
                ? "🥇"
                : index === 1
                ? "🥈"
                : index === 2
                ? "🥉"
                : index + 1;
            const bgColor = isCurrentUser ? "background: #e3f2fd;" : "";

            leaderboardHTML += `
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 12px 10px; border-bottom: 1px solid #e9ecef; ${bgColor}">
                            <span style="color: ${
                              index < 3 ? "#ffd700" : "#6c757d"
                            }; font-weight: bold;">${rankIcon}</span>
                            <span style="font-weight: 500; color: ${
                              isCurrentUser ? "#1976d2" : "#333"
                            };">${player.username}</span>
                            <span style="color: #666; font-size: 0.9em;">${t(
                              "wins_losses_format",
                              player.wins,
                              player.totalGames - player.wins
                            )}</span>
                            <span style="color: #28a745;">${
                              player.winRate
                            }%</span>
                        </div>
                    `;
          });
        }

        showCustomModal(
          t("global_ranking_title"),
          `
                <div style="text-align: center;">
                    <div style="margin-bottom: 20px;">
                        <span style="font-size: 3em; margin-bottom: 10px; display: block;">🏆</span>
                        <h3 style="color: #333; margin-bottom: 20px;">${t(
                          "global_ranking_title"
                        )}</h3>
                        <p style="color: #666; font-size: 0.9em; margin: 0 0 15px 0;">${t(
                          "ranking_subtitle"
                        )}</p>
                    </div>

                    <div style="background: #f8f9fa; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; border-bottom: 2px solid #e9ecef; font-weight: bold; color: #495057;">
                            <span>${t("ranking_header_rank")}</span>
                            <span>${t("ranking_header_nickname")}</span>
                            <span>${t("ranking_header_games")}</span>
                            <span>${t("ranking_header_winrate")}</span>
                        </div>
                        ${leaderboardHTML}
                    </div>

                    ${
                      userRank > 0
                        ? `
                        <div style="background: #e3f2fd; border-radius: 8px; padding: 8px; margin-bottom: 10px; margin-top: 0px;">
                            <p style="margin: 0; color: #1976d2; font-weight: 500; text-align: center;">
                                ${t(
                                  "current_ranking",
                                  userRank,
                                  userStats ? userStats.wins : 0,
                                  userStats
                                    ? userStats.totalGames - userStats.wins
                                    : 0,
                                  userStats ? userStats.winRate : 0
                                )}
                            </p>
                        </div>
                    `
                        : userStats && userStats.totalGames === 0
                        ? `
                        <div style="background: #fff3cd; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                            <p style="margin: 0; color: #856404; font-weight: 500;">
                                ${t("play_one_game_to_rank")}
                            </p>
                        </div>
                    `
                        : ""
                    }

                    <p style="color: #666; font-size: 0.9em; margin: 0;">
                        ${t("leaderboard_update_tip")}
                    </p>
                </div>
            `
        );
      }

      // 启动排行榜自动刷新
      function startLeaderboardAutoRefresh() {
        // 清除之前的定时器
        if (leaderboardRefreshInterval) {
          clearInterval(leaderboardRefreshInterval);
        }

        // 每30秒自动刷新一次排行榜
        leaderboardRefreshInterval = setInterval(async () => {
          console.log("[排行榜] 自动刷新数据...");
          const currentModal = document.querySelector(".modal-overlay");
          if (currentModal && currentModal.style.display !== "none") {
            // 如果排行榜弹窗还在显示，则刷新数据
            await showRealTimeLeaderboard(true);
          } else {
            // 如果弹窗已关闭，停止自动刷新
            stopLeaderboardAutoRefresh();
          }
        }, 30000); // 30秒
      }

      // 停止排行榜自动刷新
      function stopLeaderboardAutoRefresh() {
        if (leaderboardRefreshInterval) {
          clearInterval(leaderboardRefreshInterval);
          leaderboardRefreshInterval = null;
          console.log("[排行榜] 停止自动刷新");
        }
      }

      // 触发数据刷新（用于新用户登录后）
      function triggerDataRefresh() {
        console.log("[数据刷新] 触发全局数据刷新");

        // 重置刷新冷却时间，强制刷新
        lastDataRefreshTime = 0;

        // 如果排行榜弹窗正在显示，立即刷新
        const currentModal = document.querySelector(".modal-overlay");
        if (currentModal && currentModal.style.display !== "none") {
          console.log("[数据刷新] 刷新排行榜数据");
          showRealTimeLeaderboard(true);
        }

        // 刷新个人中心数据（如果正在显示）
        const personalCenterModal = document.querySelector(".custom-modal");
        if (personalCenterModal) {
          console.log("[数据刷新] 刷新个人中心数据");
          refreshUserStats();
        }
      }

      // 显示全球排行榜 (使用真实数据)
      async function showGlobalRanking() {
        // 直接调用真实排行榜函数
        await showRealTimeLeaderboard();
        return;

        // 以下代码已废弃，保留作为备用
        /*
        showCustomModal(
          `${t(
            "global_ranking_title"
          )}<br><span style='font-size: 0.7em; color: #ffffff; font-weight: normal;'>${t(
            "ranking_subtitle"
          )}</span>`,
          `
                <div style="text-align: center;">
                    <div style="background: #f8f9fa; border-radius: 8px; padding: 10px; margin-bottom: 8px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px; border-bottom: 2px solid #e9ecef; font-weight: bold; color: #495057;">
                            <span>${t("ranking_header_rank")}</span>
                            <span>${t("ranking_header_nickname")}</span>
                            <span>${t("ranking_header_games")}</span>
                            <span>${t("ranking_header_winrate")}</span>
                        </div>

                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 6px 8px; border-bottom: 1px solid #e9ecef;">
                            <span style="color: #ffd700; font-weight: bold;">🥇 1</span>
                            <span style="font-weight: 500;">棋圣大师</span>
                            <span style="color: #666; font-size: 0.9em; text-align: center;" data-i18n-format="wins_losses" data-wins="21" data-losses="1">(21胜1负)</span>
                            <span style="color: #28a745;">95.2%</span>
                        </div>

                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 6px 8px; border-bottom: 1px solid #e9ecef;">
                            <span style="color: #c0c0c0; font-weight: bold;">🥈 2</span>
                            <span style="font-weight: 500;">五子高手</span>
                            <span style="color: #666; font-size: 0.9em; text-align: center;">(25胜2负)</span>
                            <span style="color: #28a745;">92.8%</span>
                        </div>

                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 6px 8px; border-bottom: 1px solid #e9ecef;">
                            <span style="color: #cd7f32; font-weight: bold;">🥉 3</span>
                            <span style="font-weight: 500;">连珠达人</span>
                            <span style="color: #666; font-size: 0.9em; text-align: center;">(26胜3负)</span>
                            <span style="color: #28a745;">89.6%</span>
                        </div>

                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 6px 8px; border-bottom: 1px solid #e9ecef;">
                            <span style="color: #6c757d;">4</span>
                            <span style="font-weight: 500;">黑白传说</span>
                            <span style="color: #666; font-size: 0.9em; text-align: center;">(24胜4负)</span>
                            <span style="color: #28a745;">87.3%</span>
                        </div>

                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 6px 8px; border-bottom: 1px solid #e9ecef;">
                            <span style="color: #6c757d;">5</span>
                            <span style="font-weight: 500;">智慧之星</span>
                            <span style="color: #666; font-size: 0.9em; text-align: center;">(23胜4负)</span>
                            <span style="color: #28a745;">85.1%</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 6px 8px; border-bottom: 1px solid #e9ecef;">
                            <span style="color: #6c757d;">6</span>
                            <span style="font-weight: 500;">棋道高手</span>
                            <span style="color: #666; font-size: 0.9em; text-align: center;">(20胜5负)</span>
                            <span style="color: #28a745;">80.0%</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 6px 8px; border-bottom: 1px solid #e9ecef;">
                            <span style="color: #6c757d;">7</span>
                            <span style="font-weight: 500;">五子王者</span>
                            <span style="color: #666; font-size: 0.9em; text-align: center;">(19胜6负)</span>
                            <span style="color: #28a745;">76.0%</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 6px 8px; border-bottom: 1px solid #e9ecef;">
                            <span style="color: #6c757d;">8</span>
                            <span style="font-weight: 500;">连珠专家</span>
                            <span style="color: #666; font-size: 0.9em; text-align: center;">(18胜7负)</span>
                            <span style="color: #28a745;">72.0%</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 6px 8px; border-bottom: 1px solid #e9ecef;">
                            <span style="color: #6c757d;">9</span>
                            <span style="font-weight: 500;">黑白精英</span>
                            <span style="color: #666; font-size: 0.9em; text-align: center;">(17胜8负)</span>
                            <span style="color: #28a745;">68.0%</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 6px 8px;">
                            <span style="color: #6c757d;">10</span>
                            <span style="font-weight: 500;">棋局达人</span>
                            <span style="color: #666; font-size: 0.9em; text-align: center;">(16胜9负)</span>
                            <span style="color: #28a745;">64.0%</span>
                        </div>
                    </div>
                    <div style="background: #e3f2fd; border-radius: 8px; padding: 8px; margin-bottom: 10px; margin-top: 0px;">
                        <p style="margin: 0; color: #1976d2; font-weight: 500; text-align: center;">
                            ${t("current_ranking", "42", "13", "4", "76.5")}
                        </p>
                    </div>

                    <p style="color: #666; font-size: 0.9em; margin: 0;">
                        ${t("leaderboard_update_tip")}
                    </p>
                </div>
            `
        );
        */
      }

      // 显示个人中心
      async function showPersonalCenter() {
        // 如果用户已登录，确保有piUserId并刷新数据
        if (currentUser) {
          // 确保有piUserId
          if (!currentUser.piUserId) {
            currentUser.piUserId = currentUser.uid;
          }

          await refreshUserStats();
        }

        const stats = userStats || {
          totalGames: 0,
          wins: 0,
          losses: 0,
          winRate: 0,
          rank: 0,
        };

        // 获取保存的用户信息
        const savedWalletAddress =
          localStorage.getItem("userWalletAddress") || "";
        const savedNickname = localStorage.getItem("userNickname") || "";

        // 判断登录状态和昵称显示逻辑
        let displayNickname = "";
        let nicknameEditable = true;

        if (currentUser && userStats) {
          // Pi登录状态：显示Pi用户名，不可编辑
          displayNickname =
            userStats.username || currentUser.username || "Pi用户";
          nicknameEditable = false;
        } else {
          // 未登录状态：显示本地昵称，可编辑
          displayNickname = savedNickname || t("click_to_set_nickname");
          nicknameEditable = true;
        }

        showCustomModal(
          t("personal_center_title"),
          `
                <div style="text-align: center; max-height: 80vh; overflow-y: auto;">
                    <!-- 个人档案编辑 -->
                    <div style="margin-bottom: 8px;">
                        <div style="background: #f8f9fa; border-radius: 8px; padding: 10px; margin-bottom: 8px;">
                            <!-- 昵称显示 -->
                            <div style="background: white; border-radius: 8px; padding: 10px; margin-bottom: 8px;">
                                <div style="margin-bottom: 5px;">
                                    <h4
                                        style="margin: 0 0 4px 0; color: #333; ${
                                          nicknameEditable
                                            ? "cursor: pointer; transition: color 0.2s;"
                                            : "cursor: default;"
                                        } font-size: 1.2em;"
                                        id="user-nickname-display"
                                        ${
                                          nicknameEditable
                                            ? 'onclick="toggleNicknameEdit()" onmouseover="this.style.color=\'#007bff\'" onmouseout="this.style.color=\'#333\'"'
                                            : ""
                                        }
                                    >${displayNickname}</h4>
                                    ${
                                      nicknameEditable
                                        ? `
                                    <div style="display: none;" id="nickname-edit-section">
                                        <input
                                            type="text"
                                            id="nickname-input"
                                            placeholder="${t(
                                              "enter_your_nickname"
                                            )}"
                                            value="${savedNickname}"
                                            style="
                                                width: 200px;
                                                padding: 8px;
                                                border: 2px solid #e9ecef;
                                                border-radius: 6px;
                                                font-size: 14px;
                                                text-align: center;
                                                box-sizing: border-box;
                                            "
                                            maxlength="20"
                                        />
                                        <button
                                            onclick="updateNickname()"
                                            style="
                                                background: #28a745;
                                                color: white;
                                                border: none;
                                                border-radius: 6px;
                                                padding: 8px 12px;
                                                cursor: pointer;
                                                font-size: 12px;
                                                margin-left: 5px;
                                            "
                                        >
                                            ✓
                                        </button>
                                        <button
                                            onclick="toggleNicknameEdit()"
                                            style="
                                                background: #6c757d;
                                                color: white;
                                                border: none;
                                                border-radius: 6px;
                                                padding: 8px 12px;
                                                cursor: pointer;
                                                font-size: 12px;
                                                margin-left: 5px;
                                            "
                                        >
                                            ✕
                                        </button>
                                    </div>
                                    `
                                        : ""
                                    }
                                </div>
                            </div>

                            <!-- 游戏统计 -->
                            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 6px; margin-bottom: 6px;">
                                <div style="background: white; border-radius: 6px; padding: 8px; text-align: center;">
                                    <div style="font-size: 1.3em; color: #007bff; font-weight: bold;">${
                                      stats.totalGames
                                    }</div>
                                    <div style="color: #666; font-size: 0.8em;">${t(
                                      "total_games_label"
                                    )}</div>
                                </div>
                                <div style="background: white; border-radius: 6px; padding: 8px; text-align: center;">
                                    <div style="font-size: 1.3em; color: #28a745; font-weight: bold;">${
                                      stats.wins
                                    }</div>
                                    <div style="color: #666; font-size: 0.8em;">${t(
                                      "wins_label"
                                    )}</div>
                                </div>
                                <div style="background: white; border-radius: 6px; padding: 8px; text-align: center;">
                                    <div style="font-size: 1.3em; color: #ffc107; font-weight: bold;">${
                                      stats.winRate
                                    }%</div>
                                    <div style="color: #666; font-size: 0.8em;">${t(
                                      "win_rate_label"
                                    )}</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- 账户余额和钱包地址 -->
                    <div style="background: #f8f9fa; border-radius: 8px; padding: 8px; margin-bottom: 8px;">
                        <div style="background: white; border-radius: 8px; padding: 8px; margin-bottom: 6px; border: 2px solid #e3f2fd;">
                            <div style="font-size: 1.8em; color: #f39c12; font-weight: bold; margin-bottom: 4px;" id="account-balance">
                                ${t("loading_text_display")}
                            </div>
                            <div style="display: flex; gap: 8px; justify-content: center; margin-top: 8px;">
                                <button onclick="refreshBalance()" style="background: #17a2b8; color: white; border: none; border-radius: 4px; padding: 6px 12px; cursor: pointer; font-size: 12px;">
                                    ${t("refresh_balance_text")}
                                </button>
                                <button onclick="showRechargeDialog(t('recharge_prompt'))" style="background: #28a745; color: white; border: none; border-radius: 4px; padding: 6px 12px; cursor: pointer; font-size: 12px;">
                                    ${t("recharge_text")}
                                </button>
                            </div>
                        </div>

                        <!-- 钱包地址输入 -->
                        <div style="background: white; border-radius: 8px; padding: 8px;">
                            <div style="margin-bottom: 0;">
                                <input
                                    type="text"
                                    id="wallet-address-input"
                                    placeholder="${t(
                                      "wallet_address_placeholder"
                                    )}"
                                    value="${savedWalletAddress}"
                                    maxlength="50"
                                    style="
                                        width: 100%;
                                        padding: 8px;
                                        border: 2px solid #e9ecef;
                                        border-radius: 6px;
                                        font-size: 14px;
                                        box-sizing: border-box;
                                        font-family: monospace;
                                        text-transform: uppercase;
                                        background: #f8f9fa;
                                    "
                                />
                                <div style="margin-top: 8px; display: flex; justify-content: space-between; align-items: center;">
                                    <small style="color: #6c757d; font-size: 12px;">
                                        ${t("wallet_format_hint")}
                                    </small>
                                    <span id="wallet-char-count" style="color: #6c757d; font-size: 12px;">
                                        ${savedWalletAddress.length}/50
                                    </span>
                                </div>
                                <div style="margin-top: 6px; text-align: center;">
                                    <button
                                        onclick="saveWalletAddress()"
                                        style="
                                            background: #28a745;
                                            color: white;
                                            border: none;
                                            border-radius: 6px;
                                            padding: 8px 16px;
                                            cursor: pointer;
                                            font-size: 14px;
                                            margin-right: 8px;
                                        "
                                    >
                                        ${t("save_wallet")}
                                    </button>
                                    <button
                                        onclick="editWalletAddress()"
                                        style="
                                            background: #17a2b8;
                                            color: white;
                                            border: none;
                                            border-radius: 6px;
                                            padding: 8px 16px;
                                            cursor: pointer;
                                            font-size: 14px;
                                        "
                                    >
                                        ${t("edit_wallet")}
                                    </button>
                                </div>
                            </div>

                            <!-- 月度奖励重要提示 -->
                            <div style="margin-top: 8px; padding: 8px; background: #fff3cd; border-radius: 4px; border: 1px solid #ffeaa7;">
                                <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;">
                                    <span style="font-size: 14px;">🏆</span>
                                    <strong style="color: #856404; font-size: 12px;">${t(
                                      "monthly_reward_reminder"
                                    )}</strong>
                                </div>
                                <p style="color: #856404; font-size: 11px; margin: 0; line-height: 1.4;">
                                    ${t("monthly_reward_desc")}
                                </p>
                            </div>
                        </div>
                    </div>



                    <div style="text-align: center; margin-top: 6px;">
                        ${
                          currentUser && userStats
                            ? `
                        <button
                            onclick="logoutUser()"
                            style="
                                background: #dc3545;
                                color: white;
                                border: none;
                                border-radius: 8px;
                                padding: 8px 16px;
                                cursor: pointer;
                                font-size: 14px;
                                font-weight: 500;
                                transition: background 0.2s;
                            "
                            onmouseover="this.style.background='#c82333'"
                            onmouseout="this.style.background='#dc3545'"
                        >
                            ${t("logout_account_text")}
                        </button>
                        `
                            : `
                        <button
                            onclick="handlePersonalCenterLogin()"
                            style="
                                background: #7b2cbf;
                                color: white;
                                border: none;
                                border-radius: 8px;
                                padding: 8px 16px;
                                cursor: pointer;
                                font-size: 14px;
                                font-weight: 500;
                                transition: background 0.2s;
                            "
                            onmouseover="this.style.background='#5a189a'"
                            onmouseout="this.style.background='#7b2cbf'"
                        >
                            ${t("login_with_pi")}
                        </button>
                        `
                        }
                    </div>
                </div>
            `
        );

        // 初始化钱包地址状态和刷新余额
        setTimeout(() => {
          initializeWalletAddressState();
          refreshBalance(); // 自动刷新余额
        }, 100);
      }

      // 初始化钱包地址状态
      function initializeWalletAddressState() {
        const walletInput = document.getElementById("wallet-address-input");
        const savedWalletAddress =
          localStorage.getItem("userWalletAddress") || "";

        if (walletInput) {
          // 更新字符计数
          updateWalletCharCount(savedWalletAddress.length);

          // 如果已有完整的钱包地址，设置为只读状态
          if (savedWalletAddress.length === 50) {
            walletInput.style.background = "#e9ecef";
            walletInput.readOnly = true;
          } else {
            walletInput.style.background = "#f8f9fa";
            walletInput.readOnly = false;
          }
        }
      }

      // 个人中心登录处理
      async function handlePersonalCenterLogin() {
        // 保存当前在个人中心的状态
        const wasInPersonalCenter = true;

        // 关闭个人中心弹窗
        closePersonalCenter();

        // 调用主页登录逻辑
        await handleSignIn();

        // 登录成功后重新打开个人中心
        if (currentUser) {
          setTimeout(() => {
            showPersonalCenter();
          }, 1000); // 等待登录成功提示显示后再打开个人中心
        }
      }

      // 关闭个人中心弹窗
      function closePersonalCenter() {
        const modal = document.querySelector(".custom-modal");
        if (modal) {
          modal.remove();
        }
      }

      // 切换昵称编辑模式
      function toggleNicknameEdit() {
        const editSection = document.getElementById("nickname-edit-section");
        const isVisible = editSection.style.display !== "none";

        if (isVisible) {
          editSection.style.display = "none";
        } else {
          editSection.style.display = "block";
          // 聚焦到输入框
          setTimeout(() => {
            document.getElementById("nickname-input").focus();
          }, 100);
        }
      }

      // 更新用户昵称
      function updateNickname() {
        const nicknameInput = document.getElementById("nickname-input");
        const nicknameDisplay = document.getElementById(
          "user-nickname-display"
        );
        const newNickname = nicknameInput.value.trim();

        if (!newNickname) {
          showCustomAlert(t("hint"), t("enter_nickname"));
          return;
        }

        if (newNickname.length > 20) {
          showCustomAlert(t("hint"), t("nickname_too_long"));
          return;
        }

        // 过滤敏感词（简单示例）
        const forbiddenWords = ["admin", "管理员", "系统", "system"];
        if (
          forbiddenWords.some((word) =>
            newNickname.toLowerCase().includes(word)
          )
        ) {
          showCustomAlert(t("hint"), t("nickname_forbidden"));
          return;
        }

        // 保存到本地存储
        localStorage.setItem("userNickname", newNickname);

        // 更新显示
        nicknameDisplay.textContent = newNickname;

        // 隐藏编辑区域
        document.getElementById("nickname-edit-section").style.display = "none";

        showCustomAlert(t("success_title"), t("nickname_updated"));
      }

      // 保存钱包地址
      function saveWalletAddress() {
        const walletInput = document.getElementById("wallet-address-input");
        const walletAddress = walletInput.value.trim();

        if (!walletAddress) {
          showCustomAlert(t("hint"), t("enter_wallet_hint"));
          return;
        }

        // 验证钱包地址格式：50位大写字母和数字
        if (walletAddress.length !== 50) {
          showCustomAlert(
            t("error_title"),
            t("wallet_length_error", walletAddress.length)
          );
          return;
        }

        if (!/^[A-Z0-9]{50}$/.test(walletAddress)) {
          showCustomAlert(t("error_title"), t("wallet_format_error"));
          return;
        }

        // 保存到本地存储
        localStorage.setItem("userWalletAddress", walletAddress);

        // 显示成功消息
        showCustomAlert(t("success_title"), t("wallet_saved_success"));

        // 设置输入框为只读状态
        walletInput.style.background = "#e9ecef";
        walletInput.readOnly = true;

        // 自动刷新余额
        refreshBalance();
      }

      // 编辑钱包地址
      function editWalletAddress() {
        const walletInput = document.getElementById("wallet-address-input");

        // 启用编辑模式
        walletInput.style.background = "#f8f9fa";
        walletInput.readOnly = false;
        walletInput.focus();

        // 选中所有文本便于编辑
        walletInput.select();

        showCustomAlert(t("edit_mode_title"), t("edit_mode_message"));
      }

      // 退出账户
      function logoutUser() {
        showCustomConfirm(
          t("logout_confirm"),
          t("logout_message"),
          () => {
            // 保存当前用户的游戏数据到用户专属存储
            if (currentUser && userStats) {
              const userGameData = {
                userId: currentUser.piUserId || currentUser.uid,
                username: currentUser.username,
                gameStats: userStats,
                lastUpdated: new Date().toISOString(),
              };
              localStorage.setItem(
                `piGomokuUserData_${currentUser.piUserId || currentUser.uid}`,
                JSON.stringify(userGameData)
              );
            }

            // 只清除会话相关的数据，保留游戏统计数据
            localStorage.removeItem("piGomokuNickname");
            localStorage.removeItem("userAvatar");
            localStorage.removeItem("userWalletAddress");
            localStorage.removeItem("piGomokuLeaderboard");
            // 注意：不删除 piGomokuGameStats，改为用户专属存储

            // 清除登录状态
            clearLoginState();

            // 清除内存中的用户状态
            currentUser = null;
            userStats = null;

            // 显示退出成功消息
            showCustomAlert(t("logout_success"), t("logout_success_message"));

            // 关闭个人中心
            closePersonalCenter();

            // 更新主页按钮状态
            updateMainPageButtonState();

            // 刷新页面重置所有状态
            setTimeout(() => {
              location.reload();
            }, 1000);
          },
          () => {
            // 取消时不做任何操作
          }
        );
      }

      // 刷新账户余额
      async function refreshBalance() {
        const balanceElement = document.getElementById("account-balance");

        if (!currentUser) {
          showCustomAlert(t("hint"), t("please_login_first"));
          return;
        }

        try {
          balanceElement.innerHTML = t("balance_querying");

          const response = await fetch(
            `${API_BASE_URL}/api/payment/balance?userId=${currentUser.uid}`
          );
          const data = await response.json();

          if (data.success) {
            balanceElement.innerHTML = `${data.balance.current.toFixed(2)} π`;

            // 显示余额详情（可选）
            if (
              data.balance.totalRecharged > 0 ||
              data.balance.totalSpent > 0
            ) {
              const tooltip = t(
                "balance_tooltip",
                data.balance.totalRecharged.toFixed(2),
                data.balance.totalSpent.toFixed(2)
              );
              balanceElement.title = tooltip;
            }
          } else {
            balanceElement.innerHTML = "0.00 π";
            console.error("获取余额失败:", data.message);
          }
        } catch (error) {
          console.error("刷新余额失败:", error);
          balanceElement.innerHTML = t("balance_query_failed_display");
          setTimeout(() => {
            balanceElement.innerHTML = "0.00 π";
          }, 2000);
        }
      }

      // 获取等级名称
      function getLevelName(score) {
        if (score >= 2000) return "大师级";
        if (score >= 1500) return "专家级";
        if (score >= 1200) return "高级棋手";
        if (score >= 1000) return "中级棋手";
        if (score >= 800) return "初级棋手";
        return "新手";
      }

      // 获取等级进度
      function getLevelProgress(score) {
        const levels = [0, 800, 1000, 1200, 1500, 2000, 3000];
        for (let i = 0; i < levels.length - 1; i++) {
          if (score >= levels[i] && score < levels[i + 1]) {
            const progress =
              ((score - levels[i]) / (levels[i + 1] - levels[i])) * 100;
            return Math.min(100, Math.max(0, progress));
          }
        }
        return 100; // 最高级
      }

      // 显示游戏说明
      function showGameInstructions() {
        showCustomModal(
          t("game_instructions_title"),
          `
                <div style="text-align: left; max-height: 500px; overflow-y: auto;">
                    <!-- 历史渊源 -->
                    <div style="text-align: center; margin-bottom: 20px;">
                        <span style="font-size: 3em; margin-bottom: 10px; display: block;">🏛️</span>
                        <h3 style="color: #333; margin-bottom: 15px;">${t(
                          "game_history_section"
                        )}</h3>
                        <p style="margin: 0; line-height: 1.6; font-size: 14px; color: #666;">
                            ${t("game_history_desc")}
                        </p>
                    </div>

                    <!-- Basic Rules -->
                    <div style="background: #f8f9fa; border-radius: 8px; padding: 15px; margin-bottom: 15px;">
                        <h4 style="color: #333; margin: 0 0 12px 0; font-size: 16px;">${t(
                          "game_rules_title"
                        )}</h4>
                        <ul style="margin: 0; padding-left: 20px; line-height: 1.6; font-size: 14px; color: #333;">
                            <li>${t("basic_rules_detail_1")}</li>
                            <li>${t("basic_rules_detail_2")}</li>
                            <li>${t("basic_rules_detail_3")}</li>
                            <li>${t("basic_rules_detail_4")}</li>
                        </ul>
                    </div>

                    <!-- 回合时间规则 -->
                    <div style="background: #fff3cd; border-radius: 8px; padding: 15px; margin-bottom: 15px;">
                        <h4 style="color: #856404; margin: 0 0 12px 0; font-size: 16px;">${t(
                          "turn_time_rules"
                        )}</h4>
                        <ul style="margin: 0; padding-left: 20px; line-height: 1.6; font-size: 14px; color: #856404;">
                            <li><strong>${t("thinking_time_rule")}</strong></li>
                            <li><strong>${t("time_warning_rule")}</strong></li>
                            <li><strong>${t(
                              "urgent_warning_rule"
                            )}</strong></li>
                            <li><strong>${t("timeout_rule")}</strong></li>
                        </ul>
                    </div>

                    <!-- 游戏操作 -->
                    <div style="background: #e3f2fd; border-radius: 8px; padding: 15px; margin-bottom: 15px;">
                        <h4 style="color: #1976d2; margin: 0 0 12px 0; font-size: 16px;">${t(
                          "game_operations"
                        )}</h4>
                        <ul style="margin: 0; padding-left: 20px; line-height: 1.6; font-size: 14px; color: #1976d2;">
                            <li><strong>${t("place_stone")}</strong></li>
                            <li><strong>${t("undo_move")}</strong></li>
                            <li><strong>${t("new_game_op")}</strong></li>
                            <li><strong>${t("return_op")}</strong></li>
                        </ul>
                    </div>

                    <!-- 积分系统 -->
                    <div style="background: #d4edda; border-radius: 8px; padding: 15px; margin-bottom: 15px;">
                        <h4 style="color: #155724; margin: 0 0 12px 0; font-size: 16px;">${t(
                          "score_system"
                        )}</h4>
                        <ul style="margin: 0; padding-left: 20px; line-height: 1.6; font-size: 14px; color: #155724;">
                            <li><strong>${t("initial_score")}</strong></li>
                            <li><strong>${t("win_score")}</strong></li>
                            <li><strong>${t("draw_score")}</strong></li>
                            <li><strong>${t("lose_score")}</strong></li>
                            <li><strong>${t("quit_score")}</strong></li>
                        </ul>
                        <div style="margin-top: 10px; padding: 8px; background: #c3e6cb; border-radius: 4px; font-size: 13px; color: #155724;">
                            ${t("monthly_reset_system")}<br>
                            ${t("monthly_reset_desc")}<br>
                            ${t("historical_data_preserved")}<br>
                            ${t("monthly_ranking_only")}
                        </div>
                        <div style="margin-top: 8px; padding: 8px; background: #fff3cd; border-radius: 4px; font-size: 13px; color: #856404;">
                            ${t("anti_farming")}
                        </div>
                    </div>

                    <!-- 月度奖励规则 -->
                    <div style="background: #fff3cd; border-radius: 8px; padding: 15px; margin-bottom: 15px; border: 2px solid #ffeaa7;">
                        <h4 style="color: #856404; margin: 0 0 12px 0; font-size: 16px;">${t(
                          "monthly_rewards"
                        )}</h4>
                        <div style="color: #856404; font-size: 14px; line-height: 1.6;">
                            <div style="background: white; border-radius: 6px; padding: 12px; margin-bottom: 12px;">
                                <h5 style="color: #d63384; margin: 0 0 8px 0; font-size: 14px;">${t(
                                  "reward_pool_allocation"
                                )}</h5>
                                <ul style="margin: 0; padding-left: 20px; font-size: 13px;">
                                    <li>${t("reward_settlement")}</li>
                                    <li>${t("reward_pool_percentage")}</li>
                                    <li>${t("reward_example")}</li>
                                </ul>
                            </div>

                            <div style="background: white; border-radius: 6px; padding: 12px; margin-bottom: 12px;">
                                <h5 style="color: #d63384; margin: 0 0 8px 0; font-size: 14px;">${t(
                                  "top_three_distribution"
                                )}</h5>
                                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; font-size: 13px;">
                                    <div style="text-align: center; background: #fff3cd; padding: 8px; border-radius: 4px;">
                                        <div style="font-weight: bold; color: #ff6b35;">${t(
                                          "first_place"
                                        )}</div>
                                        <div style="color: #856404;">50%</div>
                                    </div>
                                    <div style="text-align: center; background: #e2e3e5; padding: 8px; border-radius: 4px;">
                                        <div style="font-weight: bold; color: #6c757d;">${t(
                                          "second_place"
                                        )}</div>
                                        <div style="color: #6c757d;">30%</div>
                                    </div>
                                    <div style="text-align: center; background: #f8d7da; padding: 8px; border-radius: 4px;">
                                        <div style="font-weight: bold; color: #721c24;">${t(
                                          "third_place"
                                        )}</div>
                                        <div style="color: #721c24;">20%</div>
                                    </div>
                                </div>
                            </div>

                            <div style="background: white; border-radius: 6px; padding: 12px;">
                                <h5 style="color: #d63384; margin: 0 0 8px 0; font-size: 14px;">${t(
                                  "distribution_method"
                                )}</h5>
                                <ul style="margin: 0; padding-left: 20px; font-size: 13px;">
                                    <li>${t("wallet_distribution")}</li>
                                    <li>${t("valid_wallet_required")}</li>
                                    <li>${t("next_day_distribution")}</li>
                                    <li>${t("invalid_wallet_rollover")}</li>
                                </ul>
                            </div>

                            <div style="margin-top: 12px; padding: 8px; background: #d1ecf1; border-radius: 4px; font-size: 12px; color: #0c5460; text-align: center;">
                                ${t("reward_example_calculation")}<br>
                                ${t("first_place_reward")} | ${t(
            "second_place_reward"
          )} | ${t("third_place_reward")}
                            </div>
                        </div>
                    </div>

                    <!-- 排行榜规则 -->
                    <div style="background: #f3e5f5; border-radius: 8px; padding: 15px; margin-bottom: 15px;">
                        <h4 style="color: #7b1fa2; margin: 0 0 12px 0; font-size: 16px;">${t(
                          "leaderboard_rules"
                        )}</h4>
                        <ul style="margin: 0; padding-left: 20px; line-height: 1.6; font-size: 14px; color: #7b1fa2;">
                            <li><strong>${t("ranking_condition")}</strong></li>
                            <li><strong>${t("ranking_basis")}</strong></li>
                            <li><strong>${t("data_statistics")}</strong></li>
                            <li><strong>${t("realtime_update")}</strong></li>
                        </ul>
                    </div>

                    <!-- 温馨提示 -->
                    <div style="background: #e8f5e8; border-radius: 8px; padding: 15px; text-align: center;">
                        <p style="margin: 0; color: #2e7d32; font-weight: 500; font-size: 14px; white-space: pre-line;">
                            ${t("warm_tips")}
                        </p>
                    </div>
                </div>
            `
        );
      }

      // 通用模态框显示函数
      function showCustomModal(title, content, callback = null) {
        // 创建模态框HTML
        const modalHTML = `
                <div id="custom-modal" style="
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.5);
                    display: flex;
                    justify-content: center;
                    align-items: flex-start;
                    padding-top: 5vh;
                    z-index: 1000;
                    padding: 20px;
                    box-sizing: border-box;
                ">
                    <div style="
                        background: white;
                        border-radius: 12px;
                        max-width: 500px;
                        width: 100%;
                        max-height: 90vh;
                        overflow: hidden;
                        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
                    ">
                        <div style="
                            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                            color: white;
                            padding: 20px;
                            display: flex;
                            justify-content: space-between;
                            align-items: center;
                        ">
                            <h3 style="margin: 0; font-size: 1.2em;">${title}</h3>
                            <button onclick="closeNewModal()" style="
                                background: none;
                                border: none;
                                color: white;
                                font-size: 1.5em;
                                cursor: pointer;
                                padding: 0;
                                width: 30px;
                                height: 30px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                border-radius: 50%;
                                transition: background 0.2s;
                            " onmouseover="this.style.background='rgba(255,255,255,0.2)'" onmouseout="this.style.background='none'">×</button>
                        </div>
                        <div style="padding: 20px; overflow-y: auto; max-height: calc(90vh - 80px);">
                            ${content}
                        </div>
                    </div>
                </div>
            `;

        // 添加到页面
        document.body.insertAdjacentHTML("beforeend", modalHTML);

        // 点击背景关闭
        document
          .getElementById("custom-modal")
          .addEventListener("click", function (e) {
            if (e.target === this) {
              closeNewModal();
            }
          });
      }

      // 关闭新的自定义模态框
      function closeNewModal() {
        const modal = document.getElementById("custom-modal");
        if (modal) {
          modal.remove();
        }
        // 停止排行榜自动刷新
        stopLeaderboardAutoRefresh();
      }

      // ==================== 游戏统计和排行榜功能 ====================

      // 加载用户统计数据
      async function loadUserStats() {
        if (!currentUser) return;

        try {
          const response = await fetch(
            `${API_BASE_URL}/api/users/stats?uid=${currentUser.uid}`
          );
          if (response.ok) {
            const data = await response.json();
            userStats = data.stats;
          } else {
            // 用户首次登录，创建初始统计
            userStats = {
              userId: currentUser.uid,
              username:
                currentUser.username ||
                `玩家${currentUser.uid.substring(0, 8)}`,
              totalGames: 0,
              wins: 0,
              losses: 0,
              draws: 0,
              winRate: 0,
              rank: 0,
            };
          }
        } catch (error) {
          console.error("加载用户统计失败:", error);
          // 使用默认统计数据
          userStats = {
            userId: currentUser.uid,
            username:
              currentUser.username || `玩家${currentUser.uid.substring(0, 8)}`,
            totalGames: 0,
            wins: 0,
            losses: 0,
            draws: 0,
            winRate: 0,
            rank: 0,
          };
        }
      }

      // 刷新用户统计数据（用于个人中心）
      async function refreshUserStats() {
        if (!currentUser) return;

        // 确保有piUserId，如果没有则使用uid
        if (!currentUser.piUserId) {
          currentUser.piUserId = currentUser.uid;
        }

        // 先获取本地数据作为备份
        const localStats = localStorage.getItem("piGomokuGameStats");
        let localUserStats = null;
        if (localStats) {
          try {
            localUserStats = JSON.parse(localStats);
          } catch (error) {
            console.error("解析本地统计数据失败:", error);
          }
        }

        try {
          const apiUrl = `${API_BASE_URL}/api/users/stats?uid=${currentUser.piUserId}`;
          const response = await fetch(apiUrl);

          if (response.ok) {
            const data = await response.json();
            const backendStats = data.stats;

            // 数据完整性检查：如果后端数据明显异常（总局数为0但本地有数据），优先使用本地数据
            if (
              localUserStats &&
              localUserStats.totalGames > 0 &&
              backendStats.totalGames === 0
            ) {
              console.log("[数据恢复] 检测到后端数据异常，使用本地数据");
              userStats = localUserStats;

              // 尝试将本地数据同步回后端（通过记录一个虚拟游戏来恢复数据）
              try {
                await syncLocalDataToBackend(localUserStats);
              } catch (syncError) {
                console.error("同步本地数据到后端失败:", syncError);
              }
            } else {
              // 后端数据正常，使用后端数据
              userStats = backendStats;

              // 保存到本地存储
              localStorage.setItem(
                "piGomokuGameStats",
                JSON.stringify(userStats)
              );

              // 同时保存到用户专属存储
              saveUserGameDataToSpecificStorage();
            }
          } else {
            // 后端请求失败，使用本地数据
            if (localUserStats) {
              console.log("[数据恢复] 后端请求失败，使用本地数据");
              userStats = localUserStats;
            }
          }
        } catch (error) {
          console.error("刷新用户统计失败:", error);
          // 网络错误，使用本地数据
          if (localUserStats) {
            console.log("[数据恢复] 网络错误，使用本地数据");
            userStats = localUserStats;
          }
        }
      }

      // 同步本地数据到后端
      async function syncLocalDataToBackend(localStats) {
        if (!currentUser || !localStats) return;

        try {
          // 为每个本地游戏记录一个胜利，以恢复后端统计数据
          for (let i = 0; i < (localStats.wins || 0); i++) {
            await fetch(`${API_BASE_URL}/api/games`, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({
                playerUid: currentUser.piUserId || currentUser.uid,
                result: "win",
                moves: [],
                duration: 0,
              }),
            });
          }

          // 为每个本地游戏记录一个失败
          for (let i = 0; i < (localStats.losses || 0); i++) {
            await fetch(`${API_BASE_URL}/api/games`, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({
                playerUid: currentUser.piUserId || currentUser.uid,
                result: "lose",
                moves: [],
                duration: 0,
              }),
            });
          }

          console.log("[数据恢复] 本地数据已成功同步到后端");
        } catch (error) {
          console.error("[数据恢复] 同步失败:", error);
        }
      }

      // 记录游戏结果
      async function recordGameResult(result, gameData = {}) {
        if (!currentUser) {
          return;
        }

        // 如果 userStats 不存在，先初始化
        if (!userStats) {
          initializeUserStatsFromLocal();
          if (!userStats) {
            createDefaultUserStats();
          }
        }

        // 先更新本地数据
        updateLocalGameStats(result);

        try {
          const userId = currentUser.piUserId || currentUser.uid;
          const apiUrl = `${API_BASE_URL}/api/games`;

          // 确保使用与个人中心一致的用户名
          const displayUsername = getCurrentDisplayUsername();

          // 同步更新本地userStats的用户名
          if (userStats) {
            userStats.username = displayUsername;
          }

          const response = await fetch(apiUrl, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              playerUid: currentUser.piUserId || currentUser.uid,
              result: result === 'loss' ? 'lose' : result, // 'win', 'lose', 'draw' - 后端期望的格式
              moves: gameData.moves || [],
              duration: gameData.duration || 0,
            }),
          });

          if (response.ok) {
            const data = await response.json();
            userStats = data.userStats; // 更新本地统计数据

            // 保存到本地存储
            localStorage.setItem(
              "piGomokuGameStats",
              JSON.stringify(userStats)
            );

            // 同时保存到用户专属存储
            saveUserGameDataToSpecificStorage();

            // 刷新本地排行榜数据
            refreshLocalLeaderboardData();

            // 显示游戏结果统计
            await showGameResultStats(result, data.userStats);
          } else {
            console.error("记录游戏结果到后端失败:", response.statusText);
            // 后端失败时，确保本地数据已保存并刷新排行榜
            saveUserGameDataToSpecificStorage();
            refreshLocalLeaderboardData();
            // 使用本地数据显示结果
            await showGameResultStats(result, userStats);
          }
        } catch (error) {
          console.error("记录游戏结果失败:", error);
          // 网络错误时，确保本地数据已保存并刷新排行榜
          saveUserGameDataToSpecificStorage();
          refreshLocalLeaderboardData();
          // 使用本地数据显示结果
          await showGameResultStats(result, userStats);
        }
      }

      // 更新本地游戏统计数据
      function updateLocalGameStats(result) {
        if (!userStats) {
          return;
        }

        // 更新统计数据
        userStats.totalGames = (userStats.totalGames || 0) + 1;

        if (result === "win") {
          userStats.wins = (userStats.wins || 0) + 1;
        } else if (result === "loss") {
          userStats.losses = (userStats.losses || 0) + 1;
        } else if (result === "draw") {
          userStats.draws = (userStats.draws || 0) + 1;
        }

        // 重新计算胜率
        if (userStats.totalGames > 0) {
          userStats.winRate = Math.round(
            (userStats.wins / userStats.totalGames) * 100
          );
        }

        // 保存到本地存储
        localStorage.setItem("piGomokuGameStats", JSON.stringify(userStats));

        // 同时保存到用户专属存储
        saveUserGameDataToSpecificStorage();
      }

      // 保存用户游戏数据到专属存储
      function saveUserGameDataToSpecificStorage() {
        if (!currentUser || !userStats) return;

        const userGameData = {
          userId: currentUser.piUserId || currentUser.uid,
          username: getCurrentDisplayUsername(), // 使用统一的用户名获取函数
          gameStats: userStats,
          lastUpdated: new Date().toISOString(),
        };

        const userDataKey = `piGomokuUserData_${
          currentUser.piUserId || currentUser.uid
        }`;
        localStorage.setItem(userDataKey, JSON.stringify(userGameData));

        console.log(`[数据保存] 用户数据已保存到本地存储: ${userDataKey}`, userGameData);
      }

      // 强制刷新本地排行榜数据
      function refreshLocalLeaderboardData() {
        if (currentUser && userStats) {
          // 确保当前用户数据被保存
          saveUserGameDataToSpecificStorage();

          // 重置数据刷新时间，强制下次获取排行榜时重新计算
          lastDataRefreshTime = 0;

          console.log("[排行榜] 本地数据已刷新");
        }
      }

      // 调试函数：分析localStorage中的用户数据
      function debugLocalStorageData() {
        console.log("=== localStorage 数据分析 ===");

        const userDataKeys = [];
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key && key.startsWith('piGomokuUserData_')) {
            userDataKeys.push(key);
          }
        }

        console.log(`找到 ${userDataKeys.length} 个用户数据键:`);
        userDataKeys.forEach(key => {
          try {
            const userData = JSON.parse(localStorage.getItem(key));
            console.log(`${key}:`, {
              userId: userData.userId,
              username: userData.username,
              totalGames: userData.gameStats?.totalGames,
              wins: userData.gameStats?.wins,
              winRate: userData.gameStats?.winRate
            });
          } catch (e) {
            console.error(`解析失败: ${key}`, e);
          }
        });

        console.log("当前用户:", currentUser);
        console.log("当前用户统计:", userStats);
        console.log("=== 分析结束 ===");
      }

      // 强制清理所有用户的重复数据
      function forceCleanupAllDuplicateUsers() {
        console.log("[强制清理] 开始清理所有用户的重复数据...");

        const userDataMap = new Map(); // userId -> 所有该用户的数据条目
        const keysToRemove = [];
        let totalCleaned = 0;

        // 1. 按用户ID分组收集所有数据
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);

          if (key && key.startsWith('piGomokuUserData_')) {
            try {
              const userData = JSON.parse(localStorage.getItem(key));
              if (userData && userData.userId && userData.gameStats) {
                const userId = userData.userId;

                if (!userDataMap.has(userId)) {
                  userDataMap.set(userId, []);
                }

                userDataMap.get(userId).push({
                  key: key,
                  data: userData,
                  totalGames: userData.gameStats.totalGames || 0,
                  wins: userData.gameStats.wins || 0,
                  winRate: userData.gameStats.winRate || 0,
                  lastUpdated: userData.lastUpdated || 0
                });
              } else {
                // 格式错误的数据直接删除
                keysToRemove.push(key);
                console.log(`[强制清理] 删除格式错误的数据: ${key}`);
              }
            } catch (error) {
              console.error(`[强制清理] 解析失败: ${key}`, error);
              keysToRemove.push(key);
            }
          }
        }

        // 2. 对每个用户，只保留最正确的数据
        userDataMap.forEach((entries, userId) => {
          if (entries.length > 1) {
            console.log(`[强制清理] 用户 ${userId} 有 ${entries.length} 个重复数据`);

            // 按游戏局数排序，局数相同时按时间戳排序
            entries.sort((a, b) => {
              if (b.totalGames !== a.totalGames) {
                return b.totalGames - a.totalGames; // 游戏局数多的优先
              }
              return b.lastUpdated - a.lastUpdated; // 时间新的优先
            });

            const keepEntry = entries[0];
            console.log(`[强制清理] 用户 ${userId} 保留: ${keepEntry.key} (总局数: ${keepEntry.totalGames})`);

            // 删除其他重复数据
            for (let i = 1; i < entries.length; i++) {
              const entry = entries[i];
              localStorage.removeItem(entry.key);
              keysToRemove.push(entry.key);
              totalCleaned++;
              console.log(`[强制清理] 用户 ${userId} 删除: ${entry.key} (总局数: ${entry.totalGames})`);
            }
          }
        });

        // 3. 删除格式错误的数据
        keysToRemove.forEach(key => {
          if (localStorage.getItem(key)) { // 确保还存在才删除
            localStorage.removeItem(key);
          }
        });

        console.log(`[强制清理] 清理完成！`);
        console.log(`[强制清理] - 处理了 ${userDataMap.size} 个用户`);
        console.log(`[强制清理] - 删除了 ${totalCleaned} 个重复数据条目`);
        console.log(`[强制清理] - 删除了 ${keysToRemove.length - totalCleaned} 个格式错误的数据`);

        return totalCleaned;
      }

      // 在全局作用域中暴露调试函数
      window.debugLocalStorageData = debugLocalStorageData;
      window.cleanupDuplicateUserData = cleanupDuplicateUserData;
      window.forceCleanupAllDuplicateUsers = forceCleanupAllDuplicateUsers;

      // 清理重复的用户数据
      function cleanupDuplicateUserData() {
        console.log("[数据清理] 开始清理重复的用户数据...");

        const userDataMap = new Map(); // userId -> 最新的用户数据
        const keysToRemove = [];

        // 1. 收集所有用户数据，保留游戏局数最多的数据（最可能是正确的）
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);

          if (key && key.startsWith('piGomokuUserData_')) {
            try {
              const userData = JSON.parse(localStorage.getItem(key));
              if (userData && userData.userId && userData.gameStats) {
                const userId = userData.userId;
                const totalGames = userData.gameStats.totalGames || 0;

                console.log(`[数据清理] 发现用户数据: ${userId} (${key}) - 总局数: ${totalGames}`);

                if (userDataMap.has(userId)) {
                  // 如果已存在，比较游戏局数，保留局数更多的数据
                  const existingData = userDataMap.get(userId);
                  const existingGames = existingData.gameStats.totalGames || 0;

                  if (totalGames > existingGames) {
                    // 当前数据游戏局数更多，标记旧key删除
                    keysToRemove.push(existingData.storageKey);
                    userDataMap.set(userId, { ...userData, storageKey: key });
                    console.log(`[数据清理] 用户 ${userId} 保留局数更多的数据: ${totalGames} > ${existingGames} (${key})`);
                  } else if (totalGames < existingGames) {
                    // 旧数据游戏局数更多，标记当前key删除
                    keysToRemove.push(key);
                    console.log(`[数据清理] 用户 ${userId} 删除局数较少的数据: ${totalGames} < ${existingGames} (${key})`);
                  } else {
                    // 游戏局数相同，比较时间戳
                    const existingTimestamp = existingData.lastUpdated || 0;
                    const currentTimestamp = userData.lastUpdated || 0;

                    if (currentTimestamp > existingTimestamp) {
                      keysToRemove.push(existingData.storageKey);
                      userDataMap.set(userId, { ...userData, storageKey: key });
                      console.log(`[数据清理] 用户 ${userId} 保留时间更新的数据 (${key})`);
                    } else {
                      keysToRemove.push(key);
                      console.log(`[数据清理] 用户 ${userId} 删除时间较旧的数据 (${key})`);
                    }
                  }
                } else {
                  // 首次遇到该用户
                  userDataMap.set(userId, { ...userData, storageKey: key });
                  console.log(`[数据清理] 用户 ${userId} 首次记录 (${key})`);
                }
              } else {
                // 数据格式不正确，删除
                keysToRemove.push(key);
                console.log(`[数据清理] 删除格式错误的数据: ${key}`);
              }
            } catch (error) {
              console.error(`[数据清理] 解析数据失败 ${key}:`, error);
              keysToRemove.push(key); // 损坏的数据也删除
            }
          }
        }

        // 2. 删除重复的数据
        keysToRemove.forEach(key => {
          localStorage.removeItem(key);
          console.log(`[数据清理] 删除重复数据: ${key}`);
        });

        console.log(`[数据清理] 清理完成，删除了 ${keysToRemove.length} 个重复项`);
        console.log(`[数据清理] 保留了 ${userDataMap.size} 个唯一用户的数据`);

        // 3. 输出保留的数据详情
        userDataMap.forEach((data, userId) => {
          console.log(`[数据清理] 保留用户: ${userId} - 总局数: ${data.gameStats.totalGames} - 存储键: ${data.storageKey}`);
        });

        return keysToRemove.length;
      }

      // 在页面加载时自动清理重复数据
      document.addEventListener('DOMContentLoaded', function() {
        // 延迟执行清理，确保其他初始化完成
        setTimeout(() => {
          console.log("[页面加载] 开始自动清理重复数据...");
          const cleanedCount = forceCleanupAllDuplicateUsers();
          if (cleanedCount > 0) {
            console.log(`[页面加载] 自动清理完成，删除了 ${cleanedCount} 个重复数据`);
          } else {
            console.log("[页面加载] 没有发现重复数据");
          }
        }, 1000);
      });



      // 显示游戏结果统计
      async function showGameResultStats(result, stats) {
        const resultText = {
          win: t("congratulations_win"),
          loss: t("sorry_lose"),
          draw: t("draw_result"),
        };

        // 检查是否为登录用户
        const isLoggedIn = currentUser && userStats;

        // 获取实时排名
        let currentRank = 0;
        if (isLoggedIn && currentUser.piUserId) {
          try {
            currentRank = await getUserRank(currentUser.piUserId);
          } catch (error) {
            console.error("获取用户排名失败:", error);
          }
        }

        showCustomModal(
          t("game_result"),
          `
                <div style="text-align: center;">
                    <div style="font-size: 3em; margin-bottom: 15px;">
                        ${
                          result === "win"
                            ? "🏆"
                            : result === "loss"
                            ? "😢"
                            : "🤝"
                        }
                    </div>
                    <h3 style="color: #333; margin-bottom: 20px;">${
                      resultText[result]
                    }</h3>

                    ${
                      isLoggedIn
                        ? `
                    <div style="background: #f8f9fa; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                            <div style="text-align: center;">
                                <div style="font-size: 1.5em; color: #28a745; font-weight: bold;">${
                                  stats.winRate
                                }%</div>
                                <div style="color: #666; font-size: 0.9em;">${t(
                                  "win_rate"
                                )}</div>
                                <div style="color: #666; font-size: 0.8em;">
                                    ${t(
                                      "wins_losses_format",
                                      stats.wins,
                                      stats.losses
                                    )}
                                </div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 1.5em; color: #007bff; font-weight: bold;">${
                                  stats.totalGames
                                }</div>
                                <div style="color: #666; font-size: 0.9em;">${t(
                                  "ranking_header_games"
                                )}</div>
                                <div style="color: #666; font-size: 0.8em;">
                                    ${t("monthly_games")}
                                </div>
                            </div>
                        </div>

                        <div style="text-align: center; padding-top: 15px; border-top: 1px solid #e9ecef;">
                            <div style="color: #666; font-size: 0.9em;">
                                ${t("current_rank_label")}: ${
                            currentRank > 0
                              ? t("rank_position", currentRank)
                              : t("not_listed")
                          }
                            </div>
                        </div>
                    </div>
                    `
                        : `
                    <div style="background: #fff3cd; border-radius: 8px; padding: 20px; margin-bottom: 20px; border: 2px solid #ffeaa7;">
                        <div style="font-size: 2em; margin-bottom: 10px;">🎮</div>
                        <h4 style="color: #856404; margin-bottom: 15px;">${t(
                          "guest_mode"
                        )}</h4>
                        <p style="color: #856404; margin: 0; line-height: 1.6;">
                            ${t("guest_mode_desc")}<br>
                            <strong>${t("login_benefits")}</strong><br>
                            ${t("benefit_stats")}<br>
                            ${t("benefit_leaderboard")}<br>
                            ${t("benefit_pi_service")}<br>
                            ${t("benefit_monthly_rewards")}
                        </p>
                    </div>
                    `
                    }



                    <div style="display: flex; gap: 10px; justify-content: center;">
                        <button onclick="closeNewModal(); resetAIGame()" style="background: #007bff; color: white; border: none; border-radius: 6px; padding: 10px 20px; cursor: pointer;">
                            ${t("play_again")}
                        </button>
                        ${
                          isLoggedIn
                            ? `
                        <button onclick="closeNewModal(); showRealTimeLeaderboard()" style="background: #28a745; color: white; border: none; border-radius: 6px; padding: 10px 20px; cursor: pointer;">
                            ${t("view_leaderboard")}
                        </button>
                        `
                            : `
                        <button onclick="closeNewModal(); handleSignIn()" style="background: #28a745; color: white; border: none; border-radius: 6px; padding: 10px 20px; cursor: pointer;">
                            ${t("login_now")}
                        </button>
                        `
                        }
                    </div>
                </div>
            `
        );
      }

      // WebSocket连接管理
      let gameWebSocket = null;
      let isConnectedToGameServer = false;
      let currentGameId = null;
      let currentOpponent = null;
      let myColor = null;

      // 连接到游戏服务器
      function connectToGameServer() {
        if (gameWebSocket && gameWebSocket.readyState === WebSocket.OPEN) {
          return Promise.resolve();
        }

        return new Promise((resolve, reject) => {
          try {
            // 根据当前页面协议选择WebSocket协议
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//47.79.240.129:3001`;

            console.log('尝试连接WebSocket:', wsUrl);
            gameWebSocket = new WebSocket(wsUrl);

            // 设置连接超时
            const connectionTimeout = setTimeout(() => {
              if (gameWebSocket.readyState === WebSocket.CONNECTING) {
                gameWebSocket.close();
                reject(new Error('WebSocket连接超时'));
              }
            }, 10000); // 10秒超时

            gameWebSocket.onopen = () => {
              console.log('WebSocket连接成功:', wsUrl);
              clearTimeout(connectionTimeout);
              isConnectedToGameServer = true;

              // 发送用户连接信息
              if (currentUser) {
                gameWebSocket.send(JSON.stringify({
                  type: 'user_connect',
                  payload: {
                    userId: currentUser.piUserId || currentUser.uid,
                    username: currentUser.username,
                    accessToken: currentUser.accessToken
                  }
                }));
              }

              resolve();
            };

            gameWebSocket.onmessage = (event) => {
              try {
                const data = JSON.parse(event.data);
                handleGameServerMessage(data);
              } catch (error) {
                console.error('解析WebSocket消息失败:', error);
              }
            };

            gameWebSocket.onclose = (event) => {
              console.log('WebSocket连接关闭:', event.code, event.reason);
              clearTimeout(connectionTimeout);
              isConnectedToGameServer = false;
              gameWebSocket = null;
            };

            gameWebSocket.onerror = (error) => {
              console.error('WebSocket错误:', error);
              console.error('连接URL:', wsUrl);
              console.error('当前协议:', window.location.protocol);
              clearTimeout(connectionTimeout);
              isConnectedToGameServer = false;
              reject(new Error(`WebSocket连接失败: ${wsUrl}`));
            };

          } catch (error) {
            reject(error);
          }
        });
      }

      // 处理游戏服务器消息
      function handleGameServerMessage(data) {
        const { type, payload } = data;

        switch (type) {
          case 'connected':
            console.log('已连接到游戏服务器:', payload);
            updateOnlineCount(payload.onlineUsers);
            break;

          case 'online_count_update':
            updateOnlineCount(payload.onlineUsers);
            break;

          case 'matching_started':
            console.log('匹配开始:', payload);
            break;

          case 'game_started':
            handleGameStarted(payload);
            break;

          case 'game_move':
            handleOpponentMove(payload);
            break;

          case 'game_ended':
            handleGameEnded(payload);
            break;

          case 'opponent_disconnected':
            handleOpponentDisconnected(payload);
            break;

          case 'error':
            console.error('游戏服务器错误:', payload);
            showError(payload.message || '服务器错误');
            break;
        }
      }

      // 显示在线匹配界面
      async function showOnlineMatchScreen() {
        // 检查用户是否已登录
        if (!currentUser) {
          showError(t("please_login_first"));
          return;
        }

        // 由于后端服务暂未部署，直接显示匹配界面并模拟匹配AI

        const root = document.getElementById("root");
        root.innerHTML = `
          <div style="height: 100vh; background: linear-gradient(135deg, var(--pi-primary) 0%, var(--pi-secondary) 100%); display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 20px; box-sizing: border-box; position: relative;">
            <div style="background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px); border-radius: 20px; padding: 40px; text-align: center; max-width: 400px; width: 100%; border: 2px solid rgba(255, 255, 255, 0.2);">
              <!-- 返回按钮 -->
              <button onclick="cancelMatchAndReturn()" style="position: absolute; top: 20px; left: 20px; background: rgba(255, 255, 255, 0.2); border: none; border-radius: 50%; width: 40px; height: 40px; color: white; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center; z-index: 10;">
                ←
              </button>

              <!-- 标题 -->
              <h2 style="color: white; margin-bottom: 30px; font-size: 24px;">
                🌐 <span data-i18n="online_match">在线匹配</span>
              </h2>

              <!-- 匹配状态 -->
              <div id="matchStatus" style="margin-bottom: 30px;">
                <div style="color: white; font-size: 18px; margin-bottom: 20px;" data-i18n="searching_opponent">
                  ${t("searching_opponent")}
                </div>
                <div style="width: 60px; height: 60px; border: 4px solid rgba(255, 255, 255, 0.3); border-top: 4px solid white; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto;"></div>
              </div>

              <!-- 在线玩家数 -->
              <div style="color: rgba(255, 255, 255, 0.8); margin-bottom: 20px;">
                <span data-i18n="online_players">${t("online_players")}</span>：<span id="onlineCount">-</span> <span data-i18n="people_suffix">${t("people_suffix")}</span>
              </div>

              <!-- 匹配说明 -->
              <div style="color: rgba(255, 255, 255, 0.7); font-size: 14px; margin-bottom: 30px;">
                <span data-i18n="match_description">${t("match_description")}</span><br>
                <span data-i18n="estimated_wait">${t("estimated_wait")}</span>
              </div>

              <!-- 取消匹配按钮 -->
              <button onclick="cancelRealMatch()" style="background: rgba(255, 255, 255, 0.2); border: 2px solid rgba(255, 255, 255, 0.3); border-radius: 25px; padding: 12px 30px; color: white; font-size: 16px; cursor: pointer; transition: all 0.3s;" data-i18n="cancel_match">
                ${t("cancel_match")}
              </button>
            </div>
          </div>

          <style>
            @keyframes spin {
              0% { transform: rotate(0deg); }
              100% { transform: rotate(360deg); }
            }
          </style>
        `;

        // 开始AI匹配模拟
        startAIMatching();
      }

      // 开始AI匹配模拟
      function startAIMatching() {
        console.log('开始AI匹配模拟');

        // 更新在线用户数显示（模拟）
        updateOnlineCount(Math.floor(Math.random() * 50) + 10); // 10-59人在线

        // 模拟匹配过程，2-4秒后匹配成功
        const matchTime = Math.random() * 2000 + 2000; // 2-4秒

        setTimeout(() => {
          // 模拟匹配到AI对手
          const aiOpponent = {
            username: t("ai_opponent_name"),
            uid: "ai_opponent_" + Date.now(),
            isAI: true
          };

          // 随机分配颜色
          const myColor = Math.random() < 0.5 ? 'black' : 'white';
          const currentPlayer = 'black'; // 黑子先手

          // 模拟游戏开始
          handleAIGameStarted({
            gameId: "ai_game_" + Date.now(),
            opponent: aiOpponent,
            yourColor: myColor,
            currentPlayer: currentPlayer
          });
        }, matchTime);
      }

      // 处理AI游戏开始
      function handleAIGameStarted(payload) {
        const { gameId, opponent, yourColor, currentPlayer } = payload;

        currentGameId = gameId;
        currentOpponent = opponent;
        myColor = yourColor;

        console.log(`AI游戏开始! 对手: ${opponent.username}, 我的颜色: ${yourColor}`);

        // 显示游戏开始对话框
        showAIGameStartDialog(opponent, yourColor, currentPlayer);
      }

      // 显示AI游戏开始对话框
      function showAIGameStartDialog(opponent, yourColor, currentPlayer) {
        const matchStatus = document.getElementById("matchStatus");
        if (matchStatus) {
          const isMyTurn = currentPlayer === yourColor;
          matchStatus.innerHTML = `
            <div style="color: #4CAF50; font-size: 18px; margin-bottom: 20px;">
              🎉 ${t("match_found")}
            </div>
            <div style="color: white; margin-bottom: 20px;">
              ${t("opponent_label")}<strong>${opponent.username}</strong><br>
              ${t("your_color")}: ${yourColor === 'black' ? '⚫ ' + t("black_stone") : '⚪ ' + t("white_stone")}<br>
              ${isMyTurn ? '🎯 ' + t("your_turn") : '⏳ ' + t("opponent_turn")}
            </div>
            <div style="display: flex; flex-direction: row; gap: 10px; justify-content: center; align-items: center; width: 100%; flex-wrap: nowrap;">
              <button onclick="startAIGame()" style="background: #4CAF50; border: none; border-radius: 25px; padding: 10px 20px; color: white; font-size: 14px; cursor: pointer; flex: 1; min-width: 80px; max-width: 140px; transition: all 0.3s; white-space: nowrap;">
                ${t("start_game")}
              </button>
            </div>
          `;
        }
      }

      // 开始AI游戏
      function startAIGame() {
        if (!currentGameId || !currentOpponent) {
          showError(t("game_not_ready"));
          return;
        }

        // 直接启动AI对战游戏
        showSimpleGameScreen();
      }

      // 取消匹配
      function cancelRealMatch() {
        showMainScreen();
      }

      // 取消匹配并返回主界面
      function cancelMatchAndReturn() {
        cancelRealMatch();
      }

      // 更新在线用户数
      function updateOnlineCount(count) {
        const onlineCountElement = document.getElementById("onlineCount");
        if (onlineCountElement) {
          onlineCountElement.textContent = count;
        }
      }

      // 处理游戏开始
      function handleGameStarted(payload) {
        const { gameId, opponent, yourColor, currentPlayer, board } = payload;

        currentGameId = gameId;
        currentOpponent = opponent;
        myColor = yourColor;

        console.log(`游戏开始! 对手: ${opponent.username}, 我的颜色: ${yourColor}`);

        // 显示游戏开始对话框
        showGameStartDialog(opponent, yourColor, currentPlayer);
      }

      // 显示游戏开始对话框
      function showGameStartDialog(opponent, yourColor, currentPlayer) {
        const matchStatus = document.getElementById("matchStatus");
        if (matchStatus) {
          const isMyTurn = currentPlayer === yourColor;
          matchStatus.innerHTML = `
            <div style="color: #4CAF50; font-size: 18px; margin-bottom: 20px;">
              🎉 ${t("match_found")}
            </div>
            <div style="color: white; margin-bottom: 20px;">
              ${t("opponent_label")}<strong>${opponent.username}</strong><br>
              ${t("your_color")}: ${yourColor === 'black' ? '⚫ ' + t("black_stone") : '⚪ ' + t("white_stone")}<br>
              ${isMyTurn ? '🎯 ' + t("your_turn") : '⏳ ' + t("opponent_turn")}
            </div>
            <div style="display: flex; flex-direction: row; gap: 10px; justify-content: center; align-items: center; width: 100%; flex-wrap: nowrap;">
              <button onclick="startRealOnlineGame()" style="background: #4CAF50; border: none; border-radius: 25px; padding: 10px 20px; color: white; font-size: 14px; cursor: pointer; flex: 1; min-width: 80px; max-width: 140px; transition: all 0.3s; white-space: nowrap;">
                ${t("start_game")}
              </button>
            </div>
          `;
        }
      }

      // 开始真实在线游戏
      function startRealOnlineGame() {
        if (!currentGameId || !currentOpponent) {
          showError(t("game_not_ready"));
          return;
        }

        // 显示在线游戏界面
        showOnlineGameScreen();
      }

      // 显示自定义确认对话框
      function showCustomConfirm(title, message, buttons) {
        return new Promise((resolve) => {
          const overlay = document.createElement('div');
          overlay.className = 'custom-confirm-overlay';

          const buttonsHtml = buttons.map((btn, index) =>
            `<button class="custom-confirm-btn ${btn.class || ''}" onclick="resolveConfirm(${index})">${btn.text}</button>`
          ).join('');

          overlay.innerHTML = `
            <div class="custom-confirm-dialog">
              <div class="custom-confirm-title">${title}</div>
              <div class="custom-confirm-message">${message}</div>
              <div class="custom-confirm-buttons">
                ${buttonsHtml}
              </div>
            </div>
          `;

          document.body.appendChild(overlay);

          // 存储resolve函数供按钮调用
          window.currentConfirmResolve = resolve;
          window.currentConfirmOverlay = overlay;
        });
      }

      // 处理确认对话框结果
      function resolveConfirm(buttonIndex) {
        if (window.currentConfirmResolve) {
          window.currentConfirmResolve(buttonIndex);
          document.body.removeChild(window.currentConfirmOverlay);
          window.currentConfirmResolve = null;
          window.currentConfirmOverlay = null;
        }
      }

      // 取消匹配
      async function cancelMatch() {
        const result = await showCustomConfirm(
          t("cancel_match_title"),
          t("cancel_match_confirm"),
          [
            { text: t("continue_match_option"), class: "primary" },
            { text: t("rematch_option"), class: "" },
            { text: t("return_main_option"), class: "danger" }
          ]
        );

        switch(result) {
          case 0: // 继续匹配
            // 什么都不做，保持当前状态
            break;
          case 1: // 重新匹配
            showOnlineMatchScreen();
            break;
          case 2: // 返回主界面
            showMainScreen();
            break;
        }
      }

      // 显示在线游戏界面
      function showOnlineGameScreen() {
        if (!currentOpponent || !myColor) {
          showError(t("game_not_ready"));
          return;
        }

        const root = document.getElementById("root");
        root.innerHTML = `
          <div style="height: 100vh; background: linear-gradient(135deg, var(--pi-primary) 0%, var(--pi-secondary) 100%); display: flex; flex-direction: column; align-items: center; padding: 2px; box-sizing: border-box; overflow: hidden;" class="game-container">
            <!-- 游戏头部 -->
            <header style="width: 100%; display: flex; justify-content: space-between; align-items: center; margin-bottom: 1px; padding: 0 10px;">
              <button onclick="surrenderOnlineGame()" class="btn btn-outline btn-sm" style="height: auto; min-height: auto; padding: 4px 8px; line-height: 1.2; font-size: 14px;">
                ${t("surrender")}
              </button>
              <div style="color: white; font-size: 14px; text-align: center;">
                🌐 ${t("online_match")}
              </div>
              <button onclick="showMainScreen()" class="btn btn-outline btn-sm" style="height: auto; min-height: auto; padding: 4px 8px; line-height: 1.2; font-size: 14px;">
                ${t("return_to_menu")}
              </button>
            </header>

            <!-- 玩家信息 -->
            <div style="text-align: center; margin-bottom: 0; color: white;">
              <div style="display: flex; justify-content: center; align-items: center; gap: clamp(10px, 3vw, 15px); margin-bottom: 0;">
                <div style="display: flex; align-items: center; gap: 6px; background: rgba(255,255,255,0.1); padding: 6px 12px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.3);">
                  <div class="stone ${myColor}" style="width: 20px; height: 20px; margin: 0;"></div>
                  <strong style="font-size: clamp(14px, 3vw, 16px);">${getCurrentDisplayUsername()}</strong>
                </div>
                <div style="color: white; font-size: clamp(16px, 3vw, 18px); font-weight: 600;">${t("vs_label")}</div>
                <div style="display: flex; align-items: center; gap: 6px; background: rgba(255,255,255,0.1); padding: 6px 12px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.3);">
                  <div class="stone ${myColor === 'black' ? 'white' : 'black'}" style="width: 20px; height: 20px; margin: 0;"></div>
                  <strong style="font-size: clamp(14px, 3vw, 16px);">${currentOpponent.username}</strong>
                </div>
              </div>
              <div style="font-size: clamp(16px, 3.5vw, 20px); font-weight: 600; margin-top: 2px; margin-bottom: 0;" id="online-current-player-display">
                ${t("waiting_for_game")}
              </div>
            </div>

            <!-- 棋盘容器 -->
            <div class="game-board" style="display: flex; align-items: flex-start; justify-content: center; margin: 0; padding-top: 2px;">
              <div class="board-container">
                <div class="board-grid responsive-board" id="online-game-board">
                  <!-- 15x15 棋盘格子将通过JavaScript生成 -->
                </div>
              </div>
            </div>
          </div>
        `;

        // 初始化在线游戏棋盘
        initOnlineGameBoard();
      }

      // 初始化在线游戏棋盘
      function initOnlineGameBoard() {
        const board = document.getElementById("online-game-board");
        board.innerHTML = "";

        // 设置响应式棋盘尺寸
        setupResponsiveBoard();

        // 创建15x15棋盘
        for (let row = 0; row < 15; row++) {
          for (let col = 0; col < 15; col++) {
            const cell = document.createElement("div");
            cell.className = "board-cell";
            cell.dataset.row = row;
            cell.dataset.col = col;
            cell.addEventListener("click", () => makeOnlineMove(row, col));
            board.appendChild(cell);
          }
        }

        // 初始化游戏状态
        onlineGameBoard = Array(15).fill().map(() => Array(15).fill(null));
        onlineCurrentPlayer = 'black'; // 黑子先手
        onlineGameActive = true;

        updateOnlineGameStatus();
        console.log('在线游戏棋盘初始化完成');
      }

      // 在线游戏相关变量
      let onlineGameBoard = Array(15).fill().map(() => Array(15).fill(null));
      let onlineCurrentPlayer = "black";
      let onlineGameActive = true;

      // 在线游戏移动处理
      function makeOnlineMove(row, col) {
        if (!onlineGameActive || !currentGameId) {
          return;
        }

        // 检查是否是我的回合
        if (onlineCurrentPlayer !== myColor) {
          showError(t("not_your_turn"));
          return;
        }

        // 检查位置是否有效
        if (onlineGameBoard[row][col] !== null) {
          return;
        }

        // 发送移动到服务器
        if (gameWebSocket && isConnectedToGameServer) {
          gameWebSocket.send(JSON.stringify({
            type: 'game_move',
            payload: {
              gameId: currentGameId,
              userId: currentUser.piUserId || currentUser.uid,
              row,
              col
            }
          }));
        }
      }

      // 处理对手移动
      function handleOpponentMove(payload) {
        const { row, col, color, currentPlayer, board } = payload;

        // 更新棋盘状态
        onlineGameBoard = board;
        onlineCurrentPlayer = currentPlayer;

        // 更新UI
        updateOnlineBoardDisplay();
        updateOnlineGameStatus();

        console.log(`对手移动: (${row}, ${col}), 当前玩家: ${currentPlayer}`);
      }

      // 更新在线游戏棋盘显示
      function updateOnlineBoardDisplay() {
        for (let row = 0; row < 15; row++) {
          for (let col = 0; col < 15; col++) {
            const cell = document.querySelector(`#online-game-board [data-row="${row}"][data-col="${col}"]`);
            if (cell) {
              cell.innerHTML = '';
              if (onlineGameBoard[row][col]) {
                const stone = document.createElement('div');
                stone.className = `stone ${onlineGameBoard[row][col]}`;
                cell.appendChild(stone);
              }
            }
          }
        }
      }

      // 更新在线游戏状态显示
      function updateOnlineGameStatus() {
        const statusDisplay = document.getElementById("online-current-player-display");
        if (statusDisplay) {
          const isMyTurn = onlineCurrentPlayer === myColor;
          if (isMyTurn) {
            statusDisplay.textContent = t("your_turn");
            statusDisplay.style.color = "#4CAF50";
          } else {
            statusDisplay.textContent = t("opponent_turn");
            statusDisplay.style.color = "#FFC107";
          }
        }
      }

      // 处理游戏结束
      function handleGameEnded(payload) {
        const { winner, surrendered, board, moves } = payload;

        onlineGameActive = false;
        onlineGameBoard = board;

        // 更新棋盘显示
        updateOnlineBoardDisplay();

        // 确定结果
        let resultMessage;
        if (surrendered) {
          if (winner === myColor) {
            resultMessage = t("opponent_surrendered");
          } else {
            resultMessage = t("you_surrendered");
          }
        } else {
          if (winner === myColor) {
            resultMessage = t("you_win");
          } else {
            resultMessage = t("you_lose");
          }
        }

        // 显示游戏结果
        setTimeout(() => {
          showCustomAlert(
            t("game_over"),
            resultMessage,
            () => {
              // 重置游戏状态
              currentGameId = null;
              currentOpponent = null;
              myColor = null;
              showMainScreen();
            }
          );
        }, 1000);

        console.log(`游戏结束: ${winner} 获胜, 投降: ${surrendered}`);
      }

      // 处理对手断开连接
      function handleOpponentDisconnected(payload) {
        onlineGameActive = false;

        showCustomAlert(
          t("game_over"),
          t("opponent_disconnected"),
          () => {
            currentGameId = null;
            currentOpponent = null;
            myColor = null;
            showMainScreen();
          }
        );
      }

      // 投降在线游戏
      function surrenderOnlineGame() {
        if (!currentGameId || !onlineGameActive) {
          return;
        }

        showCustomConfirm(
          t("surrender_confirm_title"),
          t("surrender_confirm_message"),
          () => {
            // 发送投降请求
            if (gameWebSocket && isConnectedToGameServer) {
              gameWebSocket.send(JSON.stringify({
                type: 'game_surrender',
                payload: {
                  gameId: currentGameId,
                  userId: currentUser.piUserId || currentUser.uid
                }
              }));
            }
          },
          () => {
            // 取消投降
          }
        );
      }

      // 开始在线游戏（旧版本，保持兼容性）
      async function startOnlineGame() {
        await showCustomConfirm(
          "🌐 " + t("online_match"),
          t("online_game_info"),
          [
            { text: "了解", class: "primary" },
            { text: "体验AI对战", class: "" }
          ]
        );
        showMainScreen();
      }

      // 显示AI对战游戏界面 - 响应式设计适配所有屏幕
      function showSimpleGameScreen() {
        const root = document.getElementById("root");
        root.innerHTML = `
                <div style="height: 100vh; background: linear-gradient(135deg, var(--pi-primary) 0%, var(--pi-secondary) 100%); display: flex; flex-direction: column; align-items: center; padding: 2px; box-sizing: border-box; overflow: hidden;" class="game-container">
                    <!-- 游戏头部 - 极度紧凑布局 -->
                    <header style="width: 100%; display: flex; justify-content: flex-start; align-items: center; margin-bottom: 1px;">
                        <button onclick="backToLogin()" class="btn btn-outline btn-sm" style="height: auto; min-height: auto; padding: 4px 8px; line-height: 1.2; font-size: 14px;">
                            ${t("return_to_menu")}
                        </button>
                    </header>

                    <!-- 游戏标题 - 极度紧凑 -->
                    <h1 style="color: white; margin: 0 0 1px 0; font-size: clamp(24px, 5vw, 30px); text-align: center;">${t(
                      "ai_battle_title"
                    )}</h1>

                    <!-- 玩家信息 - 极度紧凑布局 -->
                    <div style="text-align: center; margin-bottom: 0; color: white;">
                        <div style="display: flex; justify-content: center; align-items: center; gap: clamp(10px, 3vw, 15px); margin-bottom: 0;">
                            <div style="display: flex; align-items: center; gap: 6px; background: rgba(255,255,255,0.1); padding: 6px 12px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.3);">
                                <div class="stone black" style="width: 20px; height: 20px; margin: 0;"></div>
                                <strong style="font-size: clamp(16px, 3.5vw, 20px);">${t(
                                  "player_label"
                                )}</strong>
                            </div>
                            <div style="color: white; font-size: clamp(18px, 3.5vw, 22px); font-weight: 600;">${t(
                              "vs_label"
                            )}</div>
                            <div style="display: flex; align-items: center; gap: 6px; background: rgba(255,255,255,0.1); padding: 6px 12px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.3);">
                                <div class="stone white" style="width: 20px; height: 20px; margin: 0;"></div>
                                <strong style="font-size: clamp(16px, 3.5vw, 20px);">${t(
                                  "ai_label"
                                )}</strong>
                            </div>
                        </div>
                        <div style="font-size: clamp(16px, 3.5vw, 20px); font-weight: 600; margin-top: 2px; margin-bottom: 0;" id="current-player-display">
                            ${t("your_turn")}
                        </div>
                        <!-- 回合计时器 -->
                        <div style="font-size: clamp(14px, 3vw, 16px); margin-top: 4px; color: #ffffff;" id="turn-timer-display">
                            ${t("thinking_time", "60")}
                        </div>
                    </div>

                    <!-- 棋盘容器 - 极度紧凑间距 -->
                    <div class="game-board" style="display: flex; align-items: flex-start; justify-content: center; margin: 0; padding-top: 2px;">
                        <div class="board-container">
                            <div class="board-grid responsive-board" id="ai-game-board">
                                <!-- 15x15 棋盘格子将通过JavaScript生成 -->
                            </div>
                        </div>
                    </div>

                    <!-- 游戏控制按钮 - 固定在底部 -->
                    <div style="display: flex; justify-content: center; gap: 12px; margin-top: 8px;">
                        <button onclick="undoAIMove()" class="btn btn-warning btn-sm" id="undo-btn" style="min-width: 80px; padding: 8px 16px;">
                            ${t("undo_button")}
                        </button>
                        <button onclick="resetAIGame()" class="btn btn-primary btn-sm" style="min-width: 80px; padding: 8px 16px;">
                            ${t("new_game_button")}
                        </button>
                    </div>
                </div>
            `;

        // 初始化AI游戏
        initAIGame();
      }

      // AI游戏相关变量
      let aiGameBoard = Array(15)
        .fill()
        .map(() => Array(15).fill(null));
      let aiCurrentPlayer = "black"; // 玩家是黑子，AI是白子
      let aiGameHistory = [];
      let aiGameActive = true;

      // 回合超时相关变量
      let turnTimer = null;
      let turnTimeLeft = 0;
      let turnTimerDisplay = null;
      const TURN_TIME_LIMIT = 60; // 60秒回合时间限制
      const WARNING_TIME = 30; // 30秒开始警告

      // 音效管理器 - 使用您的自定义音效文件
      class SoundManager {
        constructor() {
          this.sounds = {};
          this.enabled = true;
          this.volume = 0.5; // 音量控制
          this.initSounds();
        }

        initSounds() {
          // 预加载您的音效文件，设置不同音效的音量
          const soundFiles = {
            gameStart: { src: "./public/sounds/game-start.mp3", volume: 0.5 },
            move: { src: "./public/sounds/move.mp3", volume: 0.8 }, // 提高落子音效音量
            victory: { src: "./public/sounds/victory.mp3", volume: 0.5 },
          };

          // 创建Audio对象并预加载
          for (const [key, config] of Object.entries(soundFiles)) {
            try {
              const audio = new Audio(config.src);
              audio.volume = config.volume;
              audio.preload = "auto";

              // 添加错误处理
              audio.addEventListener("error", (e) => {
                console.log(`音效文件加载失败: ${config.src}`, e);
              });

              // 添加加载成功事件
              audio.addEventListener("canplaythrough", () => {
                console.log(`音效文件加载成功: ${config.src}`);
              });

              this.sounds[key] = audio;
            } catch (e) {
              console.log(`音效初始化失败: ${key}`, e);
            }
          }
        }

        // 播放音效的通用方法
        playSound(soundName) {
          if (!this.enabled || !this.sounds[soundName]) {
            return;
          }

          try {
            const audio = this.sounds[soundName];
            // 重置播放位置
            audio.currentTime = 0;
            // 播放音效
            const playPromise = audio.play();

            // 处理播放Promise（现代浏览器要求）
            if (playPromise !== undefined) {
              playPromise.catch((error) => {
                console.log(`音效播放失败: ${soundName}`, error);
              });
            }
          } catch (e) {
            console.log(`音效播放错误: ${soundName}`, e);
          }
        }

        playMove() {
          this.playSound("move");
        }

        playVictory() {
          this.playSound("victory");
        }

        playGameStart() {
          this.playSound("gameStart");
        }

        // 设置音量
        setVolume(volume) {
          this.volume = Math.max(0, Math.min(1, volume));
          // 保持不同音效的相对音量比例
          const volumeRatios = {
            gameStart: 0.5,
            move: 0.8,
            victory: 0.5
          };

          for (const [key, audio] of Object.entries(this.sounds)) {
            const ratio = volumeRatios[key] || 0.5;
            audio.volume = this.volume * ratio;
          }
        }

        // 启用/禁用音效
        toggle() {
          this.enabled = !this.enabled;
          return this.enabled;
        }
      }

      // 创建音效管理器实例
      let soundManager = new SoundManager();

      // 自定义弹窗函数
      function showCustomAlert(title, message, callback) {
        const modal = document.createElement("div");
        modal.className = "custom-modal";
        modal.innerHTML = `
                <div class="custom-modal-content">
                    <div class="custom-modal-title">${title}</div>
                    <div class="custom-modal-message">${message}</div>
                    <div class="custom-modal-buttons">
                        <button class="custom-modal-btn primary" onclick="closeCustomModal()">${t(
                          "confirm"
                        )}</button>
                    </div>
                </div>
            `;
        document.body.appendChild(modal);

        // 保存回调函数
        window.customModalCallback = callback;
      }

      function showCustomConfirm(title, message, onConfirm, onCancel) {
        const modal = document.createElement("div");
        modal.className = "custom-modal";
        modal.innerHTML = `
                <div class="custom-modal-content">
                    <div class="custom-modal-title">${title}</div>
                    <div class="custom-modal-message">${message}</div>
                    <div class="custom-modal-buttons">
                        <button class="custom-modal-btn primary" onclick="confirmCustomModal()">${t(
                          "confirm"
                        )}</button>
                        <button class="custom-modal-btn secondary" onclick="cancelCustomModal()">${t(
                          "cancel"
                        )}</button>
                    </div>
                </div>
            `;
        document.body.appendChild(modal);

        // 保存回调函数
        window.customModalConfirm = onConfirm;
        window.customModalCancel = onCancel;
      }

      function closeCustomModal() {
        const modal = document.querySelector(".custom-modal");
        if (modal) {
          modal.remove();
          if (window.customModalCallback) {
            window.customModalCallback();
            window.customModalCallback = null;
          }
        }
      }

      function confirmCustomModal() {
        const modal = document.querySelector(".custom-modal");
        if (modal) {
          modal.remove();
          if (window.customModalConfirm) {
            window.customModalConfirm();
            window.customModalConfirm = null;
            window.customModalCancel = null;
          }
        }
      }

      function cancelCustomModal() {
        const modal = document.querySelector(".custom-modal");
        if (modal) {
          modal.remove();
          if (window.customModalCancel) {
            window.customModalCancel();
          }
          window.customModalConfirm = null;
          window.customModalCancel = null;
        }
      }

      // 初始化AI游戏
      function initAIGame() {
        const board = document.getElementById("ai-game-board");
        board.innerHTML = "";

        // 设置响应式棋盘尺寸
        setupResponsiveBoard();

        // 创建15x15棋盘
        for (let row = 0; row < 15; row++) {
          for (let col = 0; col < 15; col++) {
            const cell = document.createElement("div");
            cell.className = "board-cell";
            cell.dataset.row = row;
            cell.dataset.col = col;
            cell.addEventListener("click", () => makeAIMove(row, col));
            board.appendChild(cell);
          }
        }

        // 重置游戏状态
        aiGameBoard = Array(15)
          .fill()
          .map(() => Array(15).fill(null));
        aiCurrentPlayer = "black";
        aiGameHistory = [];
        aiGameActive = true;
        window.gameStartTime = Date.now(); // 记录游戏开始时间

        // 清除之前的计时器
        stopTurnTimer();

        updateAIGameStatus();

        // 播放游戏开始音效
        setTimeout(() => {
          soundManager.playGameStart();
        }, 300);

        // 手机端清除阴影
        setTimeout(() => {
          clearAllStoneShadows();
        }, 100);
      }

      // 设置响应式棋盘尺寸
      function setupResponsiveBoard() {
        const board = document.getElementById("ai-game-board");
        if (!board) return;

        // 根据屏幕尺寸动态计算棋盘大小
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;

        // 计算可用高度：总高度减去头部、标题、玩家信息、按钮等区域
        // 预留空间：返回按钮(40px) + 标题(35px) + 玩家信息(80px) + 按钮区域(60px) + 边距(20px)
        const reservedHeight = 235;
        const availableHeight = screenHeight - reservedHeight;
        const availableWidth = screenWidth - 16; // 减去左右边距

        let cellSize;
        if (screenWidth >= 1200) {
          cellSize = 28;
        } else if (screenWidth >= 992) {
          cellSize = 26;
        } else if (screenWidth >= 768) {
          cellSize = 24;
        } else if (screenWidth >= 576) {
          cellSize = 22;
        } else {
          // 手机端：充分利用屏幕宽度
          // 减去边框和内边距，计算最大可用宽度
          const availableWidth = screenWidth - 16; // 8px padding * 2
          const maxCellSize = Math.floor(availableWidth / 15);
          cellSize = Math.max(20, Math.min(24, maxCellSize)); // 最小20px，最大24px
        }

        // 桌面端确保棋盘不会超出屏幕高度，但优先保持宽度
        if (screenWidth >= 768) {
          const maxBoardSizeByHeight = Math.floor(availableHeight / 15);
          if (maxBoardSizeByHeight < cellSize) {
            cellSize = Math.max(20, maxBoardSizeByHeight); // 最小保持20px
          }
        }

        // 只有当尺寸真正改变时才更新CSS变量，避免不必要的重新渲染
        const currentCellSize = getComputedStyle(
          document.documentElement
        ).getPropertyValue("--cell-size");
        const newCellSizeValue = cellSize + "px";

        if (currentCellSize !== newCellSizeValue) {
          // 设置CSS变量 - 棋子尺寸适中，留出合理空隙
          const stoneSize = Math.max(14, cellSize - 4); // 棋子比格子小4px，保持合理空隙
          document.documentElement.style.setProperty(
            "--cell-size",
            newCellSizeValue
          );
          document.documentElement.style.setProperty(
            "--stone-size",
            stoneSize + "px"
          );
        }
      }

      // 防抖函数
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // 监听窗口大小变化（使用防抖避免频繁调用）
      window.addEventListener(
        "resize",
        debounce(() => {
          if (document.getElementById("ai-game-board")) {
            setupResponsiveBoard();
          }
        }, 250)
      );

      // 玩家下棋
      function makeAIMove(row, col) {
        if (
          !aiGameActive ||
          aiGameBoard[row][col] !== null ||
          aiCurrentPlayer !== "black"
        ) {
          return;
        }

        // 停止玩家回合计时器
        stopTurnTimer();

        // 玩家下黑子
        placeAIStone(row, col, "black");
        aiGameBoard[row][col] = "black";
        aiGameHistory.push({ row, col, player: "black" });

        // 播放落子音效
        soundManager.playMove();

        // 检查玩家是否获胜
        if (checkAIWin(row, col, "black")) {
          endAIGame("black");
          return;
        }

        // 检查是否平局
        if (isAIBoardFull()) {
          endAIGame(null);
          return;
        }

        // 切换到AI
        aiCurrentPlayer = "white";
        updateAIGameStatus();

        // AI思考时间显示
        const currentPlayerDisplay = document.getElementById(
          "current-player-display"
        );
        if (currentPlayerDisplay) {
          currentPlayerDisplay.textContent = t("opponent_turn");
        }

        // AI延迟下棋（给用户一些反应时间）
        setTimeout(() => {
          makeAIAutoMove();
        }, 800);
      }

      // AI自动下棋
      function makeAIAutoMove() {
        if (!aiGameActive || aiCurrentPlayer !== "white") return;

        const aiMove = getAIBestMove();
        if (aiMove) {
          placeAIStone(aiMove.row, aiMove.col, "white");
          aiGameBoard[aiMove.row][aiMove.col] = "white";
          aiGameHistory.push({
            row: aiMove.row,
            col: aiMove.col,
            player: "white",
          });

          // 播放落子音效
          soundManager.playMove();

          // 检查AI是否获胜
          if (checkAIWin(aiMove.row, aiMove.col, "white")) {
            endAIGame("white");
            return;
          }

          // 检查是否平局
          if (isAIBoardFull()) {
            endAIGame(null);
            return;
          }

          // 切换回玩家
          aiCurrentPlayer = "black";
          updateAIGameStatus();
        }
      }

      // 强制清除棋子阴影的函数 - 手机端专用
      function clearStoneShadows(stone) {
        if (stone) {
          stone.style.boxShadow = "none";
          stone.style.filter = "none";
          stone.style.webkitFilter = "none";
          stone.style.textShadow = "none";
          stone.style.webkitBoxShadow = "none";
          stone.style.mozBoxShadow = "none";

          // 强制重绘
          stone.offsetHeight;
        }
      }

      // 全局清除所有棋子阴影 - 手机端专用
      function clearAllStoneShadows() {
        if (window.innerWidth <= 768) {
          const allStones = document.querySelectorAll(".stone");
          allStones.forEach((stone) => {
            clearStoneShadows(stone);
          });

          // 也清除棋盘格子的阴影
          const allCells = document.querySelectorAll(".board-cell");
          allCells.forEach((cell) => {
            cell.style.boxShadow = "none";
            cell.style.filter = "none";
            cell.style.webkitFilter = "none";
            cell.style.webkitBoxShadow = "none";
            cell.style.mozBoxShadow = "none";
          });
        }
      }

      // 在棋盘上放置棋子
      function placeAIStone(row, col, player) {
        // 移除所有之前的最新落子标识（确保彻底清除）
        const allPreviousLatest = document.querySelectorAll(
          "#ai-game-board .stone.latest"
        );
        allPreviousLatest.forEach((stone) => {
          stone.classList.remove("latest");
          // 手机端强制清除阴影
          if (window.innerWidth <= 768) {
            clearStoneShadows(stone);
          }
        });

        const cell = document.querySelector(
          `#ai-game-board [data-row="${row}"][data-col="${col}"]`
        );

        // 给格子添加occupied类，防止hover效果
        cell.classList.add("occupied");

        const stone = document.createElement("div");
        stone.className = `stone ${player} latest`;
        cell.appendChild(stone);

        // 手机端强制清除新棋子的阴影
        if (window.innerWidth <= 768) {
          setTimeout(() => {
            clearStoneShadows(stone);
          }, 0);

          // 动画结束后再次清除
          setTimeout(() => {
            clearStoneShadows(stone);
          }, 300);
        }
      }

      // AI配置
      const AI_CONFIG = {
        MAX_DEPTH: 6, // 搜索深度
        MAX_TIME: 3000, // 最大思考时间(毫秒)
        CANDIDATE_LIMIT: 20, // 候选位置数量限制
      };

      // 评估分数常量
      const SCORES = {
        WIN: 100000,
        LOSE: -100000,
        ALIVE_FOUR: 10000,
        RUSH_FOUR: 1000,
        ALIVE_THREE: 1000,
        SLEEP_THREE: 100,
        ALIVE_TWO: 100,
        SLEEP_TWO: 10,
        ONE: 1,
      };

      // 强化AI算法 - 使用Minimax + Alpha-Beta剪枝
      function getAIBestMove() {
        const startTime = Date.now();

        // 首先检查是否有立即获胜的机会
        const winMove = findWinningMove("white");
        if (winMove) return winMove;

        // 检查是否需要立即防守
        const blockMove = findWinningMove("black");
        if (blockMove) return blockMove;

        // 获取候选位置
        const candidates = getCandidateMoves();
        if (candidates.length === 0) {
          return { row: 7, col: 7 }; // 中心位置
        }

        let bestMove = candidates[0];
        let bestScore = -Infinity;

        // 使用Minimax算法搜索最佳位置
        for (const move of candidates) {
          // 时间限制检查
          if (Date.now() - startTime > AI_CONFIG.MAX_TIME) break;

          aiGameBoard[move.row][move.col] = "white";
          const score = minimax(
            AI_CONFIG.MAX_DEPTH - 1,
            false,
            -Infinity,
            Infinity,
            startTime
          );
          aiGameBoard[move.row][move.col] = null;

          if (score > bestScore) {
            bestScore = score;
            bestMove = move;
          }
        }

        return bestMove;
      }

      // Minimax算法实现
      function minimax(depth, isMaximizing, alpha, beta, startTime) {
        // 时间限制检查
        if (Date.now() - startTime > AI_CONFIG.MAX_TIME) {
          return evaluateBoard();
        }

        // 深度限制或游戏结束
        if (depth === 0) {
          return evaluateBoard();
        }

        // 检查游戏是否结束
        const gameResult = checkGameEnd();
        if (gameResult !== null) {
          if (gameResult === "white") return SCORES.WIN;
          if (gameResult === "black") return SCORES.LOSE;
          return 0; // 平局
        }

        const candidates = getCandidateMoves();
        if (candidates.length === 0) return evaluateBoard();

        if (isMaximizing) {
          let maxScore = -Infinity;
          for (const move of candidates) {
            aiGameBoard[move.row][move.col] = "white";
            const score = minimax(depth - 1, false, alpha, beta, startTime);
            aiGameBoard[move.row][move.col] = null;

            maxScore = Math.max(maxScore, score);
            alpha = Math.max(alpha, score);
            if (beta <= alpha) break; // Alpha-Beta剪枝
          }
          return maxScore;
        } else {
          let minScore = Infinity;
          for (const move of candidates) {
            aiGameBoard[move.row][move.col] = "black";
            const score = minimax(depth - 1, true, alpha, beta, startTime);
            aiGameBoard[move.row][move.col] = null;

            minScore = Math.min(minScore, score);
            beta = Math.min(beta, score);
            if (beta <= alpha) break; // Alpha-Beta剪枝
          }
          return minScore;
        }
      }

      // 寻找获胜位置
      function findWinningMove(player) {
        for (let row = 0; row < 15; row++) {
          for (let col = 0; col < 15; col++) {
            if (aiGameBoard[row][col] === null) {
              aiGameBoard[row][col] = player;
              if (checkAIWinOnBoard(aiGameBoard, row, col, player)) {
                aiGameBoard[row][col] = null;
                return { row, col };
              }
              aiGameBoard[row][col] = null;
            }
          }
        }
        return null;
      }

      // 获取候选位置（只搜索有意义的位置）
      function getCandidateMoves() {
        const candidates = [];
        const visited = new Set();

        // 如果棋盘为空，返回中心位置
        if (aiGameHistory.length === 0) {
          return [{ row: 7, col: 7 }];
        }

        // 在已有棋子周围2格范围内寻找候选位置
        for (let row = 0; row < 15; row++) {
          for (let col = 0; col < 15; col++) {
            if (aiGameBoard[row][col] !== null) {
              // 在该棋子周围2格范围内添加候选位置
              for (let dr = -2; dr <= 2; dr++) {
                for (let dc = -2; dc <= 2; dc++) {
                  const newRow = row + dr;
                  const newCol = col + dc;
                  const key = `${newRow},${newCol}`;

                  if (
                    newRow >= 0 &&
                    newRow < 15 &&
                    newCol >= 0 &&
                    newCol < 15 &&
                    aiGameBoard[newRow][newCol] === null &&
                    !visited.has(key)
                  ) {
                    visited.add(key);
                    candidates.push({
                      row: newRow,
                      col: newCol,
                      score: evaluatePosition(newRow, newCol),
                    });
                  }
                }
              }
            }
          }
        }

        // 按评估分数排序，取前N个候选位置
        candidates.sort((a, b) => b.score - a.score);
        return candidates.slice(0, AI_CONFIG.CANDIDATE_LIMIT);
      }

      // 检查游戏是否结束
      function checkGameEnd() {
        // 检查是否有玩家获胜
        for (let row = 0; row < 15; row++) {
          for (let col = 0; col < 15; col++) {
            if (aiGameBoard[row][col] !== null) {
              if (
                checkAIWinOnBoard(aiGameBoard, row, col, aiGameBoard[row][col])
              ) {
                return aiGameBoard[row][col];
              }
            }
          }
        }

        // 检查是否平局
        if (isAIBoardFull()) {
          return "draw";
        }

        return null;
      }

      // 检查是否获胜（在指定棋盘上）
      function checkAIWinOnBoard(board, row, col, player) {
        const directions = [
          [0, 1],
          [1, 0],
          [1, 1],
          [1, -1],
        ];

        for (let [dx, dy] of directions) {
          let count = 1;

          // 正方向
          for (let i = 1; i < 5; i++) {
            const newRow = row + dx * i;
            const newCol = col + dy * i;
            if (newRow < 0 || newRow >= 15 || newCol < 0 || newCol >= 15) break;
            if (board[newRow][newCol] !== player) break;
            count++;
          }

          // 反方向
          for (let i = 1; i < 5; i++) {
            const newRow = row - dx * i;
            const newCol = col - dy * i;
            if (newRow < 0 || newRow >= 15 || newCol < 0 || newCol >= 15) break;
            if (board[newRow][newCol] !== player) break;
            count++;
          }

          if (count >= 5) return true;
        }

        return false;
      }

      // 检查是否获胜（在主棋盘上）
      function checkAIWin(row, col, player) {
        return checkAIWinOnBoard(aiGameBoard, row, col, player);
      }

      // 智能评估函数
      function evaluateBoard() {
        let score = 0;

        // 评估所有方向的连子情况
        for (let row = 0; row < 15; row++) {
          for (let col = 0; col < 15; col++) {
            if (aiGameBoard[row][col] !== null) {
              score += evaluatePositionForPlayer(
                row,
                col,
                aiGameBoard[row][col]
              );
            }
          }
        }

        return score;
      }

      // 评估单个位置的价值
      function evaluatePosition(row, col) {
        let score = 0;

        // 模拟放置白子和黑子，计算价值
        aiGameBoard[row][col] = "white";
        score += evaluatePositionForPlayer(row, col, "white");
        aiGameBoard[row][col] = "black";
        score -= evaluatePositionForPlayer(row, col, "black") * 1.1; // 防守稍微重要一些
        aiGameBoard[row][col] = null;

        // 中心位置加分
        const centerDistance = Math.abs(row - 7) + Math.abs(col - 7);
        score += (14 - centerDistance) * 2;

        return score;
      }

      // 评估特定玩家在特定位置的价值
      function evaluatePositionForPlayer(row, col, player) {
        let score = 0;
        const directions = [
          [0, 1],
          [1, 0],
          [1, 1],
          [1, -1],
        ];

        for (const [dx, dy] of directions) {
          const pattern = getLinePattern(row, col, dx, dy, player);
          score += evaluatePattern(pattern, player);
        }

        return score;
      }

      // 获取某个方向的连子模式
      function getLinePattern(row, col, dx, dy, player) {
        let pattern = [];

        // 向负方向扫描4格
        for (let i = -4; i <= 4; i++) {
          const newRow = row + dx * i;
          const newCol = col + dy * i;

          if (newRow < 0 || newRow >= 15 || newCol < 0 || newCol >= 15) {
            pattern.push("X"); // 边界
          } else if (aiGameBoard[newRow][newCol] === player) {
            pattern.push("O"); // 己方棋子
          } else if (aiGameBoard[newRow][newCol] === null) {
            pattern.push("."); // 空位
          } else {
            pattern.push("X"); // 对方棋子或边界
          }
        }

        return pattern.join("");
      }

      // 评估连子模式
      function evaluatePattern(pattern, player) {
        const multiplier = player === "white" ? 1 : -1;

        // 五连
        if (pattern.includes("OOOOO")) {
          return SCORES.WIN * multiplier;
        }

        // 活四 (.OOOO.)
        if (pattern.includes(".OOOO.")) {
          return SCORES.ALIVE_FOUR * multiplier;
        }

        // 冲四 (XOOOO. 或 .OOOOX)
        if (pattern.includes("XOOOO.") || pattern.includes(".OOOOX")) {
          return SCORES.RUSH_FOUR * multiplier;
        }

        // 活三 (.OOO. 且两边都有空位延伸)
        if (pattern.includes(".OOO.")) {
          return SCORES.ALIVE_THREE * multiplier;
        }

        // 眠三 (XOOO. 或 .OOOX)
        if (pattern.includes("XOOO.") || pattern.includes(".OOOX")) {
          return SCORES.SLEEP_THREE * multiplier;
        }

        // 活二 (.OO. 且两边都有空位延伸)
        if (pattern.includes(".OO.")) {
          return SCORES.ALIVE_TWO * multiplier;
        }

        // 眠二 (XOO. 或 .OOX)
        if (pattern.includes("XOO.") || pattern.includes(".OOX")) {
          return SCORES.SLEEP_TWO * multiplier;
        }

        // 单子
        if (pattern.includes("O")) {
          return SCORES.ONE * multiplier;
        }

        return 0;
      }

      // 检查棋盘是否已满
      function isAIBoardFull() {
        for (let row = 0; row < 15; row++) {
          for (let col = 0; col < 15; col++) {
            if (aiGameBoard[row][col] === null) {
              return false;
            }
          }
        }
        return true;
      }

      // 更新游戏状态显示
      function updateAIGameStatus() {
        const currentPlayerDisplay = document.getElementById(
          "current-player-display"
        );

        if (currentPlayerDisplay) {
          if (aiCurrentPlayer === "black") {
            currentPlayerDisplay.textContent = t("your_turn");
            startTurnTimer(); // 开始玩家回合计时
          } else {
            currentPlayerDisplay.textContent = t("opponent_turn");
            stopTurnTimer(); // 停止计时器（AI回合）
          }
        }
      }

      // 开始回合计时器
      function startTurnTimer() {
        // 清除之前的计时器
        stopTurnTimer();

        // 只在玩家回合启动计时器
        if (aiCurrentPlayer !== "black" || !aiGameActive) return;

        turnTimeLeft = TURN_TIME_LIMIT;
        updateTimerDisplay();

        turnTimer = setInterval(() => {
          turnTimeLeft--;
          updateTimerDisplay();

          // 时间到，玩家超时
          if (turnTimeLeft <= 0) {
            handlePlayerTimeout();
          }
        }, 1000);
      }

      // 停止回合计时器
      function stopTurnTimer() {
        if (turnTimer) {
          clearInterval(turnTimer);
          turnTimer = null;
        }
        // 显示AI回合状态，保持布局稳定
        const timerDisplay = document.getElementById("turn-timer-display");
        if (timerDisplay) {
          timerDisplay.style.display = "block";
          timerDisplay.style.color = "#ffffff";
          timerDisplay.style.opacity = "1";
          timerDisplay.innerHTML = t("ai_thinking");
        }
      }

      // 更新计时器显示
      function updateTimerDisplay() {
        const timerDisplay = document.getElementById("turn-timer-display");
        if (!timerDisplay) return;

        timerDisplay.style.display = "block";

        // 根据剩余时间改变显示样式
        if (turnTimeLeft > WARNING_TIME) {
          // 正常时间：白色
          timerDisplay.style.color = "#ffffff";
          timerDisplay.innerHTML = t("thinking_time", turnTimeLeft);
        } else if (turnTimeLeft > 10) {
          // 警告时间：黄色
          timerDisplay.style.color = "#ffc107";
          timerDisplay.innerHTML = t("remaining_time", turnTimeLeft);
        } else {
          // 紧急时间：红色闪烁
          timerDisplay.style.color = "#dc3545";
          timerDisplay.innerHTML = t("timeout_warning", turnTimeLeft);

          // 最后10秒闪烁效果
          if (turnTimeLeft % 2 === 0) {
            timerDisplay.style.opacity = "0.5";
          } else {
            timerDisplay.style.opacity = "1";
          }
        }
      }

      // 处理玩家超时
      function handlePlayerTimeout() {
        if (turnTimer) {
          clearInterval(turnTimer);
          turnTimer = null;
        }

        if (!aiGameActive) return;

        // 结束游戏，记录为失败
        aiGameActive = false;

        // 检查用户是否还在游戏界面
        const isInGameScreen =
          document.getElementById("current-player-display") !== null;

        if (isInGameScreen) {
          // 用户还在游戏界面，显示超时信息
          const currentPlayerDisplay = document.getElementById(
            "current-player-display"
          );
          if (currentPlayerDisplay) {
            currentPlayerDisplay.textContent = t("timeout");
          }

          // 显示超时信息
          const timerDisplay = document.getElementById("turn-timer-display");
          if (timerDisplay) {
            timerDisplay.style.display = "block";
            timerDisplay.style.color = "#dc3545";
            timerDisplay.style.opacity = "1";
            timerDisplay.innerHTML = t("timeout");
          }
        }

        // 记录超时失败
        const gameData = {
          totalMoves: aiGameHistory.length,
          gameMode: "ai",
          difficulty: 7,
          duration: Date.now() - (window.gameStartTime || Date.now()),
          timeoutReason: "player_timeout", // 玩家超时
        };

        // 延迟一下显示结果，让用户看到超时提示
        setTimeout(() => {
          // 重新检查用户是否还在游戏界面（因为可能在1.5秒内离开了）
          const stillInGameScreen =
            document.getElementById("current-player-display") !== null;

          if (currentUser && userStats) {
            if (stillInGameScreen) {
              // 用户在游戏界面，显示正常的游戏结果弹窗
              recordGameResult("loss", gameData);
            } else {
              // 用户已离开游戏界面，静默记录不显示弹窗
              recordGameResultSilent("loss", gameData);
            }
          } else {
            // 未登录用户，只在游戏界面显示提示
            if (stillInGameScreen) {
              showCustomAlert(t("game_over"), t("timeout_game_over"));
            }
          }
        }, 1500);
      }

      // 结束游戏
      function endAIGame(winner) {
        aiGameActive = false;

        // 停止计时器
        if (turnTimer) {
          clearInterval(turnTimer);
          turnTimer = null;
        }

        const currentPlayerDisplay = document.getElementById(
          "current-player-display"
        );

        // 显示游戏结束状态
        const timerDisplay = document.getElementById("turn-timer-display");
        if (timerDisplay) {
          timerDisplay.style.display = "block";
          timerDisplay.style.opacity = "1";
          if (winner === "black") {
            timerDisplay.style.color = "#28a745";
            timerDisplay.innerHTML = t("you_win");
          } else if (winner === "white") {
            timerDisplay.style.color = "#dc3545";
            timerDisplay.innerHTML = t("you_lose");
          } else {
            timerDisplay.style.color = "#ffc107";
            timerDisplay.innerHTML = t("draw");
          }
        }

        // 播放胜利音效
        setTimeout(() => {
          soundManager.playVictory();
        }, 200);

        // 记录游戏结果到后端
        let gameResult;
        if (winner === "black") {
          gameResult = "win";
          currentPlayerDisplay.textContent = t("you_win");
        } else if (winner === "white") {
          gameResult = "loss";
          currentPlayerDisplay.textContent = t("you_lose");
        } else {
          gameResult = "draw";
          currentPlayerDisplay.textContent = t("draw");
        }

        // 记录游戏数据
        const gameData = {
          totalMoves: aiGameHistory.length,
          gameMode: "ai",
          difficulty: 7,
          duration: Date.now() - (window.gameStartTime || Date.now()),
        };

        // 如果用户已登录，记录游戏结果
        if (currentUser && userStats) {
          recordGameResult(gameResult, gameData);
        } else {
          // 如果用户已登录但userStats为空，尝试初始化
          if (currentUser && !userStats) {
            initializeUserStatsFromLocal();
            // 重新检查并记录
            if (userStats) {
              recordGameResult(gameResult, gameData);
              return;
            }
          }

          // 未登录用户或初始化失败，显示简单结果
          setTimeout(() => {
            const resultText = {
              win: t("you_win"),
              loss: t("you_lose"),
              draw: t("draw"),
            };
            showCustomAlert(t("game_over"), resultText[gameResult]);
          }, 500);
        }
      }

      // 悔棋功能 - 临时移除扣币逻辑
      async function undoAIMove() {
        if (aiGameHistory.length < 2 || !aiGameActive) {
          return;
        }

        // 由于后端服务暂未部署，直接执行悔棋
        performUndo();
      }

      // 执行悔棋操作
      function performUndo() {
        // 悔棋两步（玩家和AI的棋子）
        for (let i = 0; i < 2 && aiGameHistory.length > 0; i++) {
          const lastMove = aiGameHistory.pop();
          aiGameBoard[lastMove.row][lastMove.col] = null;

          // 移除UI中的棋子
          const cell = document.querySelector(
            `#ai-game-board [data-row="${lastMove.row}"][data-col="${lastMove.col}"]`
          );
          const stone = cell.querySelector(".stone");
          if (stone) {
            stone.remove();
          }
          // 移除occupied类，恢复hover效果
          cell.classList.remove("occupied");
        }

        // 清除所有latest标记
        const allLatestStones = document.querySelectorAll(
          "#ai-game-board .stone.latest"
        );
        allLatestStones.forEach((stone) => stone.classList.remove("latest"));

        // 如果还有棋子，将最后一个棋子标记为latest
        if (aiGameHistory.length > 0) {
          const lastMove = aiGameHistory[aiGameHistory.length - 1];
          const lastCell = document.querySelector(
            `#ai-game-board [data-row="${lastMove.row}"][data-col="${lastMove.col}"]`
          );
          const lastStone = lastCell.querySelector(".stone");
          if (lastStone) {
            lastStone.classList.add("latest");
          }
        }

        // 重置为玩家回合
        aiCurrentPlayer = "black";
        aiGameActive = true;
        updateAIGameStatus();
      }

      // 重新开始游戏
      async function resetAIGame() {
        // 检查当前游戏是否正在进行中
        const isGameInProgress = aiGameActive && aiGameHistory.length > 0;

        if (isGameInProgress) {
          // 游戏进行中，需要支付费用
          if (currentUser && userStats) {
            // 登录用户必须支付
            try {
              // 先检查余额
              const balanceResponse = await fetch(
                `${API_BASE_URL}/api/payment/balance?userId=${currentUser.uid}`
              );
              const balanceData = await balanceResponse.json();

              if (balanceData.success && balanceData.balance.current >= 0.1) {
                // 余额充足，显示确认对话框
                showCustomConfirm(
                  t("restart_game"),
                  t("abandon_game_warning"),
                  async () => {
                    // 确认重新开始，扣费并执行
                    const consumeResponse = await fetch(
                      `${API_BASE_URL}/api/payment/consume`,
                      {
                        method: "POST",
                        headers: {
                          "Content-Type": "application/json",
                        },
                        body: JSON.stringify({
                          userId: currentUser.uid,
                          amount: 0.1,
                          purpose: "newgame",
                          gameData: {
                            moveCount: aiGameHistory.length,
                            gameMode: "ai",
                            reason: "restart_in_progress",
                          },
                        }),
                      }
                    );

                    const consumeData = await consumeResponse.json();
                    if (consumeData.success) {
                      // 扣费成功，记录失败并开始新游戏
                      recordGameAbandon();
                      initAIGame();
                      showCustomAlert(
                        t("success"),
                        t(
                          "undo_success_detail",
                          consumeData.newBalance.toFixed(2)
                        )
                      );
                    } else {
                      showCustomAlert(
                        t("error_title"),
                        consumeData.message || t("undo_failed_message")
                      );
                    }
                  },
                  () => {
                    // 取消操作
                  }
                );
              } else {
                // 余额不足，提示用户选择是否充值
                const currentBalance = balanceData.success
                  ? balanceData.balance.current.toFixed(2)
                  : "0.00";
                showCustomConfirm(
                  t("insufficient_balance_title"),
                  t("insufficient_balance_undo", currentBalance),
                  () => {
                    // 用户选择充值
                    showRechargeDialog(t("recharge_prompt"));
                  },
                  () => {
                    // 用户选择不充值，继续游戏但不能重新开始
                    showCustomAlert(t("hint"), t("continue_game_tip"));
                  }
                );
              }
            } catch (error) {
              console.error("新游戏支付检查失败:", error);
              showCustomAlert(t("error_title"), t("network_error_retry"));
            }
          } else {
            // 未登录用户，免费重新开始（但不参与排行榜）
            showCustomConfirm(
              t("abandon_current_game"),
              t("abandon_game_warning"),
              () => {
                recordGameAbandon();
                initAIGame();
              },
              () => {
                // 取消时不做任何操作
              }
            );
          }
        } else {
          // 游戏未开始或已结束，直接重新开始
          showCustomConfirm(
            t("restart_game"),
            t("restart_game_confirm"),
            () => {
              initAIGame();
            },
            () => {
              // 取消时不做任何操作
            }
          );
        }
      }

      // 记录游戏放弃
      function recordGameAbandon() {
        if (!currentUser || !userStats) return;

        // 记录游戏数据
        const gameData = {
          totalMoves: aiGameHistory.length,
          gameMode: "ai",
          difficulty: 7,
          duration: Date.now() - (window.gameStartTime || Date.now()),
          abandonReason: "player_restart", // 玩家主动重新开始
        };

        // 记录为失败
        recordGameResult("loss", gameData);
      }

      // 返回登录界面
      function backToLogin() {
        // 检查当前游戏是否正在进行中
        const isGameInProgress = aiGameActive && aiGameHistory.length > 0;

        if (isGameInProgress) {
          // 游戏进行中，询问是否放弃当前游戏
          showCustomConfirm(
            t("abandon_current_game"),
            t("abandon_game_return_warning"),
            () => {
              // 记录当前游戏为失败（放弃）
              recordGameAbandonAndReturn();
            },
            () => {
              // 取消时不做任何操作
            }
          );
          return;
        }

        // 游戏未开始或已结束，直接返回
        performBackToLogin();
      }

      // 记录游戏放弃并返回
      function recordGameAbandonAndReturn() {
        if (
          currentUser &&
          userStats &&
          aiGameActive &&
          aiGameHistory.length > 0
        ) {
          // 记录游戏数据
          const gameData = {
            totalMoves: aiGameHistory.length,
            gameMode: "ai",
            difficulty: 7,
            duration: Date.now() - (window.gameStartTime || Date.now()),
            abandonReason: "player_exit", // 玩家主动退出
          };

          // 记录为失败（不显示结果弹窗）
          recordGameResultSilent("loss", gameData);
        }

        // 返回主界面
        performBackToLogin();
      }

      // 静默记录游戏结果（不显示弹窗）
      async function recordGameResultSilent(result, gameData = {}) {
        if (!currentUser || !userStats) return;

        // 先更新本地数据
        updateLocalGameStats(result);

        try {
          // 确保使用与个人中心一致的用户名
          const displayUsername = getCurrentDisplayUsername();

          // 同步更新本地userStats的用户名
          if (userStats) {
            userStats.username = displayUsername;
          }

          const response = await fetch(`${API_BASE_URL}/api/games`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              userId: currentUser.piUserId || currentUser.uid,
              username: displayUsername,
              gameResult: result, // 'win', 'loss', 'draw'
              gameData: {
                ...gameData,
                gameMode: "ai",
                difficulty: 7,
                timestamp: new Date().toISOString(),
              },
            }),
          });

          if (response.ok) {
            const data = await response.json();
            userStats = data.userStats; // 更新本地统计数据
          } else {
            console.error("记录游戏结果失败:", response.statusText);
            // 如果后端失败，至少保存本地数据
            saveUserGameData();
          }
        } catch (error) {
          console.error("记录游戏结果失败:", error);
          // 如果后端失败，至少保存本地数据
          saveUserGameData();
        }
      }

      // 执行返回登录界面
      function performBackToLogin() {
        // 直接切换到主界面，避免页面重新加载的延迟
        const root = document.getElementById("root");
        root.innerHTML = `
                <div class="login-screen">
                    <div class="container">
                        <div class="login-content">
                            <div class="login-card card">
                                <!-- 语言切换器 -->
                                <div class="language-selector">
                                    <span class="globe-icon">🌍</span>
                                    <select id="language-selector-game" onchange="changeLanguage(this.value)">
                                        <option value="zh" data-i18n="lang_zh">中文</option>
                                        <option value="en" data-i18n="lang_en">English</option>
                                        <option value="ko" data-i18n="lang_ko">한국어</option>
                                        <option value="ja" data-i18n="lang_ja">日本語</option>
                                        <option value="vi" data-i18n="lang_vi">Tiếng Việt</option>
                                    </select>
                                </div>

                                <div class="card-header text-center">
                                    <div class="title-with-icon">
                                        <div class="board-icon">
                                            <div class="stones-container">
                                                <div class="stone-jar black">
                                                    <div class="stone"></div>
                                                </div>
                                                <div class="stone-jar white">
                                                    <div class="stone"></div>
                                                </div>
                                            </div>
                                        </div>
                                        <h1 class="game-title" data-i18n="game_title">${t(
                                          "game_title"
                                        )}</h1>
                                    </div>
                                    <p class="game-subtitle" data-i18n="game_subtitle">
                                        ${t("game_subtitle")}
                                    </p>
                                </div>

                                <div class="card-content">
                                    <div class="game-modes">
                                        <div class="game-mode-row">
                                            <button class="game-mode-btn online-mode" onclick="handleOnlineMatch()">
                                                <span class="mode-icon">🌐</span>
                                                <span class="mode-text" data-i18n="online_match">${t(
                                                  "online_match"
                                                )}</span>
                                            </button>
                                        </div>
                                        <div class="game-mode-row">
                                            <button class="game-mode-btn" onclick="showGlobalRanking()">
                                                <span class="mode-icon">🏆</span>
                                                <span class="mode-text" data-i18n="global_ranking">${t(
                                                  "global_ranking"
                                                )}</span>
                                            </button>
                                        </div>
                                        <div class="game-mode-row">
                                            <button class="game-mode-btn ai-mode" onclick="handleAIGame()">
                                                <span class="mode-icon">🧠</span>
                                                <span class="mode-text" data-i18n="ai_battle">${t(
                                                  "ai_battle"
                                                )}</span>
                                            </button>
                                        </div>
                                        <div class="game-mode-row">
                                            <button class="game-mode-btn" onclick="showPersonalCenter()">
                                                <span class="mode-icon">👤</span>
                                                <span class="mode-text" data-i18n="personal_center">${t(
                                                  "personal_center"
                                                )}</span>
                                            </button>
                                        </div>
                                        <div class="game-mode-row">
                                            <button class="game-mode-btn" onclick="showGameInstructions()">
                                                <span class="mode-icon">❓</span>
                                                <span class="mode-text" data-i18n="game_instructions">${t(
                                                  "game_instructions"
                                                )}</span>
                                            </button>
                                        </div>
                                    </div>

                                    <div class="error-message" id="error-message" style="display: none;">
                                        <p id="error-text" data-i18n="error_message">❌ 错误信息</p>
                                    </div>
                                </div>

                                <div class="card-footer">
                                    <button id="login-btn" class="btn btn-primary btn-lg pi-login-btn" onclick="handleSignIn()">
                                        <span class="pi-icon">π</span>
                                        <span data-i18n="login_with_pi">${t(
                                          "login_with_pi"
                                        )}</span>
                                    </button>
                                    <p class="login-note" data-i18n="login_note">
                                        ${t("login_note")}
                                    </p>

                                    <!-- 隐私政策和服务条款链接 -->
                                    <div class="legal-links" style="margin-top: 20px; text-align: center;">
                                        <a href="public/privacy-policy.html" target="_blank" style="color: #c77dff; text-decoration: none; margin: 0 10px; font-size: 14px;" data-i18n="privacy_policy">隐私政策</a>
                                        <span style="color: #ffffff80;">|</span>
                                        <a href="public/terms-of-service.html" target="_blank" style="color: #c77dff; text-decoration: none; margin: 0 10px; font-size: 14px;" data-i18n="terms_of_service">服务条款</a>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;

        // 重新初始化页面状态
        initializePage();

        // 立即调整副标题字体大小，不使用延迟
        adjustSubtitleFontSize();

        // 确保按钮状态正确更新
        updateMainPageButtonState();
      }

      // 显示充值对话框
      function showRechargeDialog(message) {
        showCustomModal(
          t("recharge_dialog_title"),
          `
            <div style="text-align: center;">
              <div style="margin-bottom: 20px;">
                <div style="font-size: 2em; margin-bottom: 10px;">💳</div>
                <p style="color: #666; margin-bottom: 15px;">${message}</p>
              </div>

              <div style="background: #f8f9fa; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                <h4 style="color: #333; margin-bottom: 15px;">${t(
                  "recharge_amount_selection"
                )}</h4>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                  <button onclick="createRechargeOrder(1)" style="background: #28a745; color: white; border: none; border-radius: 6px; padding: 12px; cursor: pointer;">
                    1 π
                  </button>
                  <button onclick="createRechargeOrder(5)" style="background: #17a2b8; color: white; border: none; border-radius: 6px; padding: 12px; cursor: pointer;">
                    5 π
                  </button>
                  <button onclick="createRechargeOrder(10)" style="background: #ffc107; color: black; border: none; border-radius: 6px; padding: 12px; cursor: pointer;">
                    10 π
                  </button>
                  <button onclick="createRechargeOrder(20)" style="background: #dc3545; color: white; border: none; border-radius: 6px; padding: 12px; cursor: pointer;">
                    20 π
                  </button>
                </div>
                <div style="margin-top: 10px;">
                  <input type="number" id="custom-amount" placeholder="${t(
                    "custom_amount_placeholder"
                  )}" min="0.1" step="0.1" style="width: 120px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-right: 10px;">
                  <button onclick="createCustomRechargeOrder()" style="background: #6c757d; color: white; border: none; border-radius: 4px; padding: 8px 12px; cursor: pointer;">
                    ${t("custom_recharge")}
                  </button>
                </div>
              </div>

              <div style="text-align: center;">
                <button onclick="closeNewModal()" style="background: #6c757d; color: white; border: none; border-radius: 6px; padding: 10px 20px; cursor: pointer;">
                  ${t("cancel")}
                </button>
              </div>
            </div>
          `
        );
      }

      // 创建充值订单
      async function createRechargeOrder(amount) {
        if (!currentUser) {
          showCustomAlert(t("error_title"), t("please_login_first"));
          return;
        }

        try {
          const response = await fetch(`${API_BASE_URL}/api/payment/create`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              userId: currentUser.uid,
              amount: amount,
              purpose: "recharge",
            }),
          });

          const data = await response.json();
          if (data.success) {
            showPaymentDialog(data.order);
          } else {
            showCustomAlert(t("create_order_failed"), data.message);
          }
        } catch (error) {
          console.error("创建充值订单失败:", error);
          showCustomAlert(t("error_title"), t("network_error_retry"));
        }
      }

      // 创建自定义金额充值订单
      function createCustomRechargeOrder() {
        const amountInput = document.getElementById("custom-amount");
        const amount = parseFloat(amountInput.value);

        if (!amount || amount < 0.1) {
          showCustomAlert(t("error_title"), t("custom_amount_error"));
          return;
        }

        createRechargeOrder(amount);
      }

      // 显示支付对话框
      function showPaymentDialog(order) {
        showCustomModal(
          t("payment_dialog_title"),
          `
            <div style="text-align: center;">
              <div style="margin-bottom: 20px;">
                <div style="font-size: 2em; margin-bottom: 10px;">π</div>
                <h3 style="color: #333; margin-bottom: 10px;">${t(
                  "recharge_amount_display",
                  order.amount
                )}</h3>
                <p style="color: #666; font-size: 14px;">${t(
                  "order_id_display",
                  order.orderId
                )}</p>
              </div>

              <div style="background: #f8f9fa; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                <h4 style="color: #333; margin-bottom: 15px;">${t(
                  "payment_method"
                )}</h4>

                <div style="background: white; border-radius: 6px; padding: 15px; margin-bottom: 15px; border: 2px solid #e9ecef;">
                  <h5 style="color: #333; margin-bottom: 10px;">${t(
                    "pi_wallet_transfer"
                  )}</h5>
                  <p style="color: #666; font-size: 14px; margin-bottom: 10px;">
                    ${t("transfer_instruction")}
                  </p>
                  <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; font-family: monospace; font-size: 12px; word-break: break-all; margin-bottom: 10px;">
                    ${order.receiverAddress}
                  </div>
                  <p style="color: #dc3545; font-size: 13px; margin-bottom: 10px;">
                    ${t("transfer_amount_warning", order.amount)}
                  </p>
                  <p style="color: #666; font-size: 13px;">
                    ${t("transfer_memo", order.qrCodeData.memo)}
                  </p>
                </div>

                <div style="margin-bottom: 15px;">
                  <input type="text" id="transaction-hash" placeholder="${t(
                    "transaction_hash_placeholder"
                  )}" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace; font-size: 14px;">
                  <p style="color: #666; font-size: 12px; margin-top: 5px;">
                    ${t("transaction_hash_instruction")}
                  </p>
                </div>
              </div>

              <div style="display: flex; gap: 10px; justify-content: center;">
                <button onclick="verifyPayment('${
                  order.orderId
                }')" style="background: #28a745; color: white; border: none; border-radius: 6px; padding: 10px 20px; cursor: pointer;">
                  ${t("verify_payment")}
                </button>
                <button onclick="closeNewModal()" style="background: #6c757d; color: white; border: none; border-radius: 6px; padding: 10px 20px; cursor: pointer;">
                  ${t("cancel")}
                </button>
              </div>

              <p style="color: #666; font-size: 12px; margin-top: 15px;">
                ${t("order_validity")}
              </p>
            </div>
          `
        );
      }

      // 验证支付
      async function verifyPayment(orderId) {
        const transactionHashInput =
          document.getElementById("transaction-hash");
        const transactionHash = transactionHashInput.value.trim();

        if (!transactionHash) {
          showCustomAlert(t("error_title"), t("please_enter_transaction_hash"));
          return;
        }

        try {
          const response = await fetch(`${API_BASE_URL}/api/payment/verify`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              orderId: orderId,
              transactionHash: transactionHash,
            }),
          });

          const data = await response.json();
          if (data.success) {
            closeNewModal();
            showCustomAlert(
              t("recharge_success"),
              t(
                "recharge_success_message",
                data.order.amount,
                data.newBalance.toFixed(2)
              )
            );
          } else {
            showCustomAlert(t("verification_failed"), data.message);
          }
        } catch (error) {
          console.error("验证支付失败:", error);
          showCustomAlert(t("error_title"), t("network_error_retry"));
        }
      }

      // Pi Network iframe环境强力修复语言选择器位置
      function forceFixLanguageSelectorPosition() {
        const languageSelector = document.querySelector(".language-selector");
        if (languageSelector) {
          // 检测是否在iframe中
          const isInIframe = window.self !== window.top;
          const isPiNetwork =
            window.location.hostname.includes("minepi.com") ||
            document.referrer.includes("minepi.com") ||
            isInIframe;

          // 强制应用最高优先级样式
          const styles = {
            position: "fixed",
            top: "15px",
            right: "15px",
            zIndex: "2147483647", // 最大z-index值
            transform: "translate3d(0, 0, 0)",
            willChange: "transform",
            pointerEvents: "auto",
            margin: "0",
            left: "auto",
            bottom: "auto",
          };

          Object.assign(languageSelector.style, styles);

          // 添加重要性标记
          languageSelector.style.setProperty("position", "fixed", "important");
          languageSelector.style.setProperty("top", "15px", "important");
          languageSelector.style.setProperty("right", "15px", "important");
          languageSelector.style.setProperty(
            "z-index",
            "2147483647",
            "important"
          );

          if (isPiNetwork) {
            document.body.classList.add("pi-network-iframe");
          }
        }
      }

      // 强制刷新缓存检查
      function checkCacheVersion() {
        const currentVersion = "2025-06-11-22:30";
        const cachedVersion = localStorage.getItem("appVersion");

        if (cachedVersion !== currentVersion) {
          localStorage.setItem("appVersion", currentVersion);
          // 如果版本不匹配，强制刷新
          if (cachedVersion && "serviceWorker" in navigator) {
            navigator.serviceWorker
              .getRegistrations()
              .then(function (registrations) {
                for (let registration of registrations) {
                  registration.unregister();
                }
              });
          }
        }
      }

      // 页面加载完成后初始化
      document.addEventListener("DOMContentLoaded", function () {
        checkCacheVersion();
        initializePage();

        // 强力修复语言选择器位置
        forceFixLanguageSelectorPosition();

        // 定时重复修复，确保在Pi Network iframe中正确显示
        setTimeout(() => {
          forceFixLanguageSelectorPosition();
        }, 500);

        setTimeout(() => {
          forceFixLanguageSelectorPosition();
        }, 1000);

        setTimeout(() => {
          forceFixLanguageSelectorPosition();
        }, 2000);

        // 手机端阴影清除
        clearAllStoneShadows();

        // 监听窗口大小变化，重新清除阴影和调整字体
        window.addEventListener("resize", function () {
          setTimeout(() => {
            clearAllStoneShadows();
            adjustSubtitleFontSize();
          }, 100);
        });

        // 监听设备方向变化
        window.addEventListener("orientationchange", function () {
          setTimeout(() => {
            clearAllStoneShadows();
          }, 200);
        });
      });

      // 强制刷新缓存检查
      function checkCacheVersion() {
        const currentVersion = "2025-06-11-22:30";
        const cachedVersion = localStorage.getItem("appVersion");

        if (cachedVersion !== currentVersion) {
          localStorage.setItem("appVersion", currentVersion);
          // 如果版本不匹配，强制刷新
          if (cachedVersion && "serviceWorker" in navigator) {
            navigator.serviceWorker
              .getRegistrations()
              .then(function (registrations) {
                for (let registration of registrations) {
                  registration.unregister();
                }
              });
          }
        }
      }

      // 页面加载完成后初始化
      document.addEventListener("DOMContentLoaded", function () {
        checkCacheVersion();
        initializePage();

        // 强力修复语言选择器位置
        forceFixLanguageSelectorPosition();

        // 更新主页按钮状态
        updateMainPageButtonState();

        // 清除所有棋子阴影
        setTimeout(() => {
          clearAllStoneShadows();
        }, 200);
      });
    </script>
  </body>
</html>








    </style>
  </head>
  <body>
    <noscript data-i18n="noscript"
      >您需要启用JavaScript才能运行此应用程序。</noscript
    >



    <script>
      // 多语言配置
      const LANGUAGES = {
        zh: {
          // 基础界面
          noscript: "您需要启用JavaScript才能运行此应用程序。",
          game_title: "五子棋",
          game_subtitle: "运行在pinetwork区块链之上的五子棋游戏",
          global_ranking: "全球排行",
          ai_battle: "AI对战",
          personal_center: "个人中心",
          game_instructions: "游戏说明",
          error_message: "❌ 错误信息",
          login_with_pi: "使用Pi Network登录",
          login_note: "点击登录即表示您同意使用Pi Network账户进行身份验证",

          // 语言选项
          lang_zh: "中文",
          lang_en: "English",
          lang_ko: "한국어",
          lang_ja: "日本語",
          lang_vi: "Tiếng Việt",

          // 游戏相关
          current_player: "当前玩家",
          your_turn: "轮到我方落子",
          opponent_turn: "轮到对方落子",
          ai_thinking: "🤖 AI正在思考中...",
          thinking_time: "⏱️ 思考时间：{0}秒",
          remaining_time: "⚠️ 剩余时间：{0}秒",
          timeout_warning: "🚨 即将超时：{0}秒",
          timeout: "⏰ 思考超时",

          // 游戏结果
          you_win: "🎉 恭喜您获胜！",
          you_lose: "😔 很遗憾，您败了",
          draw: "🤝 平局",
          game_over: "游戏结束",

          // 按钮和操作
          new_game: "新游戏",
          undo: "悔棋",
          restart: "重新开始",
          back_to_menu: "返回主菜单",
          confirm: "确认",
          cancel: "取消",
          close: "关闭",
          save: "保存",
          update: "更新",
          enter_game: "进入游戏",

          // 个人中心
          personal_info: "个人信息",
          game_stats: "游戏统计",
          total_games: "总局数",
          wins: "胜利",
          losses: "失败",
          win_rate: "胜率",
          current_rank: "当前排名",
          wallet_address: "钱包地址",
          balance: "余额",
          nickname: "昵称",
          avatar: "头像",

          // 错误和提示
          connection_failed: "连接失败",
          network_error: "网络错误，请检查网络连接后重试",
          login_failed: "登录失败",
          insufficient_balance: "余额不足",
          invalid_move: "无效落子",
          game_not_started: "游戏未开始",

          // 支付相关
          payment_confirm: "确认支付",
          payment_success: "支付成功",
          payment_failed: "支付失败",
          payment_cancelled: "支付已取消",
          recharge: "充值",

          // 排行榜
          leaderboard: "排行榜",
          rank: "排名",
          player: "玩家",
          score: "积分",
          games_played: "游戏局数",

          // 其他
          loading: "加载中...",
          connecting: "正在连接...",
          please_wait: "请稍候...",
          success: "成功",
          failed: "失败",
          connecting_pi_network: "正在连接Pi Network...",
          entering_game: "正在进入游戏...",

          // 弹窗和提示
          hint: "提示",
          confirm_purchase: "确认购买",
          confirm_payment: "确认支付",
          payment_amount: "{0} π",
          enter_nickname: "请输入昵称",
          nickname_too_long: "昵称不能超过20个字符",
          nickname_forbidden: "昵称包含敏感词，请重新输入",
          logout_confirm: "退出确认",
          logout_message: "确定要退出账户吗？您的游戏数据将被保留。",
          logout_success: "退出成功",
          logout_success_message: "已成功退出账户！",
          please_login_first: "请先登录",

          // 游戏说明
          game_instructions_title: "游戏说明",
          game_history_title: "五子棋历史渊源",
          game_history_desc:
            '相传五子棋诞生于4000多年前的尧帝时期。尧为教育儿子丹朱，发明了石子棋，后经舜改良为"五星连珠"玩法，逐渐形成现代五子棋的雏形。\n从尧舜时期的民间游戏，到南北朝传播至东亚，再经日本改良为竞技运动，最终成为全球性棋类项目。',

          // 个人中心
          personal_center_title: "个人中心",
          wallet_address_placeholder: "输入50位钱包地址 (大写字母和数字)",
          wallet_address_format: "钱包地址格式：50位大写字母和数字",

          // 支付相关
          insufficient_balance_title: "余额不足",
          insufficient_balance_message:
            "悔棋需要消费 0.1 π，当前余额 {0} π，余额不足。\n\n是否要充值？",
          recharge_prompt: "为您的游戏账户充值Pi币，享受更多游戏功能！",
          continue_without_recharge:
            "您可以继续当前游戏，但无法重新开始。充值后即可解锁此功能。",
          undo_success: "悔棋成功",
          undo_success_message: "已消费 0.1 π，余额：{0} π",
          undo_failed: "悔棋失败",
          network_error_retry: "网络错误，请稍后重试",
          invalid_amount: "请输入有效的充值金额（最低0.1π）",

          // 道具名称
          item_hint: "提示道具",
          item_undo: "悔棋券",
          item_theme: "主题包",
          item_vip: "VIP会员",
          item_unknown: "未知道具",

          // 排行榜和统计
          current_ranking: "🎯 当前排名：第{0}名 | ({1}胜{2}负) | 胜率：{3}%",
          leaderboard_update_tip: "排行榜实时更新，继续游戏提升您的排名！",
          ranking_header_rank: "排名",
          ranking_header_nickname: "昵称",
          ranking_header_games: "总对局",
          ranking_header_winrate: "胜率",
          current_rank_not_listed: "当前排名：未上榜",
          current_rank_label: "当前排名",
          not_listed: "未上榜",
          play_one_game_to_rank:
            "🎮 完成1局游戏即可上榜！开始您的五子棋之旅吧！",

          // 个人中心详细内容
          personal_profile: "个人档案",
          avatar_nickname: "头像和昵称",
          click_to_edit: "点击编辑",
          account_info: "账户信息",
          game_statistics: "游戏统计",
          account_balance_label: "账户余额",
          refresh_balance: "刷新余额",
          logout_account: "退出账户",

          // 游戏说明详细内容
          game_history_section: "五子棋历史渊源",
          game_rules_section: "游戏规则",
          game_rules_title: "🎯 基本规则",
          game_rules_desc: "两人轮流在15×15棋盘上落子，率先连成5子者获胜",
          game_features_title: "🌟 游戏特色",
          game_features_desc:
            "• 支持人机对战，AI智能强大\n• 实时排行榜系统\n• Pi币奖励机制\n• 多语言支持",
          game_controls_title: "🎮 操作说明",
          game_controls_desc:
            "• 点击棋盘空位落子\n• 支持悔棋功能（需消费Pi币）\n• 可随时重新开始游戏",

          // 充值和支付
          recharge_title: "💰 账户充值",
          payment_title: "💳 Pi币支付",
          recharge_amount: "充值 {0} π",
          order_number: "订单号：{0}",
          quick_recharge: "快速充值",
          custom_amount: "自定义金额",
          min_amount_note: "最低充值0.1π",
          recharge_benefits: "充值后可享受：",
          recharge_benefit_1: "• 无限次悔棋",
          recharge_benefit_2: "• 游戏重新开始",
          recharge_benefit_3: "• 专属道具购买",
          recharge_benefit_4: "• 参与月度奖励",

          // 错误和状态
          error_title: "错误",
          loading_text: "正在加载...",
          connecting_text: "正在连接...",
          balance_query: "查询中...",
          balance_query_failed: "查询失败",
          pi_login_failed: "Pi Network 登录失败",
          login_error: "登录过程中发生错误",
          pi_sdk_not_loaded: "Pi Network SDK未加载，无法使用支付功能",
          create_payment_failed: "创建支付失败",

          // 游戏说明详细规则
          basic_rules_detail_1: "在15×15的棋盘上，玩家执黑子，AI执白子",
          basic_rules_detail_2: "双方轮流落子，先连成五子一线者获胜",
          basic_rules_detail_3: "五子可以是横、竖、斜任意方向的连线",
          basic_rules_detail_4: "棋盘填满且无人获胜则为平局",

          // 回合时间规则
          turn_time_rules: "⏱️ 回合时间规则",
          thinking_time_rule: "思考时间：每回合60秒思考时间",
          time_warning_rule: "时间提醒：剩余30秒时黄色警告",
          urgent_warning_rule: "紧急提醒：最后10秒红色闪烁",
          timeout_rule: "超时判负：超时自动记录为失败",

          // 游戏操作详细
          game_operations: "🎮 游戏操作",
          place_stone: "落子：点击空白格子下棋",
          undo_move: "悔棋：可撤销最近一步（玩家+AI各一步）",
          new_game_op: "新游戏：重新开始，进行中的游戏记录为失败",
          return_op: "返回：退出游戏，进行中的游戏记录为失败",

          // 胜率排行系统
          score_system: "🏆 胜率排行系统",
          initial_score: "排行依据：按胜率排序",
          win_score: "获胜：提升胜率",
          draw_score: "平局：影响胜率",
          lose_score: "失败：降低胜率",
          quit_score: "放弃/超时：记为失败",

          // 月度排名规则
          monthly_ranking_rules: "🎯 月度排名规则：",
          ranking_requirement: "• 需要至少1局对局才能参与排名",
          ranking_criteria: "• 按剩余分数高低排名，分数相同按胜率排序",
          ranking_rewards: "• 月底根据排名发放奖励",
          anti_farming: "⚠️ 防刷分机制：不对局或对局太少的玩家不参与排名",

          // 月度奖励规则
          monthly_rewards: "🏆 月度奖励规则",
          reward_pool_allocation: "💰 奖励池分配",
          reward_settlement: "每月月底最后一天最后一小时进行结算",
          reward_pool_percentage: "奖励池为当月平台总盈利的 50%",
          reward_example: "例：本月盈利100π，奖励池为50π",

          // 前三名分配
          top_three_distribution: "🥇 前三名分配比例",
          first_place: "🥇 第一名",
          second_place: "🥈 第二名",
          third_place: "🥉 第三名",

          // 发放方式
          distribution_method: "📋 发放方式",
          wallet_distribution: "按照个人中心保存的钱包地址手动发放",
          valid_wallet_required: "获奖者需确保钱包地址正确有效",
          next_day_distribution: "奖励将在结算次日发放",
          invalid_wallet_rollover: "如钱包地址无效，奖励将顺延至下月",

          // 排行榜规则
          leaderboard_rules: "📊 排行榜规则",
          ranking_condition: "上榜条件：完成1局游戏即可上榜",
          ranking_basis: "排名依据：按胜率排序（胜率相同时按总局数排序）",
          data_statistics: "数据统计：月度排行榜，每月1日重置",
          realtime_update: "实时更新：每局结束后立即更新",

          // 温馨提示
          warm_tips:
            "🎋 传承千年智慧，体验古典棋艺之美\n💡 合理安排时间，享受思考乐趣",

          // 游戏结果相关
          game_result: "游戏结果",
          congratulations_win: "🎉 恭喜获胜！",
          sorry_lose: "😔 很遗憾失败了",
          draw_result: "🤝 平局",
          current_score: "当前积分",
          win_rate_display: "胜率",
          total_games_display: "总对局",
          current_rank_display: "当前排名",
          not_ranked: "未上榜",
          guest_mode: "游客模式",
          guest_mode_desc: "您当前以游客身份游戏，游戏结果不会记录到排行榜中。",
          login_benefits: "登录后可享受：",
          benefit_stats: "• 📊 游戏数据统计",
          benefit_leaderboard: "• 🏆 参与排行榜竞争",
          benefit_pi_service: "• 💰 Pi币增值服务",
          benefit_monthly_rewards: "• 🎁 月度奖励活动",
          play_again: "再来一局",
          view_leaderboard: "查看排行榜",
          login_now: "立即登录",
          monthly_games: "本月对局",
          rank_position: "第{0}名",

          // 游戏界面
          return_to_menu: "返回",
          guest_mode_short: "🎮 游客模式",
          ai_battle_title: "🧠 AI对战",
          player_label: "玩家",
          ai_label: "AI",
          vs_label: "VS",
          undo_button: "悔棋",
          new_game_button: "新游戏",

          // 悔棋相关
          undo_confirm: "悔棋确认",
          undo_confirm_message:
            "悔棋需要消费 0.1 π\n当前余额：{0} π\n\n确定要悔棋吗？",
          undo_success_title: "悔棋成功",
          undo_success_detail: "已消费 0.1 π，余额：{0} π",
          undo_failed_title: "悔棋失败",
          undo_failed_message: "扣费失败",
          insufficient_balance_undo:
            "悔棋需要消费 0.1 π，当前余额 {0} π，余额不足。\n\n是否要充值？",
          continue_game_tip:
            "您可以继续当前游戏，但无法重新开始。充值后即可解锁此功能。",

          // 充值相关
          recharge_dialog_title: "💰 账户充值",
          payment_dialog_title: "💳 Pi币支付",
          recharge_amount_display: "充值 {0} π",
          order_id_display: "订单号：{0}",
          custom_amount_error: "请输入有效的充值金额（最低0.1π）",

          // 个人中心详细内容
          monthly_reward_reminder: "🏆 月度奖励提醒",
          monthly_reward_desc: "每月利润的50%将分配给排名前三的玩家作为奖励",

          // 月度重置系统
          monthly_reset_system: "📅 月度重置系统",
          monthly_reset_desc: "每月1日自动重置排行榜，开始新的月度竞赛",
          historical_data_preserved: "历史总对局数据永久保存，不会清零",
          monthly_ranking_only: "仅月度排行榜数据重置，个人历史记录保留",

          // 全球排行榜
          global_ranking_title: "全球排行",
          ranking_subtitle: "📊 基于月度胜率的排名",
          ranking_header_rank: "排名",
          ranking_header_nickname: "昵称",
          ranking_header_games: "总对局",
          ranking_header_winrate: "胜率",

          // 个人中心详细标签
          personal_profile_section: "个人档案",
          avatar_nickname_section: "头像和昵称",
          click_avatar_edit: "点击头像编辑",
          click_nickname_edit: "点击昵称编辑",
          account_info_section: "账户信息",
          game_stats_section: "游戏统计",
          wallet_address_label: "钱包地址",
          account_balance_display: "账户余额",
          refresh_balance_btn: "刷新余额",
          logout_btn: "退出账户",

          // 游戏统计标签
          total_games_label: "总对局",
          wins_label: "胜利",
          win_rate_label: "胜率",
          current_score_label: "当前积分",
          current_rank_label: "当前排名",

          // 余额查询状态
          balance_querying: "查询中...",
          balance_query_failed_display: "查询失败",
          balance_tooltip: "总充值：{0} π\n总消费：{1} π",

          // 支付成功信息
          payment_success_title: "支付成功",
          payment_success_message: "支付成功！",
          purchase_success_message: "您已成功购买 {0}",
          transaction_id: "交易ID: {0}",

          // 个人中心输入提示
          enter_avatar_emoji: "输入emoji头像 (如: 😊)",
          click_to_set_nickname: "点击设置昵称",
          enter_your_nickname: "输入您的昵称",
          loading_text_display: "加载中...",
          refresh_balance_text: "🔄 刷新余额",
          recharge_text: "💰 充值",
          wallet_format_hint: "钱包地址格式：50位大写字母和数字",
          save_wallet: "💾 保存",
          edit_wallet: "✏️ 编辑",
          logout_account_text: "↩️ 退出账户",

          // 个人中心提示信息
          enter_avatar_hint: "请输入头像emoji",
          single_emoji_hint: "请输入单个emoji表情",
          avatar_updated: "头像已更新！",
          nickname_updated: "昵称已更新！",
          enter_wallet_hint: "请输入钱包地址",
          wallet_length_error:
            "❌ 这不是标准钱包地址！\n\n当前长度：{0}位\n标准长度：50位\n\n请输入完整的50位钱包地址",
          wallet_format_error:
            "❌ 钱包地址格式错误！\n\n只能包含大写字母(A-Z)和数字(0-9)\n请检查输入内容",
          wallet_saved_success: "✅ 钱包地址已保存成功！",
          edit_mode_title: "编辑模式",
          edit_mode_message: "💡 编辑模式已启用\n\n请修改钱包地址后点击保存",
          success_title: "成功",

          // 游戏结束相关
          you_win: "🎉 恭喜您获胜！",
          you_lose: "😔 AI获胜，再接再厉！",
          draw: "🤝 平局！",
          game_over: "游戏结束",

          // 主界面按钮
          online_match: "在线匹配",
          global_ranking: "全球排行",
          ai_battle: "AI对战",
          personal_center: "个人中心",
          game_instructions: "游戏说明",

          // 连接错误
          connection_failed: "连接失败",
          connection_error_detail: "无法连接到Pi Network，请检查网络连接后重试",
          login_with_pi: "使用Pi账号登录",
          login_benefits_note: "登录后可享受完整游戏功能和Pi币奖励",

          // 充值对话框
          recharge_amount_selection: "充值金额选择",
          custom_amount_placeholder: "自定义金额",
          custom_recharge: "自定义充值",
          cancel: "取消",

          // 错误提示
          please_login_first: "请先登录",
          create_order_failed: "创建订单失败",
          network_error_retry: "网络错误，请稍后重试",

          // 支付对话框
          payment_method: "支付方式",
          pi_wallet_transfer: "📱 Pi钱包转账",
          transfer_instruction: "请使用Pi钱包向以下地址转账：",
          transfer_amount_warning: "⚠️ 请确保转账金额为 <strong>{0} π</strong>",
          transfer_memo: "转账备注：{0}",
          transaction_hash_placeholder: "请输入转账交易哈希",
          transaction_hash_instruction:
            "转账完成后，请在Pi钱包中复制交易哈希并粘贴到上方输入框",
          verify_payment: "验证支付",
          order_validity: "订单有效期：30分钟",

          // 支付验证
          please_enter_transaction_hash: "请输入交易哈希",
          recharge_success: "充值成功",
          recharge_success_message: "恭喜！充值 {0} π 成功！\n当前余额：{1} π",
          verification_failed: "验证失败",

          // 游戏流程确认
          timeout_game_over: "⏰ 思考超时，游戏失败！",
          login_success: "登录成功",
          welcome_user: "欢迎，{0}",
          abandon_current_game: "放弃当前游戏",
          abandon_game_warning:
            "当前游戏正在进行中，重新开始将记录为失败。\n\n确定要放弃当前游戏吗？",
          restart_game: "重新开始游戏",
          restart_game_confirm: "确定要重新开始吗？",
          abandon_game_return_warning:
            "当前游戏正在进行中，返回主界面将记录为失败。\n\n确定要放弃当前游戏吗？",

          // 胜负显示格式
          wins_losses_format: "({0}胜{1}负)",

          // 月度奖励详细说明
          reward_settlement_detail: "每月月底最后一天最后一小时进行结算",
          reward_pool_50_percent: "奖励池为当月平台总盈利的 50%",
          reward_example_detail: "例：本月盈利100π，奖励池为50π",
          reward_distribution_manual: "按照个人中心保存的钱包地址手动发放",
          reward_wallet_valid: "获奖者需确保钱包地址正确有效",
          reward_next_day: "奖励将在结算次日发放",
          reward_invalid_rollover: "如钱包地址无效，奖励将顺延至下月",
          reward_example_calculation: "💡 示例：本月盈利100π，奖励池50π",
          first_place_reward: "🥇第一名：25π",
          second_place_reward: "🥈第二名：15π",
          third_place_reward: "🥉第三名：10π",
        },

        en: {
          // 基础界面
          noscript: "You need to enable JavaScript to run this application.",
          game_title: "Gomoku",
          game_subtitle: "Gomoku game running on pinetwork blockchain",
          global_ranking: "Global Ranking",
          ai_battle: "AI Battle",
          personal_center: "Personal Center",
          game_instructions: "Game Instructions",
          error_message: "❌ Error Message",
          login_with_pi: "Login with Pi Network",
          login_note:
            "By clicking login, you agree to use Pi Network account for authentication",

          // 语言选项
          lang_zh: "中文",
          lang_en: "English",
          lang_ko: "한국어",
          lang_ja: "日本語",
          lang_vi: "Tiếng Việt",

          // 游戏相关
          current_player: "Current Player",
          your_turn: "Your Turn",
          opponent_turn: "Opponent's Turn",
          ai_thinking: "🤖 AI is thinking...",
          thinking_time: "⏱️ Thinking time: {0}s",
          remaining_time: "⚠️ Time remaining: {0}s",
          timeout_warning: "🚨 Timeout warning: {0}s",
          timeout: "⏰ Timeout",

          // 游戏结果
          you_win: "🎉 Congratulations! You Win!",
          you_lose: "😔 Sorry, You Lose",
          draw: "🤝 Draw",
          game_over: "Game Over",

          // 按钮和操作
          new_game: "New Game",
          undo: "Undo",
          restart: "Restart",
          back_to_menu: "Back to Menu",
          confirm: "Confirm",
          cancel: "Cancel",
          close: "Close",
          save: "Save",
          update: "Update",
          enter_game: "Enter Game",

          // 个人中心
          personal_info: "Personal Info",
          game_stats: "Game Statistics",
          total_games: "Total Games",
          wins: "Wins",
          losses: "Losses",
          win_rate: "Win Rate",
          current_rank: "Current Rank",
          wallet_address: "Wallet Address",
          balance: "Balance",
          nickname: "Nickname",
          avatar: "Avatar",

          // 错误和提示
          connection_failed: "Connection Failed",
          network_error:
            "Network error, please check your connection and try again",
          login_failed: "Login Failed",
          insufficient_balance: "Insufficient Balance",
          invalid_move: "Invalid Move",
          game_not_started: "Game Not Started",

          // 支付相关
          payment_confirm: "Confirm Payment",
          payment_success: "Payment Successful",
          payment_failed: "Payment Failed",
          payment_cancelled: "Payment Cancelled",
          recharge: "Recharge",

          // 排行榜
          leaderboard: "Leaderboard",
          rank: "Rank",
          player: "Player",
          score: "Score",
          games_played: "Games Played",

          // 其他
          loading: "Loading...",
          connecting: "Connecting...",
          please_wait: "Please wait...",
          success: "Success",
          failed: "Failed",
          connecting_pi_network: "Connecting to Pi Network...",
          entering_game: "Entering game...",

          // 弹窗和提示
          hint: "Hint",
          confirm_purchase: "Confirm Purchase",
          confirm_payment: "Confirm Payment",
          payment_amount: "{0} π",
          enter_nickname: "Please enter nickname",
          nickname_too_long: "Nickname cannot exceed 20 characters",
          nickname_forbidden:
            "Nickname contains forbidden words, please re-enter",
          logout_confirm: "Logout Confirmation",
          logout_message:
            "Are you sure you want to logout? This will clear all locally saved data.",
          logout_success: "Logout Successful",
          logout_success_message: "Successfully logged out!",
          please_login_first: "Please login first",

          // 游戏说明
          game_instructions_title: "Game Instructions",
          game_history_title: "Gomoku History",
          game_history_desc:
            'Legend says Gomoku was born over 4000 years ago during Emperor Yao\'s era. Yao invented stone chess to educate his son Danzhu, later improved by Shun into the "Five Stars in a Row" gameplay, gradually forming the prototype of modern Gomoku.\nFrom folk games in the Yao-Shun era, to spreading to East Asia during the Northern and Southern Dynasties, then refined by Japan into competitive sports, finally becoming a global chess project.',

          // 个人中心
          personal_center_title: "Personal Center",
          wallet_address_placeholder:
            "Enter 50-character wallet address (uppercase letters and numbers)",
          wallet_address_format:
            "Wallet address format: 50 uppercase letters and numbers",

          // 支付相关
          insufficient_balance_title: "Insufficient Balance",
          insufficient_balance_message:
            "Undo requires 0.1 π, current balance {0} π, insufficient balance.\n\nWould you like to recharge?",
          recharge_prompt:
            "Recharge Pi coins for your gaming account and enjoy more game features!",
          continue_without_recharge:
            "You can continue the current game, but cannot restart. Unlock this feature after recharging.",
          undo_success: "Undo Successful",
          undo_success_message: "Consumed 0.1 π, balance: {0} π",
          undo_failed: "Undo Failed",
          network_error_retry: "Network error, please try again later",
          invalid_amount: "Please enter a valid recharge amount (minimum 0.1π)",

          // 道具名称
          item_hint: "Hint Item",
          item_undo: "Undo Ticket",
          item_theme: "Theme Pack",
          item_vip: "VIP Membership",
          item_unknown: "Unknown Item",

          // 排行榜和统计
          current_ranking:
            "🎯 Current Rank: #{0} | ({1}W {2}L) | Win Rate: {3}%",
          leaderboard_update_tip:
            "Leaderboard updates in real-time, keep playing to improve your ranking!",
          ranking_header_rank: "Rank",
          ranking_header_nickname: "Nickname",
          ranking_header_games: "Total Games",
          ranking_header_winrate: "Win Rate",
          current_rank_not_listed: "Current Rank: Not Listed",
          current_rank_label: "Current Rank",
          not_listed: "Not Listed",
          play_one_game_to_rank:
            "🎮 Complete 1 game to get on the leaderboard! Start your Gomoku journey!",

          // 个人中心详细内容
          personal_profile: "Personal Profile",
          avatar_nickname: "Avatar & Nickname",
          click_to_edit: "Click to Edit",
          account_info: "Account Information",
          game_statistics: "Game Statistics",
          account_balance_label: "Account Balance",
          refresh_balance: "Refresh Balance",
          logout_account: "Logout Account",

          // 游戏说明详细内容
          game_history_section: "Gomoku History",
          game_rules_section: "Game Rules",
          game_rules_title: "🎯 Basic Rules",
          game_rules_desc:
            "Two players take turns placing stones on a 15×15 board, first to connect 5 wins",
          game_features_title: "🌟 Game Features",
          game_features_desc:
            "• AI battle with intelligent opponent\n• Real-time leaderboard system\n• Pi coin reward mechanism\n• Multi-language support",
          game_controls_title: "🎮 Controls",
          game_controls_desc:
            "• Click empty board position to place stone\n• Undo function available (costs Pi coins)\n• Restart game anytime",

          // 充值和支付
          recharge_title: "💰 Account Recharge",
          payment_title: "💳 Pi Coin Payment",
          recharge_amount: "Recharge {0} π",
          order_number: "Order Number: {0}",
          quick_recharge: "Quick Recharge",
          custom_amount: "Custom Amount",
          min_amount_note: "Minimum recharge 0.1π",
          recharge_benefits: "After recharge, enjoy:",
          recharge_benefit_1: "• Unlimited undo moves",
          recharge_benefit_2: "• Game restart function",
          recharge_benefit_3: "• Exclusive item purchases",
          recharge_benefit_4: "• Monthly reward participation",

          // 错误和状态
          error_title: "Error",
          loading_text: "Loading...",
          connecting_text: "Connecting...",
          balance_query: "Querying...",
          balance_query_failed: "Query Failed",
          pi_login_failed: "Pi Network login failed",
          login_error: "Error occurred during login",
          pi_sdk_not_loaded:
            "Pi Network SDK not loaded, payment features unavailable",
          create_payment_failed: "Failed to create payment",

          // 游戏说明详细规则
          basic_rules_detail_1:
            "On a 15×15 board, player uses black stones, AI uses white stones",
          basic_rules_detail_2:
            "Players take turns placing stones, first to connect five wins",
          basic_rules_detail_3:
            "Five stones can be connected horizontally, vertically, or diagonally",
          basic_rules_detail_4:
            "If the board is full with no winner, it's a draw",

          // 回合时间规则
          turn_time_rules: "⏱️ Turn Time Rules",
          thinking_time_rule: "Thinking time: 60 seconds per turn",
          time_warning_rule:
            "Time warning: Yellow warning at 30 seconds remaining",
          urgent_warning_rule:
            "Urgent warning: Red flashing in last 10 seconds",
          timeout_rule:
            "Timeout penalty: Timeout automatically recorded as loss",

          // 游戏操作详细
          game_operations: "🎮 Game Operations",
          place_stone: "Place stone: Click empty grid to play",
          undo_move: "Undo: Can retract last move (player + AI each one step)",
          new_game_op: "New game: Restart, ongoing game recorded as loss",
          return_op: "Return: Exit game, ongoing game recorded as loss",

          // 胜率排行系统
          score_system: "🏆 Win Rate Ranking System",
          initial_score: "Ranking basis: Sorted by win rate",
          win_score: "Win: Improves win rate",
          draw_score: "Draw: Affects win rate",
          lose_score: "Loss: Reduces win rate",
          quit_score: "Quit/Timeout: Counts as loss",

          // 月度排名规则
          monthly_ranking_rules: "🎯 Monthly Ranking Rules:",
          ranking_requirement:
            "• At least 1 game required to participate in ranking",
          ranking_criteria:
            "• Ranked by remaining points, same points sorted by win rate",
          ranking_rewards:
            "• Rewards distributed at month end based on ranking",
          anti_farming:
            "⚠️ Anti-farming mechanism: Players with no games or too few games don't participate in ranking",

          // 月度奖励规则
          monthly_rewards: "🏆 Monthly Reward Rules",
          reward_pool_allocation: "💰 Reward Pool Allocation",
          reward_settlement:
            "Settlement on the last hour of the last day of each month",
          reward_pool_percentage:
            "Reward pool is 50% of platform's monthly profit",
          reward_example: "Example: Monthly profit 100π, reward pool 50π",

          // 前三名分配
          top_three_distribution: "🥇 Top Three Distribution",
          first_place: "🥇 First Place",
          second_place: "🥈 Second Place",
          third_place: "🥉 Third Place",

          // 发放方式
          distribution_method: "📋 Distribution Method",
          wallet_distribution:
            "Distributed manually according to wallet address saved in personal center",
          valid_wallet_required:
            "Winners must ensure wallet address is correct and valid",
          next_day_distribution:
            "Rewards will be distributed the day after settlement",
          invalid_wallet_rollover:
            "If wallet address is invalid, rewards will be rolled over to next month",

          // 排行榜规则
          leaderboard_rules: "📊 Leaderboard Rules",
          ranking_condition:
            "Ranking condition: Complete 60 games to be listed",
          ranking_basis: "Ranking basis: Sorted by cumulative points",
          data_statistics:
            "Data statistics: Based on historical cumulative data",
          realtime_update:
            "Real-time update: Updated immediately after each game",

          // 温馨提示
          warm_tips:
            "🎋 Inherit thousand-year wisdom, experience classical chess beauty\n💡 Manage time wisely, enjoy thinking pleasure",

          // 游戏结果相关
          game_result: "Game Result",
          congratulations_win: "🎉 Congratulations! You Win!",
          sorry_lose: "😔 Sorry, You Lost",
          draw_result: "🤝 Draw",
          current_score: "Current Score",
          win_rate_display: "Win Rate",
          total_games_display: "Total Games",
          current_rank_display: "Current Rank",
          not_ranked: "Not Ranked",
          guest_mode: "Guest Mode",
          guest_mode_desc:
            "You are currently playing as a guest, game results will not be recorded in leaderboard.",
          login_benefits: "After login, enjoy:",
          benefit_stats: "• 📊 Game data statistics",
          benefit_leaderboard: "• 🏆 Participate in leaderboard competition",
          benefit_pi_service: "• 💰 Pi coin value-added services",
          benefit_monthly_rewards: "• 🎁 Monthly reward activities",
          play_again: "Play Again",
          view_leaderboard: "View Leaderboard",
          login_now: "Login Now",

          // 游戏界面
          return_to_menu: "Return",
          guest_mode_short: "🎮 Guest Mode",
          ai_battle_title: "🧠 AI Battle",
          player_label: "Player",
          ai_label: "AI",
          vs_label: "VS",
          undo_button: "Undo",
          new_game_button: "New Game",

          // 悔棋相关
          undo_confirm: "Undo Confirmation",
          undo_confirm_message:
            "Undo requires 0.1 π\nCurrent balance: {0} π\n\nConfirm undo?",
          undo_success_title: "Undo Successful",
          undo_success_detail: "Consumed 0.1 π, balance: {0} π",
          undo_failed_title: "Undo Failed",
          undo_failed_message: "Payment failed",
          insufficient_balance_undo:
            "Undo requires 0.1 π, current balance {0} π, insufficient balance.\n\nWould you like to recharge?",
          continue_game_tip:
            "You can continue the current game, but cannot restart. Unlock this feature after recharging.",

          // 充值相关
          recharge_dialog_title: "💰 Account Recharge",
          payment_dialog_title: "💳 Pi Coin Payment",
          recharge_amount_display: "Recharge {0} π",
          order_id_display: "Order ID: {0}",
          custom_amount_error:
            "Please enter a valid recharge amount (minimum 0.1π)",

          // 个人中心详细内容
          monthly_reward_reminder: "🏆 Monthly Reward Reminder",
          monthly_reward_desc:
            "50% of monthly profits will be distributed to the top three players as rewards",

          // 月度奖励详细说明
          reward_settlement_detail:
            "Settlement on the last hour of the last day of each month",
          reward_pool_50_percent:
            "Reward pool is 50% of platform's monthly profit",
          reward_example_detail:
            "Example: Monthly profit 100π, reward pool 50π",
          reward_distribution_manual:
            "Distributed manually according to wallet address saved in personal center",
          reward_wallet_valid:
            "Winners must ensure wallet address is correct and valid",
          reward_next_day:
            "Rewards will be distributed the day after settlement",
          reward_invalid_rollover:
            "If wallet address is invalid, rewards will be rolled over to next month",
          reward_example_calculation:
            "💡 Example: Monthly profit 100π, reward pool 50π",
          first_place_reward: "🥇First place: 25π",
          second_place_reward: "🥈Second place: 15π",
          third_place_reward: "🥉Third place: 10π",

          // 全球排行榜
          global_ranking_title: "Global Ranking",
          ranking_subtitle: "📊 Ranking based on monthly win rate",
          ranking_header_rank: "Rank",
          ranking_header_nickname: "Nickname",
          ranking_header_games: "Total Games",
          ranking_header_winrate: "Win Rate",

          // 个人中心详细标签
          personal_profile_section: "Personal Profile",
          avatar_nickname_section: "Avatar and Nickname",
          click_avatar_edit: "Click avatar to edit",
          click_nickname_edit: "Click nickname to edit",
          account_info_section: "Account Information",
          game_stats_section: "Game Statistics",
          wallet_address_label: "Wallet Address",
          account_balance_display: "Account Balance",
          refresh_balance_btn: "Refresh Balance",
          logout_btn: "Logout",

          // 游戏统计标签
          total_games_label: "Total Games",
          wins_label: "Wins",
          win_rate_label: "Win Rate",
          current_score_label: "Current Score",
          current_rank_label: "Current Rank",

          // 余额查询状态
          balance_querying: "Querying...",
          balance_query_failed_display: "Query Failed",
          balance_tooltip: "Total Recharged: {0} π\nTotal Spent: {1} π",

          // 支付成功信息
          payment_success_title: "Payment Successful",
          payment_success_message: "Payment Successful!",
          purchase_success_message: "You have successfully purchased {0}",
          transaction_id: "Transaction ID: {0}",

          // 个人中心输入提示
          enter_avatar_emoji: "Enter emoji avatar (e.g.: 😊)",
          click_to_set_nickname: "Click to set nickname",
          enter_your_nickname: "Enter your nickname",
          loading_text_display: "Loading...",
          refresh_balance_text: "🔄 Refresh Balance",
          recharge_text: "💰 Recharge",
          wallet_format_hint:
            "Wallet address format: 50 uppercase letters and numbers",
          save_wallet: "💾 Save",
          edit_wallet: "✏️ Edit",
          logout_account_text: "↩️ Logout",

          // 个人中心提示信息
          enter_avatar_hint: "Please enter avatar emoji",
          single_emoji_hint: "Please enter a single emoji",
          avatar_updated: "Avatar updated!",
          nickname_updated: "Nickname updated!",
          enter_wallet_hint: "Please enter wallet address",
          wallet_length_error:
            "❌ This is not a standard wallet address!\n\nCurrent length: {0} characters\nStandard length: 50 characters\n\nPlease enter a complete 50-character wallet address",
          wallet_format_error:
            "❌ Wallet address format error!\n\nOnly uppercase letters (A-Z) and numbers (0-9) are allowed\nPlease check your input",
          wallet_saved_success: "✅ Wallet address saved successfully!",
          edit_mode_title: "Edit Mode",
          edit_mode_message:
            "💡 Edit mode enabled\n\nPlease modify the wallet address and click save",
          success_title: "Success",
          error_title: "Error",

          // 游戏结束相关
          you_win: "🎉 Congratulations! You win!",
          you_lose: "😔 AI wins, keep trying!",
          draw: "🤝 Draw!",
          game_over: "Game Over",

          // 主界面按钮
          global_ranking: "Global Ranking",
          ai_battle: "AI Battle",
          personal_center: "Personal Center",
          game_instructions: "Game Instructions",

          // 连接错误
          connection_failed: "Connection Failed",
          connection_error_detail:
            "Unable to connect to Pi Network, please check your network connection and try again",
          login_with_pi: "Login with Pi Account",
          login_benefits_note:
            "Login to enjoy full game features and Pi coin rewards",

          // 充值对话框
          recharge_amount_selection: "Recharge Amount Selection",
          custom_amount_placeholder: "Custom Amount",
          custom_recharge: "Custom Recharge",
          cancel: "Cancel",

          // 错误提示
          please_login_first: "Please login first",
          create_order_failed: "Failed to create order",
          network_error_retry: "Network error, please try again later",

          // 支付对话框
          payment_method: "Payment Method",
          pi_wallet_transfer: "📱 Pi Wallet Transfer",
          transfer_instruction:
            "Please use Pi wallet to transfer to the following address:",
          transfer_amount_warning:
            "⚠️ Please ensure the transfer amount is <strong>{0} π</strong>",
          transfer_memo: "Transfer memo: {0}",
          transaction_hash_placeholder: "Please enter transaction hash",
          transaction_hash_instruction:
            "After transfer completion, please copy the transaction hash from Pi wallet and paste it in the input box above",
          verify_payment: "Verify Payment",
          order_validity: "Order validity: 30 minutes",

          // 支付验证
          please_enter_transaction_hash: "Please enter transaction hash",
          recharge_success: "Recharge Successful",
          recharge_success_message:
            "Congratulations! Recharge {0} π successful!\nCurrent balance: {1} π",
          verification_failed: "Verification Failed",

          // 游戏流程确认
          timeout_game_over: "⏰ Thinking timeout, game failed!",
          login_success: "Login Successful",
          welcome_user: "Welcome, {0}",
          abandon_current_game: "Abandon Current Game",
          abandon_game_warning:
            "Current game is in progress, restarting will be recorded as a loss.\n\nAre you sure you want to abandon the current game?",
          restart_game: "Restart Game",
          restart_game_confirm: "Are you sure you want to restart?",
          abandon_game_return_warning:
            "Current game is in progress, returning to main menu will be recorded as a loss.\n\nAre you sure you want to abandon the current game?",

          // 胜负显示格式
          wins_losses_format: "({0}W {1}L)",
          monthly_games: "Monthly Games",
          play_again: "Play Again",
          view_leaderboard: "View Leaderboard",
          login_now: "Login Now",
          guest_mode: "Guest Mode",
          guest_mode_desc:
            "You are currently playing as a guest, game results will not be recorded on the leaderboard.",
          login_benefits: "Benefits after login:",
          benefit_stats: "• 📊 Game statistics",
          benefit_leaderboard: "• 🏆 Participate in leaderboard competition",
          benefit_pi_service: "• 💰 Pi coin value-added services",
          benefit_monthly_rewards: "• 🎁 Monthly reward activities",
          rank_position: "#{0}",
        },

        ko: {
          // 기본 인터페이스
          noscript:
            "이 애플리케이션을 실행하려면 JavaScript를 활성화해야 합니다.",
          game_title: "오목",
          game_subtitle: "pinetwork 블록체인에서 실행되는 오목 게임",
          global_ranking: "글로벌 순위",
          ai_battle: "AI 대전",
          personal_center: "개인 센터",
          game_instructions: "게임 설명",
          error_message: "❌ 오류 메시지",
          login_with_pi: "Pi Network로 로그인",
          login_note:
            "로그인을 클릭하면 Pi Network 계정을 사용한 인증에 동의하는 것입니다",

          // 언어 옵션
          lang_zh: "中文",
          lang_en: "English",
          lang_ko: "한국어",
          lang_ja: "日本語",
          lang_vi: "Tiếng Việt",

          // 게임 관련
          current_player: "현재 플레이어",
          your_turn: "당신의 차례",
          opponent_turn: "상대방의 차례",
          ai_thinking: "🤖 AI가 생각 중...",
          thinking_time: "⏱️ 생각 시간: {0}초",
          remaining_time: "⚠️ 남은 시간: {0}초",
          timeout_warning: "🚨 시간 초과 경고: {0}초",
          timeout: "⏰ 시간 초과",

          // 게임 결과
          you_win: "🎉 축하합니다! 승리!",
          you_lose: "😔 죄송합니다, 패배",
          draw: "🤝 무승부",
          game_over: "게임 종료",

          // 버튼 및 작업
          new_game: "새 게임",
          undo: "무르기",
          restart: "다시 시작",
          back_to_menu: "메뉴로 돌아가기",
          confirm: "확인",
          cancel: "취소",
          close: "닫기",
          save: "저장",
          update: "업데이트",
          enter_game: "게임 시작",

          // 개인 센터
          personal_info: "개인 정보",
          game_stats: "게임 통계",
          total_games: "총 게임 수",
          wins: "승리",
          losses: "패배",
          win_rate: "승률",
          current_rank: "현재 순위",
          wallet_address: "지갑 주소",
          balance: "잔액",
          nickname: "닉네임",
          avatar: "아바타",

          // 오류 및 알림
          connection_failed: "연결 실패",
          network_error: "네트워크 오류, 연결을 확인하고 다시 시도하세요",
          login_failed: "로그인 실패",
          insufficient_balance: "잔액 부족",
          invalid_move: "유효하지 않은 수",
          game_not_started: "게임이 시작되지 않음",

          // 결제 관련
          payment_confirm: "결제 확인",
          payment_success: "결제 성공",
          payment_failed: "결제 실패",
          payment_cancelled: "결제 취소됨",
          recharge: "충전",

          // 순위표
          leaderboard: "순위표",
          rank: "순위",
          player: "플레이어",
          score: "점수",
          games_played: "플레이한 게임",

          // 기타
          loading: "로딩 중...",
          connecting: "연결 중...",
          please_wait: "잠시 기다려 주세요...",
          success: "성공",
          failed: "실패",
          connecting_pi_network: "Pi Network 연결 중...",
          entering_game: "게임 진입 중...",

          // 팝업 및 알림
          hint: "힌트",
          confirm_purchase: "구매 확인",
          confirm_payment: "결제 확인",
          payment_amount: "{0} π",
          enter_nickname: "닉네임을 입력하세요",
          nickname_too_long: "닉네임은 20자를 초과할 수 없습니다",
          nickname_forbidden:
            "닉네임에 금지된 단어가 포함되어 있습니다. 다시 입력하세요",
          logout_confirm: "로그아웃 확인",
          logout_message:
            "정말 로그아웃하시겠습니까? 모든 로컬 저장 데이터가 삭제됩니다.",
          logout_success: "로그아웃 성공",
          logout_success_message: "성공적으로 로그아웃되었습니다!",
          please_login_first: "먼저 로그인하세요",

          // 게임 설명
          game_instructions_title: "게임 설명",
          game_history_title: "오목 역사",
          game_history_desc:
            '전설에 따르면 오목은 4000여 년 전 요 황제 시대에 탄생했습니다. 요 황제가 아들 단주를 교육하기 위해 돌바둑을 발명했고, 후에 순 황제가 "오성연주" 놀이로 개량하여 점차 현대 오목의 원형을 형성했습니다.\n요순 시대의 민속 게임에서 남북조 시대 동아시아로 전파되고, 일본에서 경기 스포츠로 개량되어 최종적으로 세계적인 바둑 프로젝트가 되었습니다.',

          // 게임 설명 상세 내용
          game_history_section: "오목 역사 유래",
          game_rules_section: "게임 규칙",
          game_rules_title: "🎯 기본 규칙",

          // 개인 센터
          personal_center_title: "개인 센터",
          wallet_address_placeholder: "50자 지갑 주소 입력 (대문자와 숫자)",
          wallet_address_format: "지갑 주소 형식: 50자 대문자와 숫자",

          // 결제 관련
          insufficient_balance_title: "잔액 부족",
          insufficient_balance_message:
            "무르기에는 0.1 π가 필요하며, 현재 잔액 {0} π, 잔액이 부족합니다.\n\n충전하시겠습니까?",
          recharge_prompt:
            "게임 계정에 Pi 코인을 충전하고 더 많은 게임 기능을 즐기세요!",
          continue_without_recharge:
            "현재 게임을 계속할 수 있지만 다시 시작할 수 없습니다. 충전 후 이 기능을 잠금 해제하세요.",
          undo_success: "무르기 성공",
          undo_success_message: "0.1 π 소모, 잔액: {0} π",
          undo_failed: "무르기 실패",
          network_error_retry: "네트워크 오류, 나중에 다시 시도하세요",
          invalid_amount: "유효한 충전 금액을 입력하세요 (최소 0.1π)",

          // 아이템 이름
          item_hint: "힌트 아이템",
          item_undo: "무르기 티켓",
          item_theme: "테마 팩",
          item_vip: "VIP 멤버십",
          item_unknown: "알 수 없는 아이템",

          // 순위표 및 통계
          current_ranking: "🎯 현재 순위: #{0} | ({1}승{2}패) | 승률: {3}%",
          leaderboard_update_tip:
            "순위표가 실시간으로 업데이트됩니다. 계속 게임하여 순위를 올리세요!",

          // 승률 순위 시스템
          score_system: "🏆 승률 순위 시스템",
          initial_score: "순위 기준: 승률 순으로 정렬",
          win_score: "승리: 승률 향상",
          draw_score: "무승부: 승률에 영향",
          lose_score: "패배: 승률 감소",
          quit_score: "포기/타임아웃: 패배로 기록",

          // 월간 순위 규칙
          monthly_ranking_rules: "🎯 월간 순위 규칙:",
          ranking_requirement: "• 순위 참여에는 최소 1게임 필요",
          ranking_criteria: "• 승률 순으로 순위 결정, 동률 시 승수로 정렬",

          // 게임 설명 상세 규칙
          basic_rules_detail_1:
            "15×15 바둑판에서 플레이어는 흑돌, AI는 백돌을 사용합니다",
          basic_rules_detail_2:
            "양측이 번갈아 돌을 놓으며, 먼저 5개를 연결하는 쪽이 승리합니다",
          basic_rules_detail_3:
            "5개 돌은 가로, 세로, 대각선 어느 방향이든 연결 가능합니다",
          basic_rules_detail_4:
            "바둑판이 가득 차도 승부가 나지 않으면 무승부입니다",

          // 턴 시간 규칙
          turn_time_rules: "⏱️ 턴 시간 규칙",
          thinking_time_rule: "사고 시간: 턴당 60초 사고 시간",
          time_warning_rule: "시간 알림: 30초 남으면 노란색 경고",
          urgent_warning_rule: "긴급 알림: 마지막 10초에 빨간색 깜빡임",
          timeout_rule: "시간 초과 패배: 시간 초과 시 자동으로 패배 기록",

          // 게임 조작 상세
          game_operations: "🎮 게임 조작",
          place_stone: "돌 놓기: 빈 칸을 클릭하여 돌 놓기",
          undo_move:
            "무르기: 최근 한 수를 취소할 수 있음 (플레이어+AI 각각 한 수)",
          new_game_op: "새 게임: 다시 시작, 진행 중인 게임은 패배로 기록",
          return_op: "돌아가기: 게임 종료, 진행 중인 게임은 패배로 기록",

          // 점수 시스템
          score_system: "🏆 100점 생명력 시스템",
          initial_score: "초기 점수: 100점",
          win_score: "승리: +1점",
          draw_score: "무승부: 변화 없음",
          lose_score: "패배: -1점 (0점까지 차감)",
          quit_score: "포기/시간 초과: -1점",

          // 월간 순위 규칙
          monthly_ranking_rules: "🎯 월간 순위 규칙:",
          ranking_requirement: "• 순위 참여를 위해 최소 60게임 필요",
          ranking_criteria: "• 남은 점수 순으로 순위 결정, 동점 시 승률로 정렬",
          ranking_rewards: "• 월말 순위에 따라 보상 지급",
          anti_farming:
            "⚠️ 점수 조작 방지: 게임을 하지 않거나 너무 적게 한 플레이어는 순위에서 제외",

          // 월간 보상 규칙
          monthly_rewards: "🏆 월간 보상 규칙",
          reward_pool_allocation: "💰 보상 풀 배분",
          reward_settlement: "매월 마지막 날 마지막 시간에 정산",
          reward_pool_percentage: "보상 풀은 플랫폼 월간 수익의 50%",
          reward_example: "예: 월간 수익 100π, 보상 풀 50π",

          // 상위 3명 배분
          top_three_distribution: "🥇 상위 3명 배분 비율",
          first_place: "🥇 1등",
          second_place: "🥈 2등",
          third_place: "🥉 3등",

          // 지급 방식
          distribution_method: "📋 지급 방식",
          wallet_distribution: "개인 센터에 저장된 지갑 주소로 수동 지급",
          valid_wallet_required:
            "수상자는 지갑 주소가 정확하고 유효한지 확인해야 함",
          next_day_distribution: "보상은 정산 다음 날 지급됩니다",
          invalid_wallet_rollover:
            "지갑 주소가 유효하지 않으면 보상은 다음 달로 이월됩니다",

          // 순위표 규칙
          leaderboard_rules: "📊 순위표 규칙",
          ranking_condition: "순위 조건: 60게임 완료 시 순위표 등재",
          ranking_basis: "순위 기준: 누적 점수 순으로 정렬",
          data_statistics: "데이터 통계: 역사적 누적 데이터 기반",
          realtime_update: "실시간 업데이트: 각 게임 종료 후 즉시 업데이트",

          // 따뜻한 팁
          warm_tips:
            "🎋 천년의 지혜를 계승하고, 고전 바둑의 아름다움을 경험하세요\n💡 시간을 합리적으로 배분하고, 사고의 즐거움을 만끽하세요",

          // 게임 결과 관련
          game_result: "게임 결과",
          congratulations_win: "🎉 축하합니다! 승리!",
          sorry_lose: "😔 죄송합니다, 패배했습니다",
          draw_result: "🤝 무승부",
          current_score: "현재 점수",
          win_rate_display: "승률",
          total_games_display: "총 게임 수",
          current_rank_display: "현재 순위",
          not_ranked: "순위 없음",
          guest_mode: "게스트 모드",
          guest_mode_desc:
            "현재 게스트로 게임 중이며, 게임 결과는 순위표에 기록되지 않습니다.",
          login_benefits: "로그인 후 혜택:",
          benefit_stats: "• 📊 게임 데이터 통계",
          benefit_leaderboard: "• 🏆 순위표 경쟁 참여",
          benefit_pi_service: "• 💰 Pi 코인 부가 서비스",
          benefit_monthly_rewards: "• 🎁 월간 보상 활동",
          play_again: "다시 플레이",
          view_leaderboard: "순위표 보기",
          login_now: "지금 로그인",

          // 게임 인터페이스
          return_to_menu: "돌아가기",
          guest_mode_short: "🎮 게스트 모드",
          ai_battle_title: "🧠 AI 대전",
          player_label: "플레이어",
          ai_label: "AI",
          vs_label: "VS",
          undo_button: "무르기",
          new_game_button: "새 게임",

          // 무르기 관련
          undo_confirm: "무르기 확인",
          undo_confirm_message:
            "무르기에는 0.1 π가 필요합니다\n현재 잔액: {0} π\n\n무르기를 확인하시겠습니까?",
          undo_success_title: "무르기 성공",
          undo_success_detail: "0.1 π 소모, 잔액: {0} π",
          undo_failed_title: "무르기 실패",
          undo_failed_message: "결제 실패",
          insufficient_balance_undo:
            "무르기에는 0.1 π가 필요하며, 현재 잔액 {0} π, 잔액이 부족합니다.\n\n충전하시겠습니까?",
          continue_game_tip:
            "현재 게임을 계속할 수 있지만 다시 시작할 수 없습니다. 충전 후 이 기능을 잠금 해제하세요.",

          // 충전 관련
          recharge_dialog_title: "💰 계정 충전",
          payment_dialog_title: "💳 Pi 코인 결제",
          recharge_amount_display: "충전 {0} π",
          order_id_display: "주문 번호: {0}",
          custom_amount_error: "유효한 충전 금액을 입력하세요 (최소 0.1π)",

          // 개인 센터 상세 내용
          monthly_reward_reminder: "🏆 월간 보상 알림",
          monthly_reward_desc:
            "월간 수익의 50%가 상위 3명 플레이어에게 보상으로 배분됩니다",

          // 월간 보상 상세 설명
          reward_settlement_detail: "매월 마지막 날 마지막 시간에 정산",
          reward_pool_50_percent: "보상 풀은 플랫폼 월간 수익의 50%",
          reward_example_detail: "예: 월간 수익 100π, 보상 풀 50π",
          reward_distribution_manual:
            "개인 센터에 저장된 지갑 주소로 수동 지급",
          reward_wallet_valid:
            "수상자는 지갑 주소가 정확하고 유효한지 확인해야 함",
          reward_next_day: "보상은 정산 다음 날 지급됩니다",
          reward_invalid_rollover:
            "지갑 주소가 유효하지 않으면 보상은 다음 달로 이월됩니다",
          reward_example_calculation: "💡 예시: 월간 수익 100π, 보상 풀 50π",
          first_place_reward: "🥇1등: 25π",
          second_place_reward: "🥈2등: 15π",
          third_place_reward: "🥉3등: 10π",

          // 전역 순위표
          global_ranking_title: "글로벌 순위",
          ranking_subtitle: "📊 월간 승률 기반 순위",
          ranking_header_rank: "순위",
          ranking_header_nickname: "닉네임",
          ranking_header_games: "총 게임",
          ranking_header_winrate: "승률",
          current_rank_not_listed: "현재 순위: 미등재",
          current_rank_label: "현재 순위",
          not_listed: "미등재",
          play_one_game_to_rank:
            "🎮 1게임 완료하면 순위표에 등재됩니다! 오목 여행을 시작하세요!",

          // 개인 센터 상세 라벨
          personal_profile_section: "개인 프로필",
          avatar_nickname_section: "아바타와 닉네임",
          click_avatar_edit: "아바타 클릭하여 편집",
          click_nickname_edit: "닉네임 클릭하여 편집",
          account_info_section: "계정 정보",
          game_stats_section: "게임 통계",
          wallet_address_label: "지갑 주소",
          account_balance_display: "계정 잔액",
          refresh_balance_btn: "잔액 새로고침",
          logout_btn: "로그아웃",

          // 게임 통계 라벨
          total_games_label: "총 게임",
          wins_label: "승리",
          win_rate_label: "승률",
          current_score_label: "현재 점수",
          current_rank_label: "현재 순위",

          // 잔액 조회 상태
          balance_querying: "조회 중...",
          balance_query_failed_display: "조회 실패",
          balance_tooltip: "총 충전: {0} π\n총 소비: {1} π",

          // 결제 성공 정보
          payment_success_title: "결제 성공",
          payment_success_message: "결제 성공!",
          purchase_success_message: "{0}을(를) 성공적으로 구매했습니다",
          transaction_id: "거래 ID: {0}",

          // 개인 센터 입력 힌트
          enter_avatar_emoji: "이모지 아바타 입력 (예: 😊)",
          click_to_set_nickname: "닉네임 설정하려면 클릭",
          enter_your_nickname: "닉네임을 입력하세요",
          loading_text_display: "로딩 중...",
          refresh_balance_text: "🔄 잔액 새로고침",
          recharge_text: "💰 충전",
          wallet_format_hint: "지갑 주소 형식: 50자 대문자와 숫자",
          save_wallet: "💾 저장",
          edit_wallet: "✏️ 편집",
          logout_account_text: "↩️ 계정 로그아웃",

          // 개인 센터 힌트 정보
          enter_avatar_hint: "아바타 이모지를 입력하세요",
          single_emoji_hint: "단일 이모지를 입력하세요",
          avatar_updated: "아바타가 업데이트되었습니다!",
          nickname_updated: "닉네임이 업데이트되었습니다!",
          enter_wallet_hint: "지갑 주소를 입력하세요",
          wallet_length_error:
            "❌ 표준 지갑 주소가 아닙니다!\n\n현재 길이: {0}자\n표준 길이: 50자\n\n완전한 50자 지갑 주소를 입력하세요",
          wallet_format_error:
            "❌ 지갑 주소 형식 오류!\n\n대문자(A-Z)와 숫자(0-9)만 허용됩니다\n입력 내용을 확인하세요",
          wallet_saved_success: "✅ 지갑 주소가 성공적으로 저장되었습니다!",
          edit_mode_title: "편집 모드",
          edit_mode_message:
            "💡 편집 모드가 활성화되었습니다\n\n지갑 주소를 수정한 후 저장을 클릭하세요",
          success_title: "성공",
          error_title: "오류",

          // 게임 종료 관련
          you_win: "🎉 축하합니다! 승리!",
          you_lose: "😔 AI가 승리했습니다, 다시 도전하세요!",
          draw: "🤝 무승부!",
          game_over: "게임 종료",

          // 메인 인터페이스 버튼
          global_ranking: "글로벌 순위",
          ai_battle: "AI 대전",
          personal_center: "개인 센터",
          game_instructions: "게임 설명",

          // 연결 오류
          connection_failed: "연결 실패",
          connection_error_detail:
            "Pi Network에 연결할 수 없습니다. 네트워크 연결을 확인한 후 다시 시도하세요",
          login_with_pi: "Pi 계정으로 로그인",
          login_benefits_note:
            "로그인 후 완전한 게임 기능과 Pi 코인 보상을 즐기세요",

          // 충전 대화상자
          recharge_amount_selection: "충전 금액 선택",
          custom_amount_placeholder: "사용자 정의 금액",
          custom_recharge: "사용자 정의 충전",
          cancel: "취소",

          // 오류 알림
          please_login_first: "먼저 로그인하세요",
          create_order_failed: "주문 생성 실패",
          network_error_retry: "네트워크 오류, 나중에 다시 시도하세요",
          pi_login_failed: "Pi Network 로그인 실패",
          login_error: "로그인 중 오류 발생",
          pi_sdk_not_loaded:
            "Pi Network SDK가 로드되지 않아 결제 기능을 사용할 수 없습니다",
          create_payment_failed: "결제 생성 실패",

          // 결제 대화상자
          payment_method: "결제 방법",
          pi_wallet_transfer: "📱 Pi 지갑 송금",
          transfer_instruction: "Pi 지갑을 사용하여 다음 주소로 송금하세요:",
          transfer_amount_warning:
            "⚠️ 송금 금액이 <strong>{0} π</strong>인지 확인하세요",
          transfer_memo: "송금 메모: {0}",
          transaction_hash_placeholder: "거래 해시를 입력하세요",
          transaction_hash_instruction:
            "송금 완료 후 Pi 지갑에서 거래 해시를 복사하여 위 입력란에 붙여넣으세요",
          verify_payment: "결제 확인",
          order_validity: "주문 유효기간: 30분",

          // 결제 확인
          please_enter_transaction_hash: "거래 해시를 입력하세요",
          recharge_success: "충전 성공",
          recharge_success_message:
            "축하합니다! {0} π 충전 성공!\n현재 잔액: {1} π",
          verification_failed: "확인 실패",

          // 게임 흐름 확인
          timeout_game_over: "⏰ 사고 시간 초과, 게임 실패!",
          login_success: "로그인 성공",
          welcome_user: "환영합니다, {0}",
          abandon_current_game: "현재 게임 포기",
          abandon_game_warning:
            "현재 게임이 진행 중입니다. 다시 시작하면 패배로 기록됩니다.\n\n현재 게임을 포기하시겠습니까?",
          restart_game: "게임 다시 시작",
          restart_game_confirm: "다시 시작하시겠습니까?",
          abandon_game_return_warning:
            "현재 게임이 진행 중입니다. 메인 메뉴로 돌아가면 패배로 기록됩니다.\n\n현재 게임을 포기하시겠습니까?",

          // 승부 표시 형식
          wins_losses_format: "({0}승{1}패)",
          monthly_games: "월간 게임",
          play_again: "다시 플레이",
          view_leaderboard: "순위표 보기",
          login_now: "지금 로그인",
          guest_mode: "게스트 모드",
          guest_mode_desc:
            "현재 게스트로 게임 중이며, 게임 결과는 순위표에 기록되지 않습니다.",
          login_benefits: "로그인 후 혜택:",
          benefit_stats: "• 📊 게임 통계",
          benefit_leaderboard: "• 🏆 순위표 경쟁 참여",
          benefit_pi_service: "• 💰 Pi 코인 부가가치 서비스",
          benefit_monthly_rewards: "• 🎁 월간 보상 활동",
          rank_position: "#{0}위",
        },

        ja: {
          // 基本インターフェース
          noscript:
            "このアプリケーションを実行するにはJavaScriptを有効にする必要があります。",
          game_title: "五目並べ",
          game_subtitle: "pinetworkブロックチェーン上で動作する五目並べゲーム",
          global_ranking: "グローバルランキング",
          ai_battle: "AI対戦",
          personal_center: "個人センター",
          game_instructions: "ゲーム説明",
          error_message: "❌ エラーメッセージ",
          login_with_pi: "Pi Networkでログイン",
          login_note:
            "ログインをクリックすると、Pi Networkアカウントを使用した認証に同意したことになります",

          // 言語オプション
          lang_zh: "中文",
          lang_en: "English",
          lang_ko: "한국어",
          lang_ja: "日本語",
          lang_vi: "Tiếng Việt",

          // ゲーム関連
          current_player: "現在のプレイヤー",
          your_turn: "あなたの番",
          opponent_turn: "相手の番",
          ai_thinking: "🤖 AIが考え中...",
          thinking_time: "⏱️ 思考時間: {0}秒",
          remaining_time: "⚠️ 残り時間: {0}秒",
          timeout_warning: "🚨 タイムアウト警告: {0}秒",
          timeout: "⏰ タイムアウト",

          // ゲーム結果
          you_win: "🎉 おめでとうございます！勝利！",
          you_lose: "😔 残念、敗北",
          draw: "🤝 引き分け",
          game_over: "ゲーム終了",

          // ボタンと操作
          new_game: "新しいゲーム",
          undo: "待った",
          restart: "再開",
          back_to_menu: "メニューに戻る",
          confirm: "確認",
          cancel: "キャンセル",
          close: "閉じる",
          save: "保存",
          update: "更新",
          enter_game: "ゲーム開始",

          // 個人センター
          personal_info: "個人情報",
          game_stats: "ゲーム統計",
          total_games: "総ゲーム数",
          wins: "勝利",
          losses: "敗北",
          win_rate: "勝率",
          current_rank: "現在のランク",
          wallet_address: "ウォレットアドレス",
          balance: "残高",
          nickname: "ニックネーム",
          avatar: "アバター",

          // エラーと通知
          connection_failed: "接続失敗",
          network_error: "ネットワークエラー、接続を確認して再試行してください",
          login_failed: "ログイン失敗",
          insufficient_balance: "残高不足",
          invalid_move: "無効な手",
          game_not_started: "ゲームが開始されていません",

          // 支払い関連
          payment_confirm: "支払い確認",
          payment_success: "支払い成功",
          payment_failed: "支払い失敗",
          payment_cancelled: "支払いキャンセル",
          recharge: "チャージ",

          // ランキング
          leaderboard: "ランキング",
          rank: "ランク",
          player: "プレイヤー",
          score: "スコア",
          games_played: "プレイしたゲーム",

          // その他
          loading: "読み込み中...",
          connecting: "接続中...",
          please_wait: "お待ちください...",
          success: "成功",
          failed: "失敗",
          connecting_pi_network: "Pi Networkに接続中...",
          entering_game: "ゲーム開始中...",

          // ポップアップと通知
          hint: "ヒント",
          confirm_purchase: "購入確認",
          confirm_payment: "支払い確認",
          payment_amount: "{0} π",
          enter_nickname: "ニックネームを入力してください",
          nickname_too_long: "ニックネームは20文字を超えることはできません",
          nickname_forbidden:
            "ニックネームに禁止された単語が含まれています。再入力してください",
          logout_confirm: "ログアウト確認",
          logout_message:
            "本当にログアウトしますか？すべてのローカル保存データが削除されます。",
          logout_success: "ログアウト成功",
          logout_success_message: "正常にログアウトしました！",
          please_login_first: "まずログインしてください",

          // ゲーム説明
          game_instructions_title: "ゲーム説明",
          game_history_title: "五目並べの歴史",
          game_history_desc:
            "伝説によると、五目並べは4000年以上前の堯帝時代に誕生しました。堯帝が息子の丹朱を教育するために石子棋を発明し、後に舜帝が「五星連珠」の遊び方に改良して、徐々に現代五目並べの原型を形成しました。\n堯舜時代の民俗ゲームから、南北朝時代に東アジアに伝播し、日本で競技スポーツに改良され、最終的に世界的な棋類プロジェクトとなりました。",

          // ゲーム説明詳細内容
          game_history_section: "五目並べ歴史の由来",
          game_rules_section: "ゲームルール",
          game_rules_title: "🎯 基本ルール",

          // 個人センター
          personal_center_title: "個人センター",
          wallet_address_placeholder:
            "50文字のウォレットアドレスを入力（大文字と数字）",
          wallet_address_format: "ウォレットアドレス形式：50文字の大文字と数字",

          // 支払い関連
          insufficient_balance_title: "残高不足",
          insufficient_balance_message:
            "待ったには0.1 πが必要で、現在の残高{0} π、残高が不足しています。\n\nチャージしますか？",
          recharge_prompt:
            "ゲームアカウントにPiコインをチャージして、より多くのゲーム機能をお楽しみください！",
          continue_without_recharge:
            "現在のゲームを続けることはできますが、再開はできません。チャージ後にこの機能のロックを解除してください。",
          undo_success: "待った成功",
          undo_success_message: "0.1 π消費、残高：{0} π",
          undo_failed: "待った失敗",
          network_error_retry: "ネットワークエラー、後でもう一度お試しください",
          invalid_amount: "有効なチャージ金額を入力してください（最低0.1π）",

          // アイテム名
          item_hint: "ヒントアイテム",
          item_undo: "待ったチケット",
          item_theme: "テーマパック",
          item_vip: "VIPメンバーシップ",
          item_unknown: "不明なアイテム",

          // ランキングと統計
          current_ranking: "🎯 現在のランク: #{0} | ({1}勝{2}敗) | 勝率: {3}%",
          leaderboard_update_tip:
            "ランキングはリアルタイムで更新されます。ゲームを続けてランクを上げましょう！",

          // ゲーム説明詳細ルール
          basic_rules_detail_1:
            "15×15の盤面で、プレイヤーは黒石、AIは白石を使用します",
          basic_rules_detail_2:
            "両者が交互に石を置き、先に5つを連結した方が勝利です",
          basic_rules_detail_3:
            "5つの石は横、縦、斜めのいずれの方向でも連結可能です",
          basic_rules_detail_4:
            "盤面が満杯になっても勝負がつかない場合は引き分けです",

          // ターン時間ルール
          turn_time_rules: "⏱️ ターン時間ルール",
          thinking_time_rule: "思考時間：ターンごとに60秒の思考時間",
          time_warning_rule: "時間警告：残り30秒で黄色警告",
          urgent_warning_rule: "緊急警告：最後の10秒で赤色点滅",
          timeout_rule: "タイムアウト敗北：タイムアウト時は自動的に敗北記録",

          // ゲーム操作詳細
          game_operations: "🎮 ゲーム操作",
          place_stone: "石を置く：空いているマスをクリックして石を置く",
          undo_move:
            "待った：最近の一手を取り消すことができます（プレイヤー+AI各一手）",
          new_game_op: "新しいゲーム：再開始、進行中のゲームは敗北として記録",
          return_op: "戻る：ゲーム終了、進行中のゲームは敗北として記録",

          // スコアシステム
          score_system: "🏆 勝率ランキングシステム",
          initial_score: "ランキング基準：勝率順でソート",
          win_score: "勝利：勝率向上",
          draw_score: "引き分け：勝率に影響",
          lose_score: "敗北：勝率低下",
          quit_score: "放棄/タイムアウト：敗北として記録",

          // 月間ランキングルール
          monthly_ranking_rules: "🎯 月間ランキングルール：",
          ranking_requirement: "• ランキング参加には最低1ゲームが必要",
          ranking_criteria:
            "• 残りポイント順でランキング決定、同点時は勝率でソート",
          ranking_rewards: "• 月末にランキングに応じて報酬配布",
          anti_farming:
            "⚠️ スコア操作防止：ゲームをしないか少なすぎるプレイヤーはランキングから除外",

          // 月間報酬ルール
          monthly_rewards: "🏆 月間報酬ルール",
          reward_pool_allocation: "💰 報酬プール配分",
          reward_settlement: "毎月最終日の最終時間に決算",
          reward_pool_percentage: "報酬プールはプラットフォーム月間利益の50%",
          reward_example: "例：月間利益100π、報酬プール50π",

          // トップ3配分
          top_three_distribution: "🥇 トップ3配分比率",
          first_place: "🥇 1位",
          second_place: "🥈 2位",
          third_place: "🥉 3位",

          // 配布方式
          distribution_method: "📋 配布方式",
          wallet_distribution:
            "個人センターに保存されたウォレットアドレスに手動配布",
          valid_wallet_required:
            "受賞者はウォレットアドレスが正確で有効であることを確認する必要があります",
          next_day_distribution: "報酬は決算翌日に配布されます",
          invalid_wallet_rollover:
            "ウォレットアドレスが無効な場合、報酬は翌月に繰り越されます",

          // ランキングルール
          leaderboard_rules: "📊 ランキングルール",
          ranking_condition: "ランキング条件：60ゲーム完了でランキング掲載",
          ranking_basis: "ランキング基準：累積ポイント順でソート",
          data_statistics: "データ統計：歴史的累積データに基づく",
          realtime_update: "リアルタイム更新：各ゲーム終了後即座に更新",

          // 温かいヒント
          warm_tips:
            "🎋 千年の知恵を継承し、古典的な棋芸の美しさを体験してください\n💡 時間を合理的に配分し、思考の楽しさを満喫してください",

          // ゲーム結果関連
          game_result: "ゲーム結果",
          congratulations_win: "🎉 おめでとうございます！勝利！",
          sorry_lose: "😔 申し訳ございません、敗北しました",
          draw_result: "🤝 引き分け",
          current_score: "現在のスコア",
          win_rate_display: "勝率",
          total_games_display: "総ゲーム数",
          current_rank_display: "現在のランク",
          not_ranked: "ランク外",
          guest_mode: "ゲストモード",
          guest_mode_desc:
            "現在ゲストとしてゲーム中で、ゲーム結果はランキングに記録されません。",
          login_benefits: "ログイン後の特典：",
          benefit_stats: "• 📊 ゲームデータ統計",
          benefit_leaderboard: "• 🏆 ランキング競争参加",
          benefit_pi_service: "• 💰 Piコイン付加価値サービス",
          benefit_monthly_rewards: "• 🎁 月間報酬活動",
          play_again: "もう一度プレイ",
          view_leaderboard: "ランキングを見る",
          login_now: "今すぐログイン",

          // ゲームインターフェース
          return_to_menu: "戻る",
          guest_mode_short: "🎮 ゲストモード",
          ai_battle_title: "🧠 AI対戦",
          player_label: "プレイヤー",
          ai_label: "AI",
          vs_label: "VS",
          undo_button: "待った",
          new_game_button: "新しいゲーム",

          // 待った関連
          undo_confirm: "待った確認",
          undo_confirm_message:
            "待ったには0.1 πが必要です\n現在の残高：{0} π\n\n待ったを確認しますか？",
          undo_success_title: "待った成功",
          undo_success_detail: "0.1 π消費、残高：{0} π",
          undo_failed_title: "待った失敗",
          undo_failed_message: "支払い失敗",
          insufficient_balance_undo:
            "待ったには0.1 πが必要で、現在の残高{0} π、残高が不足しています。\n\nチャージしますか？",
          continue_game_tip:
            "現在のゲームを続けることはできますが、再開はできません。チャージ後にこの機能のロックを解除してください。",

          // チャージ関連
          recharge_dialog_title: "💰 アカウントチャージ",
          payment_dialog_title: "💳 Piコイン支払い",
          recharge_amount_display: "チャージ {0} π",
          order_id_display: "注文番号：{0}",
          custom_amount_error:
            "有効なチャージ金額を入力してください（最低0.1π）",

          // 個人センター詳細内容
          monthly_reward_reminder: "🏆 月間報酬リマインダー",
          monthly_reward_desc:
            "月間利益の50%がトップ3プレイヤーに報酬として配分されます",

          // 月間報酬詳細説明
          reward_settlement_detail: "毎月最終日の最終時間に決算",
          reward_pool_50_percent: "報酬プールはプラットフォーム月間利益の50%",
          reward_example_detail: "例：月間利益100π、報酬プール50π",
          reward_distribution_manual:
            "個人センターに保存されたウォレットアドレスに手動配布",
          reward_wallet_valid:
            "受賞者はウォレットアドレスが正確で有効であることを確認する必要があります",
          reward_next_day: "報酬は決算翌日に配布されます",
          reward_invalid_rollover:
            "ウォレットアドレスが無効な場合、報酬は翌月に繰り越されます",
          reward_example_calculation: "💡 例：月間利益100π、報酬プール50π",
          first_place_reward: "🥇1位：25π",
          second_place_reward: "🥈2位：15π",
          third_place_reward: "🥉3位：10π",

          // グローバルランキング
          global_ranking_title: "グローバルランキング",
          ranking_subtitle: "📊 月間勝率に基づくランキング",
          ranking_header_rank: "ランク",
          ranking_header_nickname: "ニックネーム",
          ranking_header_games: "総ゲーム数",
          ranking_header_winrate: "勝率",
          current_rank_not_listed: "現在のランク：未掲載",
          current_rank_label: "現在のランク",
          not_listed: "未掲載",
          play_one_game_to_rank:
            "🎮 1ゲーム完了でランキング掲載！五目並べの旅を始めましょう！",

          // 個人センター詳細ラベル
          personal_profile_section: "個人プロフィール",
          avatar_nickname_section: "アバターとニックネーム",
          click_avatar_edit: "アバターをクリックして編集",
          click_nickname_edit: "ニックネームをクリックして編集",
          account_info_section: "アカウント情報",
          game_stats_section: "ゲーム統計",
          wallet_address_label: "ウォレットアドレス",
          account_balance_display: "アカウント残高",
          refresh_balance_btn: "残高更新",
          logout_btn: "ログアウト",

          // ゲーム統計ラベル
          total_games_label: "総ゲーム数",
          wins_label: "勝利",
          win_rate_label: "勝率",
          current_score_label: "現在のスコア",
          current_rank_label: "現在のランク",

          // 残高照会状態
          balance_querying: "照会中...",
          balance_query_failed_display: "照会失敗",
          balance_tooltip: "総チャージ：{0} π\n総消費：{1} π",

          // 支払い成功情報
          payment_success_title: "支払い成功",
          payment_success_message: "支払い成功！",
          purchase_success_message: "{0}を正常に購入しました",
          transaction_id: "取引ID：{0}",

          // 個人センター入力ヒント
          enter_avatar_emoji: "絵文字アバターを入力（例：😊）",
          click_to_set_nickname: "ニックネーム設定はクリック",
          enter_your_nickname: "ニックネームを入力してください",
          loading_text_display: "読み込み中...",
          refresh_balance_text: "🔄 残高更新",
          recharge_text: "💰 チャージ",
          wallet_format_hint: "ウォレットアドレス形式：50文字の大文字と数字",
          save_wallet: "💾 保存",
          edit_wallet: "✏️ 編集",
          logout_account_text: "↩️ アカウントログアウト",

          // 個人センターヒント情報
          enter_avatar_hint: "アバター絵文字を入力してください",
          single_emoji_hint: "単一の絵文字を入力してください",
          avatar_updated: "アバターが更新されました！",
          nickname_updated: "ニックネームが更新されました！",
          enter_wallet_hint: "ウォレットアドレスを入力してください",
          wallet_length_error:
            "❌ これは標準ウォレットアドレスではありません！\n\n現在の長さ：{0}文字\n標準長さ：50文字\n\n完全な50文字のウォレットアドレスを入力してください",
          wallet_format_error:
            "❌ ウォレットアドレス形式エラー！\n\n大文字（A-Z）と数字（0-9）のみ許可されています\n入力内容を確認してください",
          wallet_saved_success: "✅ ウォレットアドレスが正常に保存されました！",
          edit_mode_title: "編集モード",
          edit_mode_message:
            "💡 編集モードが有効になりました\n\nウォレットアドレスを修正後、保存をクリックしてください",
          success_title: "成功",
          error_title: "エラー",

          // ゲーム終了関連
          you_win: "🎉 おめでとうございます！勝利！",
          you_lose: "😔 AIの勝利です、頑張って！",
          draw: "🤝 引き分け！",
          game_over: "ゲーム終了",

          // メインインターフェースボタン
          global_ranking: "グローバルランキング",
          ai_battle: "AI対戦",
          personal_center: "個人センター",
          game_instructions: "ゲーム説明",

          // 接続エラー
          connection_failed: "接続失敗",
          connection_error_detail:
            "Pi Networkに接続できません。ネットワーク接続を確認して再試行してください",
          login_with_pi: "Piアカウントでログイン",
          login_benefits_note:
            "ログイン後、完全なゲーム機能とPiコイン報酬をお楽しみください",

          // チャージダイアログ
          recharge_amount_selection: "チャージ金額選択",
          custom_amount_placeholder: "カスタム金額",
          custom_recharge: "カスタムチャージ",
          cancel: "キャンセル",

          // エラー通知
          please_login_first: "まずログインしてください",
          create_order_failed: "注文作成失敗",
          network_error_retry: "ネットワークエラー、後でもう一度お試しください",
          pi_login_failed: "Pi Networkログイン失敗",
          login_error: "ログイン中にエラーが発生しました",
          pi_sdk_not_loaded:
            "Pi Network SDKが読み込まれていないため、支払い機能が利用できません",
          create_payment_failed: "支払い作成失敗",

          // 支払いダイアログ
          payment_method: "支払い方法",
          pi_wallet_transfer: "📱 Piウォレット送金",
          transfer_instruction:
            "Piウォレットを使用して以下のアドレスに送金してください：",
          transfer_amount_warning:
            "⚠️ 送金金額が<strong>{0} π</strong>であることを確認してください",
          transfer_memo: "送金メモ：{0}",
          transaction_hash_placeholder: "取引ハッシュを入力してください",
          transaction_hash_instruction:
            "送金完了後、Piウォレットから取引ハッシュをコピーして上記の入力欄に貼り付けてください",
          verify_payment: "支払い確認",
          order_validity: "注文有効期限：30分",

          // 支払い確認
          please_enter_transaction_hash: "取引ハッシュを入力してください",
          recharge_success: "チャージ成功",
          recharge_success_message:
            "おめでとうございます！{0} π チャージ成功！\n現在の残高：{1} π",
          verification_failed: "確認失敗",

          // ゲームフロー確認
          timeout_game_over: "⏰ 思考時間超過、ゲーム失敗！",
          login_success: "ログイン成功",
          welcome_user: "ようこそ、{0}",
          abandon_current_game: "現在のゲームを放棄",
          abandon_game_warning:
            "現在のゲームが進行中です。再開始すると敗北として記録されます。\n\n現在のゲームを放棄しますか？",
          restart_game: "ゲーム再開始",
          restart_game_confirm: "再開始しますか？",
          abandon_game_return_warning:
            "現在のゲームが進行中です。メインメニューに戻ると敗北として記録されます。\n\n現在のゲームを放棄しますか？",

          // 勝敗表示形式
          wins_losses_format: "({0}勝{1}敗)",
          monthly_games: "月間ゲーム",
          play_again: "もう一度プレイ",
          view_leaderboard: "ランキングを見る",
          login_now: "今すぐログイン",
          guest_mode: "ゲストモード",
          guest_mode_desc:
            "現在ゲストとしてプレイしており、ゲーム結果はランキングに記録されません。",
          login_benefits: "ログイン後の特典:",
          benefit_stats: "• 📊 ゲーム統計",
          benefit_leaderboard: "• 🏆 ランキング競争への参加",
          benefit_pi_service: "• 💰 Piコイン付加価値サービス",
          benefit_monthly_rewards: "• 🎁 月間報酬活動",
          rank_position: "#{0}位",
        },

        vi: {
          // Giao diện cơ bản
          noscript: "Bạn cần bật JavaScript để chạy ứng dụng này.",
          game_title: "Cờ Carô",
          game_subtitle: "Trò chơi cờ carô chạy trên blockchain pinetwork",
          global_ranking: "Bảng Xếp Hạng Toàn Cầu",
          ai_battle: "Đấu với AI",
          personal_center: "Trung Tâm Cá Nhân",
          game_instructions: "Hướng Dẫn Trò Chơi",
          error_message: "❌ Thông Báo Lỗi",
          login_with_pi: "Đăng nhập bằng Pi Network",
          login_note:
            "Bằng cách nhấp đăng nhập, bạn đồng ý sử dụng tài khoản Pi Network để xác thực",

          // Tùy chọn ngôn ngữ
          lang_zh: "中文",
          lang_en: "English",
          lang_ko: "한국어",
          lang_ja: "日本語",
          lang_vi: "Tiếng Việt",

          // Liên quan đến trò chơi
          current_player: "Người Chơi Hiện Tại",
          your_turn: "Lượt Của Bạn",
          opponent_turn: "Lượt Của Đối Thủ",
          ai_thinking: "🤖 AI đang suy nghĩ...",
          thinking_time: "⏱️ Thời gian suy nghĩ: {0}s",
          remaining_time: "⚠️ Thời gian còn lại: {0}s",
          timeout_warning: "🚨 Cảnh báo hết thời gian: {0}s",
          timeout: "⏰ Hết thời gian",

          // Kết quả trò chơi
          you_win: "🎉 Chúc mừng! Bạn thắng!",
          you_lose: "😔 Tiếc quá, bạn thua",
          draw: "🤝 Hòa",
          game_over: "Kết Thúc Trò Chơi",

          // Nút và thao tác
          new_game: "Trò Chơi Mới",
          undo: "Hoàn Tác",
          restart: "Khởi Động Lại",
          back_to_menu: "Về Menu",
          confirm: "Xác Nhận",
          cancel: "Hủy",
          close: "Đóng",
          save: "Lưu",
          update: "Cập Nhật",
          enter_game: "Vào Game",

          // Trung tâm cá nhân
          personal_info: "Thông Tin Cá Nhân",
          game_stats: "Thống Kê Trò Chơi",
          total_games: "Tổng Số Trận",
          wins: "Thắng",
          losses: "Thua",
          win_rate: "Tỷ Lệ Thắng",
          current_rank: "Xếp Hạng Hiện Tại",
          wallet_address: "Địa Chỉ Ví",
          balance: "Số Dư",
          nickname: "Biệt Danh",
          avatar: "Hình Đại Diện",

          // Lỗi và thông báo
          connection_failed: "Kết Nối Thất Bại",
          network_error: "Lỗi mạng, vui lòng kiểm tra kết nối và thử lại",
          login_failed: "Đăng Nhập Thất Bại",
          insufficient_balance: "Số Dư Không Đủ",
          invalid_move: "Nước Đi Không Hợp Lệ",
          game_not_started: "Trò Chơi Chưa Bắt Đầu",

          // Liên quan đến thanh toán
          payment_confirm: "Xác Nhận Thanh Toán",
          payment_success: "Thanh Toán Thành Công",
          payment_failed: "Thanh Toán Thất Bại",
          payment_cancelled: "Thanh Toán Đã Hủy",
          recharge: "Nạp Tiền",

          // Bảng xếp hạng
          leaderboard: "Bảng Xếp Hạng",
          rank: "Xếp Hạng",
          player: "Người Chơi",
          score: "Điểm",
          games_played: "Trận Đã Chơi",

          // Khác
          loading: "Đang tải...",
          connecting: "Đang kết nối...",
          please_wait: "Vui lòng đợi...",
          success: "Thành Công",
          failed: "Thất Bại",
          connecting_pi_network: "Đang kết nối Pi Network...",
          entering_game: "Đang vào game...",

          // Popup và thông báo
          hint: "Gợi Ý",
          confirm_purchase: "Xác Nhận Mua",
          confirm_payment: "Xác Nhận Thanh Toán",
          payment_amount: "{0} π",
          enter_nickname: "Vui lòng nhập biệt danh",
          nickname_too_long: "Biệt danh không được vượt quá 20 ký tự",
          nickname_forbidden: "Biệt danh chứa từ bị cấm, vui lòng nhập lại",
          logout_confirm: "Xác Nhận Đăng Xuất",
          logout_message:
            "Bạn có chắc chắn muốn đăng xuất? Điều này sẽ xóa tất cả dữ liệu được lưu cục bộ.",
          logout_success: "Đăng Xuất Thành Công",
          logout_success_message: "Đã đăng xuất thành công!",
          please_login_first: "Vui lòng đăng nhập trước",

          // Hướng dẫn trò chơi
          game_instructions_title: "Hướng Dẫn Trò Chơi",
          game_history_title: "Lịch Sử Cờ Carô",
          game_history_desc:
            'Truyền thuyết kể rằng cờ carô ra đời cách đây hơn 4000 năm vào thời Hoàng đế Nghiêu. Nghiêu đã phát minh ra cờ đá để giáo dục con trai Đan Chu, sau đó được Thuấn cải tiến thành trò chơi "Ngũ tinh liên châu", dần hình thành nguyên mẫu của cờ carô hiện đại.\nTừ trò chơi dân gian thời Nghiêu-Thuấn, đến việc lan truyền sang Đông Á vào thời Nam Bắc triều, rồi được Nhật Bản cải tiến thành môn thể thao thi đấu, cuối cùng trở thành dự án cờ vua toàn cầu.',

          // Nội dung chi tiết hướng dẫn trò chơi
          game_history_section: "Nguồn Gốc Lịch Sử Cờ Carô",
          game_rules_section: "Luật Chơi",
          game_rules_title: "🎯 Quy Tắc Cơ Bản",

          // Trung tâm cá nhân
          personal_center_title: "Trung Tâm Cá Nhân",
          wallet_address_placeholder:
            "Nhập địa chỉ ví 50 ký tự (chữ hoa và số)",
          wallet_address_format: "Định dạng địa chỉ ví: 50 chữ hoa và số",

          // Liên quan đến thanh toán
          insufficient_balance_title: "Số Dư Không Đủ",
          insufficient_balance_message:
            "Hoàn tác cần 0.1 π, số dư hiện tại {0} π, số dư không đủ.\n\nBạn có muốn nạp tiền không?",
          recharge_prompt:
            "Nạp Pi coin vào tài khoản game của bạn và tận hưởng nhiều tính năng game hơn!",
          continue_without_recharge:
            "Bạn có thể tiếp tục trò chơi hiện tại nhưng không thể khởi động lại. Mở khóa tính năng này sau khi nạp tiền.",
          undo_success: "Hoàn Tác Thành Công",
          undo_success_message: "Đã tiêu thụ 0.1 π, số dư: {0} π",
          undo_failed: "Hoàn Tác Thất Bại",
          network_error_retry: "Lỗi mạng, vui lòng thử lại sau",
          invalid_amount: "Vui lòng nhập số tiền nạp hợp lệ (tối thiểu 0.1π)",

          // Tên vật phẩm
          item_hint: "Vật Phẩm Gợi Ý",
          item_undo: "Vé Hoàn Tác",
          item_theme: "Gói Chủ Đề",
          item_vip: "Thành Viên VIP",
          item_unknown: "Vật Phẩm Không Xác Định",

          // Bảng xếp hạng và thống kê
          current_ranking:
            "🎯 Xếp hạng hiện tại: #{0} | ({1}T {2}B) | Tỷ lệ thắng: {3}%",
          leaderboard_update_tip:
            "Bảng xếp hạng cập nhật theo thời gian thực, tiếp tục chơi để cải thiện xếp hạng của bạn!",

          // Quy tắc chi tiết trò chơi
          basic_rules_detail_1:
            "Trên bàn cờ 15×15, người chơi dùng quân đen, AI dùng quân trắng",
          basic_rules_detail_2:
            "Hai bên luân phiên đặt quân, ai nối được 5 quân trước sẽ thắng",
          basic_rules_detail_3:
            "5 quân có thể nối theo hướng ngang, dọc hoặc chéo",
          basic_rules_detail_4:
            "Nếu bàn cờ đầy mà không có ai thắng thì là hòa",

          // Quy tắc thời gian lượt
          turn_time_rules: "⏱️ Quy Tắc Thời Gian Lượt",
          thinking_time_rule: "Thời gian suy nghĩ: 60 giây mỗi lượt",
          time_warning_rule:
            "Cảnh báo thời gian: Cảnh báo màu vàng khi còn 30 giây",
          urgent_warning_rule:
            "Cảnh báo khẩn cấp: Nhấp nháy màu đỏ trong 10 giây cuối",
          timeout_rule:
            "Thua do hết thời gian: Hết thời gian sẽ tự động ghi nhận là thua",

          // Chi tiết thao tác trò chơi
          game_operations: "🎮 Thao Tác Trò Chơi",
          place_stone: "Đặt quân: Nhấp vào ô trống để đặt quân",
          undo_move:
            "Hoàn tác: Có thể hủy nước đi gần nhất (người chơi + AI mỗi bên một nước)",
          new_game_op:
            "Trò chơi mới: Bắt đầu lại, trò chơi đang diễn ra sẽ được ghi là thua",
          return_op:
            "Quay lại: Thoát trò chơi, trò chơi đang diễn ra sẽ được ghi là thua",

          // Hệ thống điểm số
          score_system: "🏆 Hệ Thống Xếp Hạng Tỷ Lệ Thắng",
          initial_score: "Cơ sở xếp hạng: Sắp xếp theo tỷ lệ thắng",
          win_score: "Thắng: Cải thiện tỷ lệ thắng",
          draw_score: "Hòa: Ảnh hưởng tỷ lệ thắng",
          lose_score: "Thua: Giảm tỷ lệ thắng",
          quit_score: "Bỏ cuộc/Hết thời gian: Ghi nhận là thua",

          // Quy tắc xếp hạng hàng tháng
          monthly_ranking_rules: "🎯 Quy Tắc Xếp Hạng Hàng Tháng:",
          ranking_requirement: "• Cần tối thiểu 1 trận để tham gia xếp hạng",
          ranking_criteria:
            "• Xếp hạng theo điểm còn lại, điểm bằng nhau thì sắp xếp theo tỷ lệ thắng",
          ranking_rewards: "• Phát thưởng cuối tháng dựa trên xếp hạng",
          anti_farming:
            "⚠️ Cơ chế chống gian lận: Người chơi không chơi hoặc chơi quá ít sẽ không tham gia xếp hạng",

          // Quy tắc thưởng hàng tháng
          monthly_rewards: "🏆 Quy Tắc Thưởng Hàng Tháng",
          reward_pool_allocation: "💰 Phân Bổ Quỹ Thưởng",
          reward_settlement: "Quyết toán vào giờ cuối của ngày cuối mỗi tháng",
          reward_pool_percentage:
            "Quỹ thưởng là 50% lợi nhuận hàng tháng của nền tảng",
          reward_example: "Ví dụ: Lợi nhuận tháng 100π, quỹ thưởng 50π",

          // Phân bổ top 3
          top_three_distribution: "🥇 Tỷ Lệ Phân Bổ Top 3",
          first_place: "🥇 Hạng Nhất",
          second_place: "🥈 Hạng Nhì",
          third_place: "🥉 Hạng Ba",

          // Phương thức phát thưởng
          distribution_method: "📋 Phương Thức Phát Thưởng",
          wallet_distribution:
            "Phát thưởng thủ công theo địa chỉ ví được lưu trong trung tâm cá nhân",
          valid_wallet_required:
            "Người thắng giải phải đảm bảo địa chỉ ví chính xác và hợp lệ",
          next_day_distribution:
            "Thưởng sẽ được phát vào ngày sau khi quyết toán",
          invalid_wallet_rollover:
            "Nếu địa chỉ ví không hợp lệ, thưởng sẽ được chuyển sang tháng sau",

          // Quy tắc bảng xếp hạng
          leaderboard_rules: "📊 Quy Tắc Bảng Xếp Hạng",
          ranking_condition:
            "Điều kiện xếp hạng: Hoàn thành 60 trận để được lên bảng",
          ranking_basis: "Cơ sở xếp hạng: Sắp xếp theo điểm tích lũy",
          data_statistics:
            "Thống kê dữ liệu: Dựa trên dữ liệu tích lũy lịch sử",
          realtime_update:
            "Cập nhật thời gian thực: Cập nhật ngay sau mỗi trận đấu",

          // Lời khuyên ấm áp
          warm_tips:
            "🎋 Kế thừa trí tuệ ngàn năm, trải nghiệm vẻ đẹp cờ cổ điển\n💡 Sắp xếp thời gian hợp lý, tận hưởng niềm vui suy nghĩ",

          // Liên quan đến kết quả trò chơi
          game_result: "Kết Quả Trò Chơi",
          congratulations_win: "🎉 Chúc mừng! Bạn thắng!",
          sorry_lose: "😔 Xin lỗi, bạn đã thua",
          draw_result: "🤝 Hòa",
          current_score: "Điểm Hiện Tại",
          win_rate_display: "Tỷ Lệ Thắng",
          total_games_display: "Tổng Số Trận",
          current_rank_display: "Xếp Hạng Hiện Tại",
          not_ranked: "Chưa Có Xếp Hạng",
          guest_mode: "Chế Độ Khách",
          guest_mode_desc:
            "Bạn hiện đang chơi với tư cách khách, kết quả trò chơi sẽ không được ghi vào bảng xếp hạng.",
          login_benefits: "Sau khi đăng nhập, tận hưởng:",
          benefit_stats: "• 📊 Thống kê dữ liệu trò chơi",
          benefit_leaderboard: "• 🏆 Tham gia cạnh tranh bảng xếp hạng",
          benefit_pi_service: "• 💰 Dịch vụ giá trị gia tăng Pi coin",
          benefit_monthly_rewards: "• 🎁 Hoạt động thưởng hàng tháng",
          play_again: "Chơi Lại",
          view_leaderboard: "Xem Bảng Xếp Hạng",
          login_now: "Đăng Nhập Ngay",

          // Giao diện trò chơi
          return_to_menu: "Quay Lại",
          guest_mode_short: "🎮 Chế Độ Khách",
          ai_battle_title: "🧠 Đấu Với AI",
          player_label: "Người Chơi",
          ai_label: "AI",
          vs_label: "VS",
          undo_button: "Hoàn Tác",
          new_game_button: "Trò Chơi Mới",

          // Liên quan đến hoàn tác
          undo_confirm: "Xác Nhận Hoàn Tác",
          undo_confirm_message:
            "Hoàn tác cần 0.1 π\nSố dư hiện tại: {0} π\n\nXác nhận hoàn tác?",
          undo_success_title: "Hoàn Tác Thành Công",
          undo_success_detail: "Đã tiêu thụ 0.1 π, số dư: {0} π",
          undo_failed_title: "Hoàn Tác Thất Bại",
          undo_failed_message: "Thanh toán thất bại",
          insufficient_balance_undo:
            "Hoàn tác cần 0.1 π, số dư hiện tại {0} π, số dư không đủ.\n\nBạn có muốn nạp tiền không?",
          continue_game_tip:
            "Bạn có thể tiếp tục trò chơi hiện tại nhưng không thể khởi động lại. Mở khóa tính năng này sau khi nạp tiền.",

          // Liên quan đến nạp tiền
          recharge_dialog_title: "💰 Nạp Tiền Tài Khoản",
          payment_dialog_title: "💳 Thanh Toán Pi Coin",
          recharge_amount_display: "Nạp {0} π",
          order_id_display: "Mã đơn hàng: {0}",
          custom_amount_error:
            "Vui lòng nhập số tiền nạp hợp lệ (tối thiểu 0.1π)",

          // Nội dung chi tiết trung tâm cá nhân
          monthly_reward_reminder: "🏆 Nhắc Nhở Thưởng Hàng Tháng",
          monthly_reward_desc:
            "50% lợi nhuận hàng tháng sẽ được phân phối cho 3 người chơi hàng đầu làm phần thưởng",

          // Giải thích chi tiết thưởng hàng tháng
          reward_settlement_detail:
            "Quyết toán vào giờ cuối của ngày cuối mỗi tháng",
          reward_pool_50_percent:
            "Quỹ thưởng là 50% lợi nhuận hàng tháng của nền tảng",
          reward_example_detail: "Ví dụ: Lợi nhuận tháng 100π, quỹ thưởng 50π",
          reward_distribution_manual:
            "Phát thưởng thủ công theo địa chỉ ví được lưu trong trung tâm cá nhân",
          reward_wallet_valid:
            "Người thắng giải phải đảm bảo địa chỉ ví chính xác và hợp lệ",
          reward_next_day: "Thưởng sẽ được phát vào ngày sau khi quyết toán",
          reward_invalid_rollover:
            "Nếu địa chỉ ví không hợp lệ, thưởng sẽ được chuyển sang tháng sau",
          reward_example_calculation:
            "💡 Ví dụ: Lợi nhuận tháng 100π, quỹ thưởng 50π",
          first_place_reward: "🥇Hạng nhất: 25π",
          second_place_reward: "🥈Hạng nhì: 15π",
          third_place_reward: "🥉Hạng ba: 10π",

          // Bảng xếp hạng toàn cầu
          global_ranking_title: "Bảng Xếp Hạng Toàn Cầu",
          ranking_subtitle: "📊 Xếp hạng dựa trên tỷ lệ thắng hàng tháng",
          ranking_header_rank: "Hạng",
          ranking_header_nickname: "Biệt danh",
          ranking_header_games: "Tổng trận",
          ranking_header_winrate: "Tỷ lệ thắng",
          current_rank_not_listed: "Xếp hạng hiện tại: Chưa có",
          current_rank_label: "Xếp hạng hiện tại",
          not_listed: "Chưa có",
          play_one_game_to_rank:
            "🎮 Hoàn thành 1 trận để lên bảng xếp hạng! Bắt đầu hành trình Cờ Carô của bạn!",

          // Nhãn chi tiết trung tâm cá nhân
          personal_profile_section: "Hồ sơ cá nhân",
          avatar_nickname_section: "Avatar và biệt danh",
          click_avatar_edit: "Nhấp avatar để chỉnh sửa",
          click_nickname_edit: "Nhấp biệt danh để chỉnh sửa",
          account_info_section: "Thông tin tài khoản",
          game_stats_section: "Thống kê trò chơi",
          wallet_address_label: "Địa chỉ ví",
          account_balance_display: "Số dư tài khoản",
          refresh_balance_btn: "Làm mới số dư",
          logout_btn: "Đăng xuất",

          // Nhãn thống kê trò chơi
          total_games_label: "Tổng trận",
          wins_label: "Thắng",
          win_rate_label: "Tỷ lệ thắng",
          current_score_label: "Điểm hiện tại",
          current_rank_label: "Hạng hiện tại",

          // Trạng thái truy vấn số dư
          balance_querying: "Đang truy vấn...",
          balance_query_failed_display: "Truy vấn thất bại",
          balance_tooltip: "Tổng nạp: {0} π\nTổng chi: {1} π",

          // Thông tin thanh toán thành công
          payment_success_title: "Thanh toán thành công",
          payment_success_message: "Thanh toán thành công!",
          purchase_success_message: "Bạn đã mua thành công {0}",
          transaction_id: "ID giao dịch: {0}",

          // Gợi ý nhập trung tâm cá nhân
          enter_avatar_emoji: "Nhập emoji avatar (ví dụ: 😊)",
          click_to_set_nickname: "Nhấp để đặt biệt danh",
          enter_your_nickname: "Nhập biệt danh của bạn",
          loading_text_display: "Đang tải...",
          refresh_balance_text: "🔄 Làm mới số dư",
          recharge_text: "💰 Nạp tiền",
          wallet_format_hint: "Định dạng địa chỉ ví: 50 chữ cái viết hoa và số",
          save_wallet: "💾 Lưu",
          edit_wallet: "✏️ Chỉnh sửa",
          logout_account_text: "↩️ Đăng xuất tài khoản",

          // Thông tin gợi ý trung tâm cá nhân
          enter_avatar_hint: "Vui lòng nhập emoji avatar",
          single_emoji_hint: "Vui lòng nhập một emoji duy nhất",
          avatar_updated: "Avatar đã được cập nhật!",
          nickname_updated: "Biệt danh đã được cập nhật!",
          enter_wallet_hint: "Vui lòng nhập địa chỉ ví",
          wallet_length_error:
            "❌ Đây không phải là địa chỉ ví tiêu chuẩn!\n\nĐộ dài hiện tại: {0} ký tự\nĐộ dài tiêu chuẩn: 50 ký tự\n\nVui lòng nhập địa chỉ ví đầy đủ 50 ký tự",
          wallet_format_error:
            "❌ Lỗi định dạng địa chỉ ví!\n\nChỉ cho phép chữ cái viết hoa (A-Z) và số (0-9)\nVui lòng kiểm tra nội dung nhập",
          wallet_saved_success: "✅ Địa chỉ ví đã được lưu thành công!",
          edit_mode_title: "Chế độ chỉnh sửa",
          edit_mode_message:
            "💡 Chế độ chỉnh sửa đã được kích hoạt\n\nVui lòng sửa đổi địa chỉ ví và nhấp lưu",
          success_title: "Thành công",
          error_title: "Lỗi",

          // Liên quan đến kết thúc trò chơi
          you_win: "🎉 Chúc mừng! Bạn thắng!",
          you_lose: "😔 AI thắng, hãy cố gắng lần sau!",
          draw: "🤝 Hòa!",
          game_over: "Kết thúc trò chơi",

          // Nút giao diện chính
          global_ranking: "Bảng xếp hạng toàn cầu",
          ai_battle: "Đấu với AI",
          personal_center: "Trung tâm cá nhân",
          game_instructions: "Hướng dẫn trò chơi",

          // Lỗi kết nối
          connection_failed: "Kết nối thất bại",
          connection_error_detail:
            "Không thể kết nối với Pi Network, vui lòng kiểm tra kết nối mạng và thử lại",
          login_with_pi: "Đăng nhập bằng tài khoản Pi",
          login_benefits_note:
            "Đăng nhập để tận hưởng đầy đủ tính năng trò chơi và phần thưởng Pi coin",

          // Hộp thoại nạp tiền
          recharge_amount_selection: "Lựa chọn số tiền nạp",
          custom_amount_placeholder: "Số tiền tùy chỉnh",
          custom_recharge: "Nạp tiền tùy chỉnh",
          cancel: "Hủy",

          // Thông báo lỗi
          please_login_first: "Vui lòng đăng nhập trước",
          create_order_failed: "Tạo đơn hàng thất bại",
          network_error_retry: "Lỗi mạng, vui lòng thử lại sau",
          pi_login_failed: "Đăng nhập Pi Network thất bại",
          login_error: "Lỗi xảy ra trong quá trình đăng nhập",
          pi_sdk_not_loaded:
            "Pi Network SDK chưa được tải, không thể sử dụng tính năng thanh toán",
          create_payment_failed: "Tạo thanh toán thất bại",

          // Hộp thoại thanh toán
          payment_method: "Phương thức thanh toán",
          pi_wallet_transfer: "📱 Chuyển khoản ví Pi",
          transfer_instruction:
            "Vui lòng sử dụng ví Pi để chuyển khoản đến địa chỉ sau:",
          transfer_amount_warning:
            "⚠️ Vui lòng đảm bảo số tiền chuyển khoản là <strong>{0} π</strong>",
          transfer_memo: "Ghi chú chuyển khoản: {0}",
          transaction_hash_placeholder: "Vui lòng nhập hash giao dịch",
          transaction_hash_instruction:
            "Sau khi hoàn tất chuyển khoản, vui lòng sao chép hash giao dịch từ ví Pi và dán vào ô nhập ở trên",
          verify_payment: "Xác minh thanh toán",
          order_validity: "Thời hạn đơn hàng: 30 phút",

          // Xác minh thanh toán
          please_enter_transaction_hash: "Vui lòng nhập hash giao dịch",
          recharge_success: "Nạp tiền thành công",
          recharge_success_message:
            "Chúc mừng! Nạp {0} π thành công!\nSố dư hiện tại: {1} π",
          verification_failed: "Xác minh thất bại",

          // Xác nhận luồng trò chơi
          timeout_game_over: "⏰ Hết thời gian suy nghĩ, trò chơi thất bại!",
          login_success: "Đăng nhập thành công",
          welcome_user: "Chào mừng, {0}",
          abandon_current_game: "Bỏ cuộc trò chơi hiện tại",
          abandon_game_warning:
            "Trò chơi hiện tại đang diễn ra, khởi động lại sẽ được ghi nhận là thua.\n\nBạn có chắc chắn muốn bỏ cuộc trò chơi hiện tại không?",
          restart_game: "Khởi động lại trò chơi",
          restart_game_confirm: "Bạn có chắc chắn muốn khởi động lại không?",
          abandon_game_return_warning:
            "Trò chơi hiện tại đang diễn ra, quay về menu chính sẽ được ghi nhận là thua.\n\nBạn có chắc chắn muốn bỏ cuộc trò chơi hiện tại không?",

          // Định dạng hiển thị thắng thua
          wins_losses_format: "({0}T {1}B)",
          monthly_games: "Trò chơi hàng tháng",
          play_again: "Chơi lại",
          view_leaderboard: "Xem bảng xếp hạng",
          login_now: "Đăng nhập ngay",
          guest_mode: "Chế độ khách",
          guest_mode_desc:
            "Bạn hiện đang chơi với tư cách khách, kết quả trò chơi sẽ không được ghi vào bảng xếp hạng.",
          login_benefits: "Lợi ích sau khi đăng nhập:",
          benefit_stats: "• 📊 Thống kê trò chơi",
          benefit_leaderboard: "• 🏆 Tham gia cạnh tranh bảng xếp hạng",
          benefit_pi_service: "• 💰 Dịch vụ giá trị gia tăng Pi coin",
          benefit_monthly_rewards: "• 🎁 Hoạt động thưởng hàng tháng",
          rank_position: "#{0}",
        },
      };

      // 当前语言
      let currentLanguage = localStorage.getItem("selectedLanguage") || "zh";

      // 翻译函数
      function t(key, ...args) {
        let text =
          LANGUAGES[currentLanguage]?.[key] || LANGUAGES["zh"][key] || key;

        // 处理参数替换 {0}, {1}, etc.
        if (args.length > 0) {
          args.forEach((arg, index) => {
            text = text.replace(`{${index}}`, arg);
          });
        }

        return text;
      }

      // 更新页面文本
      function updatePageTexts() {
        // 更新所有带有 data-i18n 属性的元素
        document.querySelectorAll("[data-i18n]").forEach((element) => {
          const key = element.getAttribute("data-i18n");
          const translatedText = t(key);

          // 特殊处理：保持 pinetwork 为英文
          const finalText = translatedText.replace(/pinetwork/gi, "pinetwork");

          if (element.tagName === "INPUT" && element.type === "text") {
            element.placeholder = finalText;
          } else {
            element.textContent = finalText;
          }
        });

        // 更新语言选择器
        const languageSelector = document.getElementById("language-selector");
        if (languageSelector) {
          languageSelector.value = currentLanguage;
        }

        // 更新游戏界面的语言选择器
        const languageSelectorGame = document.getElementById(
          "language-selector-game"
        );
        if (languageSelectorGame) {
          languageSelectorGame.value = currentLanguage;
        }

        // 动态调整副标题字体大小
        adjustSubtitleFontSize();
      }

      // 动态调整副标题字体大小以适应不同语言
      function adjustSubtitleFontSize() {
        const subtitle = document.querySelector(".game-subtitle");
        if (!subtitle) return;

        // 重置字体大小，确保使用CSS默认值
        subtitle.style.fontSize = "";

        // 强制重新计算布局
        subtitle.offsetHeight;

        // 不进行任何宽度相关的计算，避免影响布局
        // 让CSS的clamp()函数自动处理字体大小
      }

      // 切换语言
      function changeLanguage(lang) {
        currentLanguage = lang;
        localStorage.setItem("selectedLanguage", lang);
        updatePageTexts();

        // 如果有动态内容，也需要更新
        updateDynamicContent();
      }

      // 更新动态内容（游戏中的文本）
      function updateDynamicContent() {
        // 更新游戏状态显示
        const currentPlayerDisplay = document.getElementById(
          "current-player-display"
        );
        if (currentPlayerDisplay && typeof aiCurrentPlayer !== "undefined") {
          if (aiCurrentPlayer === "black") {
            currentPlayerDisplay.textContent = t("your_turn");
          } else {
            currentPlayerDisplay.textContent = t("ai_thinking");
          }
        }

        // 更新主页登录/进入游戏按钮的文本
        updateMainPageButtonState();

        // 更新其他动态元素...
      }

      // 全局变量
      let currentUser = null;
      let isLoading = false;
      let currentGame = null;

      // 后端API配置 - 根据环境自动检测
      const API_BASE_URL = (() => {
        const hostname = window.location.hostname;
        const protocol = window.location.protocol;

        if (hostname === "localhost" || hostname === "127.0.0.1") {
          // 本地开发环境
          return "http://localhost:3001";
        } else if (hostname === "mrsong-ai.github.io") {
          // GitHub Pages + 阿里云后端
          return "http://47.79.240.129:3001";
        } else {
          // 阿里云自部署环境 - 使用相同域名的/api路径
          return `${protocol}//${hostname}/api`;
        }
      })();

      // 用户统计数据
      let userStats = null;

      // 数据刷新相关变量
      let leaderboardRefreshInterval = null;
      let lastDataRefreshTime = 0;
      const DATA_REFRESH_COOLDOWN = 5000; // 5秒冷却时间

      // 检查Pi SDK是否可用
      function isPiAvailable() {
        return typeof window.Pi !== "undefined";
      }

      // 初始化页面
      function initializePage() {
        // 移除Pi Browser检查，始终允许使用
        const loginBtn = document.getElementById("login-btn");
        if (loginBtn) {
          loginBtn.disabled = false;
        }

        // 初始化多语言
        updatePageTexts();

        // 添加钱包地址输入验证
        setupWalletAddressValidation();

        // 检查并恢复登录状态
        checkAndRestoreLoginState();

        // 延迟更新主页按钮状态，确保DOM完全加载
        setTimeout(() => {
          updateMainPageButtonState();
        }, 200);

        // 注释掉测试数据创建，使用真实数据
        // 如果需要测试，可以在浏览器控制台手动设置数据
      }

      // 检查并恢复登录状态
      async function checkAndRestoreLoginState() {
        const restored = restoreLoginState();
        if (restored) {
          // 如果成功恢复登录状态，只更新按钮状态，不自动进入游戏
          try {
            // 尝试刷新后端数据（如果可用）
            if (currentUser.accessToken) {
              await authenticateWithBackend(currentUser.accessToken);
            }
          } catch (error) {
            console.error("自动登录时后端验证失败:", error);
            // 即使后端失败，也保持登录状态，使用本地数据
          }

          // 延迟更新按钮状态，确保DOM已加载
          setTimeout(() => {
            updateMainPageButtonState();
          }, 100);
        }
      }

      // 设置钱包地址输入验证
      function setupWalletAddressValidation() {
        // 使用事件委托，因为钱包输入框可能在模态框中动态创建
        document.addEventListener("input", function (e) {
          if (e.target && e.target.id === "wallet-address-input") {
            let value = e.target.value;
            // 只允许大写字母和数字
            value = value.replace(/[^A-Z0-9]/g, "");
            // 限制长度为50位
            if (value.length > 50) {
              value = value.substring(0, 50);
            }
            e.target.value = value;

            // 更新字符计数
            updateWalletCharCount(value.length);
          }
        });
      }

      // 更新钱包地址字符计数
      function updateWalletCharCount(length) {
        const countElement = document.getElementById("wallet-char-count");
        if (countElement) {
          countElement.textContent = `${length}/50`;
          // 根据长度改变颜色
          if (length === 50) {
            countElement.style.color = "#28a745"; // 绿色
          } else if (length > 40) {
            countElement.style.color = "#ffc107"; // 黄色
          } else {
            countElement.style.color = "#6c757d"; // 灰色
          }
        }
      }

      // 显示错误信息
      function showError(message) {
        const errorMessage = document.getElementById("error-message");
        const errorText = document.getElementById("error-text");
        errorText.textContent = "❌ " + message;
        errorMessage.style.display = "block";
      }

      // 隐藏错误信息
      function hideError() {
        const errorMessage = document.getElementById("error-message");
        errorMessage.style.display = "none";
      }

      // Pi Network 登录处理
      async function handleSignIn() {
        if (isLoading) return;

        // 如果已经登录，直接进入游戏
        if (currentUser) {
          showSimpleGameScreen();
          return;
        }

        isLoading = true;
        const loginBtn = document.getElementById("login-btn");
        loginBtn.disabled = true;

        // 检查是否在Pi Browser中来显示不同的提示
        const isInPiBrowser = isPiAvailable();
        const loadingText = isInPiBrowser
          ? t("connecting_pi_network")
          : t("entering_game");

        // 完全替换按钮内容为连接状态，隐藏原有的登录文本
        loginBtn.innerHTML = `
                <div class="loading">
                    <div class="spinner"></div>
                    <span>${loadingText}</span>
                </div>
            `;
        loginBtn.classList.add('loading');

        try {
          hideError();

          // 检查是否在Pi Browser中
          if (isPiAvailable()) {
            // 真实的Pi Network登录
            const scopes = ["username", "payments"];

            // 设置超时机制，避免无限等待
            const authPromise = Pi.authenticate(
              scopes,
              onIncompletePaymentFound
            );
            const timeoutPromise = new Promise((_, reject) =>
              setTimeout(() => reject(new Error("Pi Network连接超时")), 10000)
            );

            const authResult = await Promise.race([
              authPromise,
              timeoutPromise,
            ]);

            if (authResult.accessToken) {
              currentUser = authResult.user;
              currentUser.accessToken = authResult.accessToken; // 保存访问令牌

              // 保存登录状态到本地存储
              saveLoginState(currentUser);

              // 向后端验证用户并获取统计数据
              await authenticateWithBackend(authResult.accessToken);

              // 更新主页按钮状态
              updateMainPageButtonState();

              // 确保用户数据被保存到本地存储
              if (userStats) {
                saveUserGameDataToSpecificStorage();
                refreshLocalLeaderboardData();
              }

              // 触发数据刷新（延迟执行，确保后端数据已同步）
              setTimeout(() => {
                triggerDataRefresh();
              }, 2000);

              // 登录成功后保持在当前界面，不自动跳转到游戏
              showCustomAlert(
                t("login_success"),
                t("welcome_user", currentUser.username)
              );
            } else {
              showError(t("pi_login_failed"));
            }
          } else {
            // Pi SDK不可用，显示错误信息
            showError(t("pi_sdk_not_available"));
          }
        } catch (error) {
          console.error("Sign in failed:", error);
          showError(t("login_error") + ": " + error.message);
        } finally {
          isLoading = false;
          loginBtn.disabled = false;
          loginBtn.classList.remove('loading');

          // 恢复按钮原始状态
          if (!currentUser) {
            loginBtn.innerHTML = `
              <span class="pi-icon">π</span>
              <span data-i18n="login_with_pi">${t("login_with_pi")}</span>
            `;
          }
        }
      }

      // 后端认证函数
      async function authenticateWithBackend(accessToken) {
        try {
          const response = await fetch(`${API_BASE_URL}/api/auth/login`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              accessToken,
              userInfo: {
                uid: currentUser.uid,
                username: currentUser.username,
              },
            }),
          });

          if (response.ok) {
            const data = await response.json();
            // 保存用户ID用于后续API调用
            currentUser.piUserId =
              data.user.piUserId || data.user.uid || currentUser.uid;

            // 先尝试恢复用户专属的游戏数据
            const hasLocalData = restoreUserGameData();

            // 数据完整性检查：比较本地数据和后端数据
            const backendStats = data.user.stats;
            if (
              hasLocalData &&
              userStats &&
              userStats.totalGames > 0 &&
              backendStats.totalGames === 0
            ) {
              console.log(
                "[登录数据恢复] 检测到后端数据异常，保持使用本地数据"
              );
              // 异步同步本地数据到后端
              setTimeout(() => {
                syncLocalDataToBackend(userStats);
              }, 1000);
            } else if (!userStats || userStats.totalGames === 0) {
              // 如果没有本地数据，才使用后端返回的初始数据
              userStats = backendStats;
            }
          } else {
            // 如果后端认证失败，使用uid作为piUserId
            currentUser.piUserId = currentUser.uid;

            // 尝试恢复本地数据
            const restored = restoreUserGameData();
            if (!restored) {
              // 如果没有可恢复的数据，创建默认数据
              createDefaultUserStats();
            }
          }
        } catch (error) {
          // 如果后端连接失败，使用uid作为piUserId
          currentUser.piUserId = currentUser.uid;

          // 尝试恢复本地数据
          const restored = restoreUserGameData();
          if (!restored) {
            // 如果没有可恢复的数据，创建默认数据
            createDefaultUserStats();
          }
        }
      }

      // 恢复用户专属的游戏数据
      function restoreUserGameData() {
        if (!currentUser) return;

        const userId = currentUser.piUserId || currentUser.uid;
        const userDataKey = `piGomokuUserData_${userId}`;
        const savedUserData = localStorage.getItem(userDataKey);

        if (savedUserData) {
          try {
            const userData = JSON.parse(savedUserData);
            // 如果找到用户专属数据，使用它
            if (userData.gameStats) {
              userStats = userData.gameStats;
              // 更新用户名为最新的
              userStats.username =
                currentUser.username || userStats.username || "Pi用户";

              // 同时更新通用存储，保持兼容性
              localStorage.setItem(
                "piGomokuGameStats",
                JSON.stringify(userStats)
              );
              return true; // 表示成功恢复了数据
            }
          } catch (error) {
            console.error("恢复用户数据失败:", error);
          }
        }

        // 如果没有找到用户专属数据，尝试从通用存储恢复
        const generalStats = localStorage.getItem("piGomokuGameStats");
        if (generalStats) {
          try {
            const stats = JSON.parse(generalStats);
            if (stats && stats.totalGames > 0) {
              userStats = stats;
              userStats.username =
                currentUser.username || userStats.username || "Pi用户";
              return true; // 表示成功恢复了数据
            }
          } catch (error) {
            console.error("恢复通用数据失败:", error);
          }
        }

        return false; // 表示没有找到可恢复的数据
      }

      // 从本地存储初始化用户数据
      function initializeUserStatsFromLocal() {
        const localStats = localStorage.getItem("piGomokuGameStats");

        if (localStats) {
          try {
            userStats = JSON.parse(localStats);
            // 确保用户名是最新的
            userStats.username =
              currentUser.username || userStats.username || "Pi用户";
          } catch (error) {
            console.error("解析本地数据失败:", error);
            createDefaultUserStats();
          }
        } else {
          createDefaultUserStats();
        }
      }

      // 创建默认用户统计数据
      function createDefaultUserStats() {
        userStats = {
          username: currentUser.username || "Pi用户",
          totalGames: 0,
          wins: 0,
          losses: 0,
          draws: 0,
          winRate: 0,
          rank: 0,
        };
        // 立即保存到本地存储
        localStorage.setItem("piGomokuGameStats", JSON.stringify(userStats));
      }

      // 获取当前显示的用户名（与个人中心保持一致）
      function getCurrentDisplayUsername() {
        if (currentUser && userStats) {
          // Pi登录状态：优先使用Pi用户名，然后是userStats中的用户名
          return currentUser.username || userStats.username || "Pi用户";
        } else {
          // 未登录状态：使用本地昵称
          return localStorage.getItem("userNickname") || "游客";
        }
      }

      // 保存登录状态到本地存储
      function saveLoginState(user) {
        const loginState = {
          user: user,
          timestamp: Date.now(),
          expiresAt: Date.now() + 7 * 24 * 60 * 60 * 1000, // 7天过期
        };
        localStorage.setItem("piGomokuLoginState", JSON.stringify(loginState));
      }

      // 恢复登录状态
      function restoreLoginState() {
        try {
          const savedState = localStorage.getItem("piGomokuLoginState");
          if (!savedState) return false;

          const loginState = JSON.parse(savedState);

          // 检查是否过期
          if (Date.now() > loginState.expiresAt) {
            localStorage.removeItem("piGomokuLoginState");
            return false;
          }

          // 恢复用户状态
          currentUser = loginState.user;

          // 恢复用户数据
          const restored = restoreUserGameData();
          if (!restored) {
            createDefaultUserStats();
          }

          return true;
        } catch (error) {
          console.error("恢复登录状态失败:", error);
          localStorage.removeItem("piGomokuLoginState");
          return false;
        }
      }

      // 清除登录状态
      function clearLoginState() {
        localStorage.removeItem("piGomokuLoginState");
      }

      // 更新主页按钮显示状态
      function updateMainPageButtonState() {
        const loginBtn = document.getElementById("login-btn");
        if (!loginBtn) {
          return;
        }

        if (currentUser) {
          // 已登录状态：显示"进入游戏"按钮
          loginBtn.innerHTML = `
            <span class="pi-icon">🎮</span>
            <span>${t("enter_game")}</span>
          `;
          loginBtn.onclick = () => showSimpleGameScreen();
        } else {
          // 未登录状态：显示"登录"按钮
          loginBtn.innerHTML = `
            <span class="pi-icon">π</span>
            <span data-i18n="login_with_pi">${t("login_with_pi")}</span>
          `;
          loginBtn.onclick = handleSignIn;
        }
      }

      // Pi SDK不可用时的处理
      function handlePiSdkUnavailable() {
        showCustomAlert(
          t("error_title"),
          t("pi_sdk_required_message")
        );
      }

      // 处理未完成的支付
      function onIncompletePaymentFound(payment) {
        console.log("发现未完成的支付:", payment);
        // 这里可以处理未完成的支付，比如重新验证
        handleIncompletePayment(payment);
      }

      // Pi支付功能 - 购买道具
      async function buyItem(itemType, amount) {
        if (!currentUser) {
          showError(t("please_login_first"));
          return;
        }

        if (!isPiAvailable()) {
          showError(t("pi_sdk_not_loaded"));
          return;
        }

        try {
          // 显示支付确认
          const confirmed = await showPaymentConfirm(itemType, amount);
          if (!confirmed) return;

          // 创建支付请求
          const paymentData = {
            amount: amount,
            memo: `购买${getItemName(itemType)}`,
            metadata: {
              itemType: itemType,
              userId: currentUser.uid,
              timestamp: Date.now(),
            },
          };

          // 发起Pi支付
          const payment = await Pi.createPayment(paymentData, {
            onReadyForServerApproval: async function (paymentId) {
              console.log("支付等待服务器审批:", paymentId);
              try {
                const response = await fetch(
                  `${API_BASE_URL}/api/payment/approve`,
                  {
                    method: "POST",
                    headers: {
                      "Content-Type": "application/json",
                      Authorization: `Bearer ${currentUser.accessToken}`,
                    },
                    body: JSON.stringify({ paymentId, paymentData }),
                  }
                );

                if (response.ok) {
                  console.log("支付审批成功");
                } else {
                  console.error("支付审批失败");
                  // 即使后端失败，也继续流程（用于测试）
                }
              } catch (error) {
                console.error("支付审批请求失败:", error);
                // 即使后端失败，也继续流程（用于测试）
              }
            },
            onReadyForServerCompletion: async function (paymentId, txid) {
              console.log("支付等待服务器完成:", paymentId, txid);
              try {
                const response = await fetch(
                  `${API_BASE_URL}/api/payment/complete`,
                  {
                    method: "POST",
                    headers: {
                      "Content-Type": "application/json",
                      Authorization: `Bearer ${currentUser.accessToken}`,
                    },
                    body: JSON.stringify({ paymentId, txid, paymentData }),
                  }
                );

                if (response.ok) {
                  const data = await response.json();
                  console.log("支付完成验证成功:", data);
                } else {
                  console.error("支付完成验证失败");
                }
              } catch (error) {
                console.error("支付完成请求失败:", error);
              }

              // 显示支付成功消息
              setTimeout(() => {
                showCustomModal(
                  "支付成功",
                  `
                    <div style="text-align: center;">
                        <div style="font-size: 3em; margin-bottom: 15px;">✅</div>
                        <h3 style="color: #28a745;">支付成功！</h3>
                        <p style="color: #666; margin: 15px 0;">
                            您已成功购买 ${getItemName(
                              paymentData.metadata.itemType
                            )}
                        </p>
                        <p style="color: #007bff; font-weight: bold;">
                            交易ID: ${txid.substring(0, 16)}...
                        </p>
                    </div>
                  `
                );
              }, 1000);
            },
            onCancel: function (paymentId) {
              console.log("支付被取消:", paymentId);
              showError(t("payment_cancelled"));
            },
            onError: function (error, payment) {
              console.error("支付错误:", error, payment);
              showError(t("payment_failed") + ": " + error.message);
            },
          });
        } catch (error) {
          console.error("创建支付失败:", error);
          showError(t("create_payment_failed") + ": " + error.message);
        }
      }

      // 获取道具名称
      function getItemName(itemType) {
        const keys = {
          hint: "item_hint",
          undo: "item_undo",
          theme: "item_theme",
          vip: "item_vip",
        };
        return t(keys[itemType] || "item_unknown");
      }

      // 显示支付确认对话框
      function showPaymentConfirm(itemType, amount) {
        return new Promise((resolve) => {
          const itemName = getItemName(itemType);
          showCustomModal(
            t("confirm_purchase"),
            `
                    <div style="text-align: center;">
                        <div style="font-size: 3em; margin-bottom: 15px;">💰</div>
                        <h3 style="color: #333; margin-bottom: 15px;">${t(
                          "confirm_purchase"
                        )}</h3>
                        <div style="background: #f8f9fa; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                            <p style="font-size: 1.1em; margin-bottom: 10px; color: #333;">
                                <strong>${itemName}</strong>
                            </p>
                            <p style="font-size: 1.3em; color: #007bff; font-weight: bold;">
                                ${t("payment_amount", amount)}
                            </p>
                        </div>
                        <div style="display: flex; gap: 10px; justify-content: center;">
                            <button onclick="closeNewModal(); resolve(false)" style="background: #6c757d; color: white; border: none; border-radius: 6px; padding: 10px 20px; cursor: pointer;">
                                ${t("cancel")}
                            </button>
                            <button onclick="closeNewModal(); resolve(true)" style="background: #007bff; color: white; border: none; border-radius: 6px; padding: 10px 20px; cursor: pointer;">
                                ${t("confirm_payment")}
                            </button>
                        </div>
                    </div>
                `,
            resolve
          );
        });
      }

      // 处理未完成的支付
      async function handleIncompletePayment(payment) {
        try {
          // 检查支付状态并处理
          // 这里可以重新提交到服务器验证
        } catch (error) {
          console.error("处理未完成支付失败:", error);
        }
      }

      // 服务器端支付审批 (需要后端API)
      async function approvePaymentOnServer(paymentId, paymentData) {
        try {
          // 这里需要调用您的后端API
          // const response = await fetch('YOUR_BACKEND_URL/api/payments/approve', {
          //     method: 'POST',
          //     headers: { 'Content-Type': 'application/json' },
          //     body: JSON.stringify({ paymentId, paymentData })
          // });
          // 模拟审批成功
        } catch (error) {
          console.error("服务器审批失败:", error);
        }
      }

      // 服务器端支付完成 (需要后端API)
      async function completePaymentOnServer(paymentId, txid, paymentData) {
        try {
          // 这里需要调用您的后端API
          // const response = await fetch('YOUR_BACKEND_URL/api/payments/complete', {
          //     method: 'POST',
          //     headers: { 'Content-Type': 'application/json' },
          //     body: JSON.stringify({ paymentId, txid, paymentData })
          // });

          // 模拟支付成功
          setTimeout(() => {
            showCustomModal(
              t("payment_success_title"),
              `
                        <div style="text-align: center;">
                            <div style="font-size: 3em; margin-bottom: 15px;">✅</div>
                            <h3 style="color: #28a745;">${t(
                              "payment_success_message"
                            )}</h3>
                            <p style="color: #666; margin: 15px 0;">
                                ${t(
                                  "purchase_success_message",
                                  getItemName(paymentData.metadata.itemType)
                                )}
                            </p>
                            <p style="color: #007bff; font-weight: bold;">
                                ${t(
                                  "transaction_id",
                                  txid.substring(0, 16) + "..."
                                )}
                            </p>
                        </div>
                    `
            );
          }, 2000);
        } catch (error) {
          console.error("服务器完成支付失败:", error);
        }
      }

      // AI对战处理
      function handleAIGame() {
        showSimpleGameScreen();
      }

      // 加载排行榜数据 - 支持本地数据降级
      async function loadLeaderboard(
        sortBy = "score",
        limit = 100,
        forceRefresh = false
      ) {
        try {
          const now = Date.now();
          const shouldRefresh =
            forceRefresh || now - lastDataRefreshTime > DATA_REFRESH_COOLDOWN;

          if (!shouldRefresh) {
            console.log("[排行榜] 跳过刷新，冷却时间未到");
            // 如果不需要刷新，返回本地排行榜数据
            return getLocalLeaderboard(limit);
          }

          // 首先尝试从后端获取数据
          try {
            const refreshParam = forceRefresh ? "&refresh=true" : "";
            const response = await fetch(
              `${API_BASE_URL}/api/leaderboard?limit=${limit}${refreshParam}`
            );
            if (response.ok) {
              const data = await response.json();
              lastDataRefreshTime = now;
              console.log(
                `[排行榜] 后端数据刷新成功，总用户数: ${data.totalUsers}, 排行榜条目: ${data.leaderboard.length}`
              );
              return data.leaderboard || [];
            } else {
              console.error("获取排行榜失败:", response.status);
              throw new Error("后端请求失败");
            }
          } catch (backendError) {
            console.log("[排行榜] 后端不可用，使用本地数据");
            return getLocalLeaderboard(limit);
          }
        } catch (error) {
          console.error("排行榜请求错误:", error);
          // 发生任何错误时，都返回本地排行榜数据
          return getLocalLeaderboard(limit);
        }
      }

      // 获取真实Pi Network用户排行榜数据（无模拟用户）
      function getLocalLeaderboard(limit = 100) {
        try {
          const allUsers = [];
          const userIdSet = new Set(); // 用于去重

          console.log("[排行榜] 开始收集真实Pi Network用户数据...");

          // 1. 收集localStorage中的所有真实Pi Network用户数据，过滤掉测试用户
          const userDataMap = new Map(); // userId -> 最佳用户数据

          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);

            // 查找用户专属数据
            if (key && key.startsWith('piGomokuUserData_')) {
              try {
                const userData = JSON.parse(localStorage.getItem(key));
                if (userData && userData.gameStats && userData.gameStats.totalGames > 0) {
                  const userId = userData.userId;

                  // 过滤掉测试用户和模拟用户
                  if (userId && !userId.startsWith('test_user_') && !userId.startsWith('mock_') && !userData.accessToken?.startsWith('mock_token_')) {
                    const userEntry = {
                      userId: userId,
                      username: userData.username || userData.gameStats.username || "Pi用户",
                      totalGames: userData.gameStats.totalGames,
                      wins: userData.gameStats.wins,
                      losses: userData.gameStats.losses,
                      draws: userData.gameStats.draws || 0,
                      winRate: userData.gameStats.winRate || 0,
                      lastUpdated: userData.lastUpdated || 0,
                      storageKey: key
                    };

                    // 如果用户已存在，比较并保留更好的数据
                    if (userDataMap.has(userId)) {
                      const existingEntry = userDataMap.get(userId);

                      // 优先保留游戏局数更多的数据，局数相同时保留时间更新的
                      if (userEntry.totalGames > existingEntry.totalGames ||
                          (userEntry.totalGames === existingEntry.totalGames &&
                           userEntry.lastUpdated > existingEntry.lastUpdated)) {
                        userDataMap.set(userId, userEntry);
                        console.log(`[排行榜] 更新Pi用户数据: ${userId} (${userEntry.username}) - 总局数: ${userEntry.totalGames} (${key})`);
                      } else {
                        console.log(`[排行榜] 保留现有Pi用户数据: ${userId} - 总局数: ${existingEntry.totalGames} >= ${userEntry.totalGames}`);
                      }
                    } else {
                      userDataMap.set(userId, userEntry);
                      console.log(`[排行榜] 添加新Pi用户: ${userId} (${userEntry.username}) - 总局数: ${userEntry.totalGames} (${key})`);
                    }
                  } else {
                    console.log(`[排行榜] 跳过测试用户: ${userId}`);
                  }
                }
              } catch (parseError) {
                console.error("解析用户数据失败:", parseError);
              }
            }
          }

          // 转换为数组
          userDataMap.forEach((userEntry) => {
            const isCurrentUser = currentUser &&
              (userEntry.userId === currentUser.piUserId || userEntry.userId === currentUser.uid);

            allUsers.push({
              userId: userEntry.userId,
              username: userEntry.username,
              totalGames: userEntry.totalGames,
              wins: userEntry.wins,
              losses: userEntry.losses,
              draws: userEntry.draws,
              winRate: userEntry.winRate,
              isCurrentUser: isCurrentUser
            });
            userIdSet.add(userEntry.userId);
          });

          // 2. 如果当前用户有数据但不在localStorage专属存储中，且是真实Pi用户，添加当前用户
          if (currentUser && userStats && userStats.totalGames > 0) {
            const currentUserId = currentUser.piUserId || currentUser.uid;
            // 只添加真实Pi Network用户，过滤掉测试用户
            if (currentUserId && !userIdSet.has(currentUserId) &&
                !currentUserId.startsWith('test_user_') &&
                !currentUserId.startsWith('mock_') &&
                !currentUser.accessToken?.startsWith('mock_token_')) {
              userIdSet.add(currentUserId);
              allUsers.push({
                userId: currentUserId,
                username: getCurrentDisplayUsername(),
                totalGames: userStats.totalGames,
                wins: userStats.wins,
                losses: userStats.losses,
                draws: userStats.draws || 0,
                winRate: userStats.winRate || 0,
                isCurrentUser: true
              });
              console.log(`[排行榜] 添加当前Pi用户数据: ${currentUserId} (${getCurrentDisplayUsername()})`);
            } else if (currentUserId?.startsWith('test_user_') || currentUserId?.startsWith('mock_') || currentUser.accessToken?.startsWith('mock_token_')) {
              console.log(`[排行榜] 跳过当前测试用户: ${currentUserId}`);
            }
          }

          // 按胜率排序，胜率相同时按胜场数排序，再按总局数排序
          const sortedUsers = allUsers
            .sort((a, b) => {
              // 1. 首先按胜率排序（高到低）
              if (b.winRate !== a.winRate) {
                return b.winRate - a.winRate;
              }
              // 2. 胜率相同时，按胜场数排序（高到低）
              if (b.wins !== a.wins) {
                return b.wins - a.wins;
              }
              // 3. 胜场数相同时，按总局数排序（高到低）
              if (b.totalGames !== a.totalGames) {
                return b.totalGames - a.totalGames;
              }
              // 4. 最后按用户名排序（确保稳定排序）
              return a.username.localeCompare(b.username);
            })
            .slice(0, limit)
            .map((user, index) => ({
              rank: index + 1,
              userId: user.userId,
              username: user.username,
              totalGames: user.totalGames,
              wins: user.wins,
              winRate: user.winRate,
              isCurrentUser: user.isCurrentUser || false
            }));

          console.log(`[本地排行榜] 生成排行榜数据，共 ${sortedUsers.length} 条记录:`, sortedUsers);
          return sortedUsers;
        } catch (error) {
          console.error("生成本地排行榜失败:", error);
          return [];
        }
      }

      // 获取用户排名 - 支持本地数据降级
      async function getUserRank(userId) {
        try {
          // 首先尝试从后端获取排名
          try {
            const response = await fetch(
              `${API_BASE_URL}/api/leaderboard/rank?userId=${userId}`
            );
            if (response.ok) {
              const data = await response.json();
              return data.rank || 0;
            } else {
              throw new Error("后端请求失败");
            }
          } catch (backendError) {
            console.log("[用户排名] 后端不可用，使用本地数据计算排名");
            return getLocalUserRank(userId);
          }
        } catch (error) {
          console.error("获取用户排名错误:", error);
          return getLocalUserRank(userId);
        }
      }

      // 从本地数据计算用户排名
      function getLocalUserRank(userId) {
        try {
          const leaderboard = getLocalLeaderboard(1000); // 获取完整排行榜
          const userEntry = leaderboard.find(entry => entry.userId === userId);
          return userEntry ? userEntry.rank : 0;
        } catch (error) {
          console.error("计算本地用户排名失败:", error);
          return 0;
        }
      }

      // 显示实时排行榜
      async function showRealTimeLeaderboard(forceRefresh = false) {
        const leaderboard = await loadLeaderboard("score", 100, forceRefresh);

        // 获取当前用户的真实排名
        let userRank = 0;
        if (currentUser && currentUser.piUserId) {
          userRank = await getUserRank(currentUser.piUserId);
        }

        // 启动自动刷新
        startLeaderboardAutoRefresh();

        let leaderboardHTML = "";
        if (leaderboard.length === 0) {
          // 检查当前用户是否有游戏数据但未显示在排行榜中
          const hasUserData = currentUser && userStats && userStats.totalGames > 0;

          leaderboardHTML = `
                    <div style="text-align: center; padding: 40px 20px; color: #666;">
                        <div style="font-size: 3em; margin-bottom: 15px;">🎯</div>
                        ${hasUserData ?
                          `<p style="margin: 0; font-size: 1.1em;">正在加载排行榜数据...</p>
                           <p style="margin: 5px 0 0 0; font-size: 0.9em;">您的游戏数据：${userStats.totalGames}局 (${userStats.wins}胜${userStats.losses}负) 胜率${userStats.winRate}%</p>` :
                          `<p style="margin: 0; font-size: 1.1em;">暂无排行榜数据</p>
                           <p style="margin: 5px 0 0 0; font-size: 0.9em;">${t("play_one_game_to_rank")}</p>`
                        }
                    </div>
                `;
        } else {
          leaderboard.forEach((player, index) => {
            const isCurrentUser =
              currentUser &&
              (player.userId === currentUser.uid ||
                player.userId === currentUser.piUserId);
            const rankIcon =
              index === 0
                ? "🥇"
                : index === 1
                ? "🥈"
                : index === 2
                ? "🥉"
                : index + 1;
            const bgColor = isCurrentUser ? "background: #e3f2fd;" : "";

            leaderboardHTML += `
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 12px 10px; border-bottom: 1px solid #e9ecef; ${bgColor}">
                            <span style="color: ${
                              index < 3 ? "#ffd700" : "#6c757d"
                            }; font-weight: bold;">${rankIcon}</span>
                            <span style="font-weight: 500; color: ${
                              isCurrentUser ? "#1976d2" : "#333"
                            };">${player.username}</span>
                            <span style="color: #666; font-size: 0.9em;">${t(
                              "wins_losses_format",
                              player.wins,
                              player.totalGames - player.wins
                            )}</span>
                            <span style="color: #28a745;">${
                              player.winRate
                            }%</span>
                        </div>
                    `;
          });
        }

        showCustomModal(
          t("global_ranking_title"),
          `
                <div style="text-align: center;">
                    <div style="margin-bottom: 20px;">
                        <span style="font-size: 3em; margin-bottom: 10px; display: block;">🏆</span>
                        <h3 style="color: #333; margin-bottom: 20px;">${t(
                          "global_ranking_title"
                        )}</h3>
                        <p style="color: #666; font-size: 0.9em; margin: 0 0 15px 0;">${t(
                          "ranking_subtitle"
                        )}</p>
                    </div>

                    <div style="background: #f8f9fa; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; border-bottom: 2px solid #e9ecef; font-weight: bold; color: #495057;">
                            <span>${t("ranking_header_rank")}</span>
                            <span>${t("ranking_header_nickname")}</span>
                            <span>${t("ranking_header_games")}</span>
                            <span>${t("ranking_header_winrate")}</span>
                        </div>
                        ${leaderboardHTML}
                    </div>

                    ${
                      userRank > 0
                        ? `
                        <div style="background: #e3f2fd; border-radius: 8px; padding: 8px; margin-bottom: 10px; margin-top: 0px;">
                            <p style="margin: 0; color: #1976d2; font-weight: 500; text-align: center;">
                                ${t(
                                  "current_ranking",
                                  userRank,
                                  userStats ? userStats.wins : 0,
                                  userStats
                                    ? userStats.totalGames - userStats.wins
                                    : 0,
                                  userStats ? userStats.winRate : 0
                                )}
                            </p>
                        </div>
                    `
                        : userStats && userStats.totalGames === 0
                        ? `
                        <div style="background: #fff3cd; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                            <p style="margin: 0; color: #856404; font-weight: 500;">
                                ${t("play_one_game_to_rank")}
                            </p>
                        </div>
                    `
                        : ""
                    }

                    <p style="color: #666; font-size: 0.9em; margin: 0;">
                        ${t("leaderboard_update_tip")}
                    </p>
                </div>
            `
        );
      }

      // 启动排行榜自动刷新
      function startLeaderboardAutoRefresh() {
        // 清除之前的定时器
        if (leaderboardRefreshInterval) {
          clearInterval(leaderboardRefreshInterval);
        }

        // 每30秒自动刷新一次排行榜
        leaderboardRefreshInterval = setInterval(async () => {
          console.log("[排行榜] 自动刷新数据...");
          const currentModal = document.querySelector(".modal-overlay");
          if (currentModal && currentModal.style.display !== "none") {
            // 如果排行榜弹窗还在显示，则刷新数据
            await showRealTimeLeaderboard(true);
          } else {
            // 如果弹窗已关闭，停止自动刷新
            stopLeaderboardAutoRefresh();
          }
        }, 30000); // 30秒
      }

      // 停止排行榜自动刷新
      function stopLeaderboardAutoRefresh() {
        if (leaderboardRefreshInterval) {
          clearInterval(leaderboardRefreshInterval);
          leaderboardRefreshInterval = null;
          console.log("[排行榜] 停止自动刷新");
        }
      }

      // 触发数据刷新（用于新用户登录后）
      function triggerDataRefresh() {
        console.log("[数据刷新] 触发全局数据刷新");

        // 重置刷新冷却时间，强制刷新
        lastDataRefreshTime = 0;

        // 如果排行榜弹窗正在显示，立即刷新
        const currentModal = document.querySelector(".modal-overlay");
        if (currentModal && currentModal.style.display !== "none") {
          console.log("[数据刷新] 刷新排行榜数据");
          showRealTimeLeaderboard(true);
        }

        // 刷新个人中心数据（如果正在显示）
        const personalCenterModal = document.querySelector(".custom-modal");
        if (personalCenterModal) {
          console.log("[数据刷新] 刷新个人中心数据");
          refreshUserStats();
        }
      }

      // 显示全球排行榜 (使用真实数据)
      async function showGlobalRanking() {
        // 直接调用真实排行榜函数
        await showRealTimeLeaderboard();
        return;

        // 以下代码已废弃，保留作为备用
        /*
        showCustomModal(
          `${t(
            "global_ranking_title"
          )}<br><span style='font-size: 0.7em; color: #ffffff; font-weight: normal;'>${t(
            "ranking_subtitle"
          )}</span>`,
          `
                <div style="text-align: center;">
                    <div style="background: #f8f9fa; border-radius: 8px; padding: 10px; margin-bottom: 8px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px; border-bottom: 2px solid #e9ecef; font-weight: bold; color: #495057;">
                            <span>${t("ranking_header_rank")}</span>
                            <span>${t("ranking_header_nickname")}</span>
                            <span>${t("ranking_header_games")}</span>
                            <span>${t("ranking_header_winrate")}</span>
                        </div>

                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 6px 8px; border-bottom: 1px solid #e9ecef;">
                            <span style="color: #ffd700; font-weight: bold;">🥇 1</span>
                            <span style="font-weight: 500;">棋圣大师</span>
                            <span style="color: #666; font-size: 0.9em; text-align: center;" data-i18n-format="wins_losses" data-wins="21" data-losses="1">(21胜1负)</span>
                            <span style="color: #28a745;">95.2%</span>
                        </div>

                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 6px 8px; border-bottom: 1px solid #e9ecef;">
                            <span style="color: #c0c0c0; font-weight: bold;">🥈 2</span>
                            <span style="font-weight: 500;">五子高手</span>
                            <span style="color: #666; font-size: 0.9em; text-align: center;">(25胜2负)</span>
                            <span style="color: #28a745;">92.8%</span>
                        </div>

                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 6px 8px; border-bottom: 1px solid #e9ecef;">
                            <span style="color: #cd7f32; font-weight: bold;">🥉 3</span>
                            <span style="font-weight: 500;">连珠达人</span>
                            <span style="color: #666; font-size: 0.9em; text-align: center;">(26胜3负)</span>
                            <span style="color: #28a745;">89.6%</span>
                        </div>

                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 6px 8px; border-bottom: 1px solid #e9ecef;">
                            <span style="color: #6c757d;">4</span>
                            <span style="font-weight: 500;">黑白传说</span>
                            <span style="color: #666; font-size: 0.9em; text-align: center;">(24胜4负)</span>
                            <span style="color: #28a745;">87.3%</span>
                        </div>

                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 6px 8px; border-bottom: 1px solid #e9ecef;">
                            <span style="color: #6c757d;">5</span>
                            <span style="font-weight: 500;">智慧之星</span>
                            <span style="color: #666; font-size: 0.9em; text-align: center;">(23胜4负)</span>
                            <span style="color: #28a745;">85.1%</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 6px 8px; border-bottom: 1px solid #e9ecef;">
                            <span style="color: #6c757d;">6</span>
                            <span style="font-weight: 500;">棋道高手</span>
                            <span style="color: #666; font-size: 0.9em; text-align: center;">(20胜5负)</span>
                            <span style="color: #28a745;">80.0%</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 6px 8px; border-bottom: 1px solid #e9ecef;">
                            <span style="color: #6c757d;">7</span>
                            <span style="font-weight: 500;">五子王者</span>
                            <span style="color: #666; font-size: 0.9em; text-align: center;">(19胜6负)</span>
                            <span style="color: #28a745;">76.0%</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 6px 8px; border-bottom: 1px solid #e9ecef;">
                            <span style="color: #6c757d;">8</span>
                            <span style="font-weight: 500;">连珠专家</span>
                            <span style="color: #666; font-size: 0.9em; text-align: center;">(18胜7负)</span>
                            <span style="color: #28a745;">72.0%</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 6px 8px; border-bottom: 1px solid #e9ecef;">
                            <span style="color: #6c757d;">9</span>
                            <span style="font-weight: 500;">黑白精英</span>
                            <span style="color: #666; font-size: 0.9em; text-align: center;">(17胜8负)</span>
                            <span style="color: #28a745;">68.0%</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 6px 8px;">
                            <span style="color: #6c757d;">10</span>
                            <span style="font-weight: 500;">棋局达人</span>
                            <span style="color: #666; font-size: 0.9em; text-align: center;">(16胜9负)</span>
                            <span style="color: #28a745;">64.0%</span>
                        </div>
                    </div>
                    <div style="background: #e3f2fd; border-radius: 8px; padding: 8px; margin-bottom: 10px; margin-top: 0px;">
                        <p style="margin: 0; color: #1976d2; font-weight: 500; text-align: center;">
                            ${t("current_ranking", "42", "13", "4", "76.5")}
                        </p>
                    </div>

                    <p style="color: #666; font-size: 0.9em; margin: 0;">
                        ${t("leaderboard_update_tip")}
                    </p>
                </div>
            `
        );
        */
      }

      // 显示个人中心
      async function showPersonalCenter() {
        // 如果用户已登录，确保有piUserId并刷新数据
        if (currentUser) {
          // 确保有piUserId
          if (!currentUser.piUserId) {
            currentUser.piUserId = currentUser.uid;
          }

          await refreshUserStats();
        }

        const stats = userStats || {
          totalGames: 0,
          wins: 0,
          losses: 0,
          winRate: 0,
          rank: 0,
        };

        // 获取保存的用户信息
        const savedWalletAddress =
          localStorage.getItem("userWalletAddress") || "";
        const savedNickname = localStorage.getItem("userNickname") || "";

        // 判断登录状态和昵称显示逻辑
        let displayNickname = "";
        let nicknameEditable = true;

        if (currentUser && userStats) {
          // Pi登录状态：显示Pi用户名，不可编辑
          displayNickname =
            userStats.username || currentUser.username || "Pi用户";
          nicknameEditable = false;
        } else {
          // 未登录状态：显示本地昵称，可编辑
          displayNickname = savedNickname || t("click_to_set_nickname");
          nicknameEditable = true;
        }

        showCustomModal(
          t("personal_center_title"),
          `
                <div style="text-align: center; max-height: 80vh; overflow-y: auto;">
                    <!-- 个人档案编辑 -->
                    <div style="margin-bottom: 8px;">
                        <div style="background: #f8f9fa; border-radius: 8px; padding: 10px; margin-bottom: 8px;">
                            <!-- 昵称显示 -->
                            <div style="background: white; border-radius: 8px; padding: 10px; margin-bottom: 8px;">
                                <div style="margin-bottom: 5px;">
                                    <h4
                                        style="margin: 0 0 4px 0; color: #333; ${
                                          nicknameEditable
                                            ? "cursor: pointer; transition: color 0.2s;"
                                            : "cursor: default;"
                                        } font-size: 1.2em;"
                                        id="user-nickname-display"
                                        ${
                                          nicknameEditable
                                            ? 'onclick="toggleNicknameEdit()" onmouseover="this.style.color=\'#007bff\'" onmouseout="this.style.color=\'#333\'"'
                                            : ""
                                        }
                                    >${displayNickname}</h4>
                                    ${
                                      nicknameEditable
                                        ? `
                                    <div style="display: none;" id="nickname-edit-section">
                                        <input
                                            type="text"
                                            id="nickname-input"
                                            placeholder="${t(
                                              "enter_your_nickname"
                                            )}"
                                            value="${savedNickname}"
                                            style="
                                                width: 200px;
                                                padding: 8px;
                                                border: 2px solid #e9ecef;
                                                border-radius: 6px;
                                                font-size: 14px;
                                                text-align: center;
                                                box-sizing: border-box;
                                            "
                                            maxlength="20"
                                        />
                                        <button
                                            onclick="updateNickname()"
                                            style="
                                                background: #28a745;
                                                color: white;
                                                border: none;
                                                border-radius: 6px;
                                                padding: 8px 12px;
                                                cursor: pointer;
                                                font-size: 12px;
                                                margin-left: 5px;
                                            "
                                        >
                                            ✓
                                        </button>
                                        <button
                                            onclick="toggleNicknameEdit()"
                                            style="
                                                background: #6c757d;
                                                color: white;
                                                border: none;
                                                border-radius: 6px;
                                                padding: 8px 12px;
                                                cursor: pointer;
                                                font-size: 12px;
                                                margin-left: 5px;
                                            "
                                        >
                                            ✕
                                        </button>
                                    </div>
                                    `
                                        : ""
                                    }
                                </div>
                            </div>

                            <!-- 游戏统计 -->
                            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 6px; margin-bottom: 6px;">
                                <div style="background: white; border-radius: 6px; padding: 8px; text-align: center;">
                                    <div style="font-size: 1.3em; color: #007bff; font-weight: bold;">${
                                      stats.totalGames
                                    }</div>
                                    <div style="color: #666; font-size: 0.8em;">${t(
                                      "total_games_label"
                                    )}</div>
                                </div>
                                <div style="background: white; border-radius: 6px; padding: 8px; text-align: center;">
                                    <div style="font-size: 1.3em; color: #28a745; font-weight: bold;">${
                                      stats.wins
                                    }</div>
                                    <div style="color: #666; font-size: 0.8em;">${t(
                                      "wins_label"
                                    )}</div>
                                </div>
                                <div style="background: white; border-radius: 6px; padding: 8px; text-align: center;">
                                    <div style="font-size: 1.3em; color: #ffc107; font-weight: bold;">${
                                      stats.winRate
                                    }%</div>
                                    <div style="color: #666; font-size: 0.8em;">${t(
                                      "win_rate_label"
                                    )}</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- 账户余额和钱包地址 -->
                    <div style="background: #f8f9fa; border-radius: 8px; padding: 8px; margin-bottom: 8px;">
                        <div style="background: white; border-radius: 8px; padding: 8px; margin-bottom: 6px; border: 2px solid #e3f2fd;">
                            <div style="font-size: 1.8em; color: #f39c12; font-weight: bold; margin-bottom: 4px;" id="account-balance">
                                ${t("loading_text_display")}
                            </div>
                            <div style="display: flex; gap: 8px; justify-content: center; margin-top: 8px;">
                                <button onclick="refreshBalance()" style="background: #17a2b8; color: white; border: none; border-radius: 4px; padding: 6px 12px; cursor: pointer; font-size: 12px;">
                                    ${t("refresh_balance_text")}
                                </button>
                                <button onclick="showRechargeDialog(t('recharge_prompt'))" style="background: #28a745; color: white; border: none; border-radius: 4px; padding: 6px 12px; cursor: pointer; font-size: 12px;">
                                    ${t("recharge_text")}
                                </button>
                            </div>
                        </div>

                        <!-- 钱包地址输入 -->
                        <div style="background: white; border-radius: 8px; padding: 8px;">
                            <div style="margin-bottom: 0;">
                                <input
                                    type="text"
                                    id="wallet-address-input"
                                    placeholder="${t(
                                      "wallet_address_placeholder"
                                    )}"
                                    value="${savedWalletAddress}"
                                    maxlength="50"
                                    style="
                                        width: 100%;
                                        padding: 8px;
                                        border: 2px solid #e9ecef;
                                        border-radius: 6px;
                                        font-size: 14px;
                                        box-sizing: border-box;
                                        font-family: monospace;
                                        text-transform: uppercase;
                                        background: #f8f9fa;
                                    "
                                />
                                <div style="margin-top: 8px; display: flex; justify-content: space-between; align-items: center;">
                                    <small style="color: #6c757d; font-size: 12px;">
                                        ${t("wallet_format_hint")}
                                    </small>
                                    <span id="wallet-char-count" style="color: #6c757d; font-size: 12px;">
                                        ${savedWalletAddress.length}/50
                                    </span>
                                </div>
                                <div style="margin-top: 6px; text-align: center;">
                                    <button
                                        onclick="saveWalletAddress()"
                                        style="
                                            background: #28a745;
                                            color: white;
                                            border: none;
                                            border-radius: 6px;
                                            padding: 8px 16px;
                                            cursor: pointer;
                                            font-size: 14px;
                                            margin-right: 8px;
                                        "
                                    >
                                        ${t("save_wallet")}
                                    </button>
                                    <button
                                        onclick="editWalletAddress()"
                                        style="
                                            background: #17a2b8;
                                            color: white;
                                            border: none;
                                            border-radius: 6px;
                                            padding: 8px 16px;
                                            cursor: pointer;
                                            font-size: 14px;
                                        "
                                    >
                                        ${t("edit_wallet")}
                                    </button>
                                </div>
                            </div>

                            <!-- 月度奖励重要提示 -->
                            <div style="margin-top: 8px; padding: 8px; background: #fff3cd; border-radius: 4px; border: 1px solid #ffeaa7;">
                                <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;">
                                    <span style="font-size: 14px;">🏆</span>
                                    <strong style="color: #856404; font-size: 12px;">${t(
                                      "monthly_reward_reminder"
                                    )}</strong>
                                </div>
                                <p style="color: #856404; font-size: 11px; margin: 0; line-height: 1.4;">
                                    ${t("monthly_reward_desc")}
                                </p>
                            </div>
                        </div>
                    </div>



                    <div style="text-align: center; margin-top: 6px;">
                        ${
                          currentUser && userStats
                            ? `
                        <button
                            onclick="logoutUser()"
                            style="
                                background: #dc3545;
                                color: white;
                                border: none;
                                border-radius: 8px;
                                padding: 8px 16px;
                                cursor: pointer;
                                font-size: 14px;
                                font-weight: 500;
                                transition: background 0.2s;
                            "
                            onmouseover="this.style.background='#c82333'"
                            onmouseout="this.style.background='#dc3545'"
                        >
                            ${t("logout_account_text")}
                        </button>
                        `
                            : `
                        <button
                            onclick="handlePersonalCenterLogin()"
                            style="
                                background: #7b2cbf;
                                color: white;
                                border: none;
                                border-radius: 8px;
                                padding: 8px 16px;
                                cursor: pointer;
                                font-size: 14px;
                                font-weight: 500;
                                transition: background 0.2s;
                            "
                            onmouseover="this.style.background='#5a189a'"
                            onmouseout="this.style.background='#7b2cbf'"
                        >
                            ${t("login_with_pi")}
                        </button>
                        `
                        }
                    </div>
                </div>
            `
        );

        // 初始化钱包地址状态和刷新余额
        setTimeout(() => {
          initializeWalletAddressState();
          refreshBalance(); // 自动刷新余额
        }, 100);
      }

      // 初始化钱包地址状态
      function initializeWalletAddressState() {
        const walletInput = document.getElementById("wallet-address-input");
        const savedWalletAddress =
          localStorage.getItem("userWalletAddress") || "";

        if (walletInput) {
          // 更新字符计数
          updateWalletCharCount(savedWalletAddress.length);

          // 如果已有完整的钱包地址，设置为只读状态
          if (savedWalletAddress.length === 50) {
            walletInput.style.background = "#e9ecef";
            walletInput.readOnly = true;
          } else {
            walletInput.style.background = "#f8f9fa";
            walletInput.readOnly = false;
          }
        }
      }

      // 个人中心登录处理
      async function handlePersonalCenterLogin() {
        // 保存当前在个人中心的状态
        const wasInPersonalCenter = true;

        // 关闭个人中心弹窗
        closePersonalCenter();

        // 调用主页登录逻辑
        await handleSignIn();

        // 登录成功后重新打开个人中心
        if (currentUser) {
          setTimeout(() => {
            showPersonalCenter();
          }, 1000); // 等待登录成功提示显示后再打开个人中心
        }
      }

      // 关闭个人中心弹窗
      function closePersonalCenter() {
        const modal = document.querySelector(".custom-modal");
        if (modal) {
          modal.remove();
        }
      }

      // 切换昵称编辑模式
      function toggleNicknameEdit() {
        const editSection = document.getElementById("nickname-edit-section");
        const isVisible = editSection.style.display !== "none";

        if (isVisible) {
          editSection.style.display = "none";
        } else {
          editSection.style.display = "block";
          // 聚焦到输入框
          setTimeout(() => {
            document.getElementById("nickname-input").focus();
          }, 100);
        }
      }

      // 更新用户昵称
      function updateNickname() {
        const nicknameInput = document.getElementById("nickname-input");
        const nicknameDisplay = document.getElementById(
          "user-nickname-display"
        );
        const newNickname = nicknameInput.value.trim();

        if (!newNickname) {
          showCustomAlert(t("hint"), t("enter_nickname"));
          return;
        }

        if (newNickname.length > 20) {
          showCustomAlert(t("hint"), t("nickname_too_long"));
          return;
        }

        // 过滤敏感词（简单示例）
        const forbiddenWords = ["admin", "管理员", "系统", "system"];
        if (
          forbiddenWords.some((word) =>
            newNickname.toLowerCase().includes(word)
          )
        ) {
          showCustomAlert(t("hint"), t("nickname_forbidden"));
          return;
        }

        // 保存到本地存储
        localStorage.setItem("userNickname", newNickname);

        // 更新显示
        nicknameDisplay.textContent = newNickname;

        // 隐藏编辑区域
        document.getElementById("nickname-edit-section").style.display = "none";

        showCustomAlert(t("success_title"), t("nickname_updated"));
      }

      // 保存钱包地址
      function saveWalletAddress() {
        const walletInput = document.getElementById("wallet-address-input");
        const walletAddress = walletInput.value.trim();

        if (!walletAddress) {
          showCustomAlert(t("hint"), t("enter_wallet_hint"));
          return;
        }

        // 验证钱包地址格式：50位大写字母和数字
        if (walletAddress.length !== 50) {
          showCustomAlert(
            t("error_title"),
            t("wallet_length_error", walletAddress.length)
          );
          return;
        }

        if (!/^[A-Z0-9]{50}$/.test(walletAddress)) {
          showCustomAlert(t("error_title"), t("wallet_format_error"));
          return;
        }

        // 保存到本地存储
        localStorage.setItem("userWalletAddress", walletAddress);

        // 显示成功消息
        showCustomAlert(t("success_title"), t("wallet_saved_success"));

        // 设置输入框为只读状态
        walletInput.style.background = "#e9ecef";
        walletInput.readOnly = true;

        // 自动刷新余额
        refreshBalance();
      }

      // 编辑钱包地址
      function editWalletAddress() {
        const walletInput = document.getElementById("wallet-address-input");

        // 启用编辑模式
        walletInput.style.background = "#f8f9fa";
        walletInput.readOnly = false;
        walletInput.focus();

        // 选中所有文本便于编辑
        walletInput.select();

        showCustomAlert(t("edit_mode_title"), t("edit_mode_message"));
      }

      // 退出账户
      function logoutUser() {
        showCustomConfirm(
          t("logout_confirm"),
          t("logout_message"),
          () => {
            // 保存当前用户的游戏数据到用户专属存储
            if (currentUser && userStats) {
              const userGameData = {
                userId: currentUser.piUserId || currentUser.uid,
                username: currentUser.username,
                gameStats: userStats,
                lastUpdated: new Date().toISOString(),
              };
              localStorage.setItem(
                `piGomokuUserData_${currentUser.piUserId || currentUser.uid}`,
                JSON.stringify(userGameData)
              );
            }

            // 只清除会话相关的数据，保留游戏统计数据
            localStorage.removeItem("piGomokuNickname");
            localStorage.removeItem("userAvatar");
            localStorage.removeItem("userWalletAddress");
            localStorage.removeItem("piGomokuLeaderboard");
            // 注意：不删除 piGomokuGameStats，改为用户专属存储

            // 清除登录状态
            clearLoginState();

            // 清除内存中的用户状态
            currentUser = null;
            userStats = null;

            // 显示退出成功消息
            showCustomAlert(t("logout_success"), t("logout_success_message"));

            // 关闭个人中心
            closePersonalCenter();

            // 更新主页按钮状态
            updateMainPageButtonState();

            // 刷新页面重置所有状态
            setTimeout(() => {
              location.reload();
            }, 1000);
          },
          () => {
            // 取消时不做任何操作
          }
        );
      }

      // 刷新账户余额
      async function refreshBalance() {
        const balanceElement = document.getElementById("account-balance");

        if (!currentUser) {
          showCustomAlert(t("hint"), t("please_login_first"));
          return;
        }

        try {
          balanceElement.innerHTML = t("balance_querying");

          const response = await fetch(
            `${API_BASE_URL}/api/payment/balance?userId=${currentUser.uid}`
          );
          const data = await response.json();

          if (data.success) {
            balanceElement.innerHTML = `${data.balance.current.toFixed(2)} π`;

            // 显示余额详情（可选）
            if (
              data.balance.totalRecharged > 0 ||
              data.balance.totalSpent > 0
            ) {
              const tooltip = t(
                "balance_tooltip",
                data.balance.totalRecharged.toFixed(2),
                data.balance.totalSpent.toFixed(2)
              );
              balanceElement.title = tooltip;
            }
          } else {
            balanceElement.innerHTML = "0.00 π";
            console.error("获取余额失败:", data.message);
          }
        } catch (error) {
          console.error("刷新余额失败:", error);
          balanceElement.innerHTML = t("balance_query_failed_display");
          setTimeout(() => {
            balanceElement.innerHTML = "0.00 π";
          }, 2000);
        }
      }

      // 获取等级名称
      function getLevelName(score) {
        if (score >= 2000) return "大师级";
        if (score >= 1500) return "专家级";
        if (score >= 1200) return "高级棋手";
        if (score >= 1000) return "中级棋手";
        if (score >= 800) return "初级棋手";
        return "新手";
      }

      // 获取等级进度
      function getLevelProgress(score) {
        const levels = [0, 800, 1000, 1200, 1500, 2000, 3000];
        for (let i = 0; i < levels.length - 1; i++) {
          if (score >= levels[i] && score < levels[i + 1]) {
            const progress =
              ((score - levels[i]) / (levels[i + 1] - levels[i])) * 100;
            return Math.min(100, Math.max(0, progress));
          }
        }
        return 100; // 最高级
      }

      // 显示游戏说明
      function showGameInstructions() {
        showCustomModal(
          t("game_instructions_title"),
          `
                <div style="text-align: left; max-height: 500px; overflow-y: auto;">
                    <!-- 历史渊源 -->
                    <div style="text-align: center; margin-bottom: 20px;">
                        <span style="font-size: 3em; margin-bottom: 10px; display: block;">🏛️</span>
                        <h3 style="color: #333; margin-bottom: 15px;">${t(
                          "game_history_section"
                        )}</h3>
                        <p style="margin: 0; line-height: 1.6; font-size: 14px; color: #666;">
                            ${t("game_history_desc")}
                        </p>
                    </div>

                    <!-- Basic Rules -->
                    <div style="background: #f8f9fa; border-radius: 8px; padding: 15px; margin-bottom: 15px;">
                        <h4 style="color: #333; margin: 0 0 12px 0; font-size: 16px;">${t(
                          "game_rules_title"
                        )}</h4>
                        <ul style="margin: 0; padding-left: 20px; line-height: 1.6; font-size: 14px; color: #333;">
                            <li>${t("basic_rules_detail_1")}</li>
                            <li>${t("basic_rules_detail_2")}</li>
                            <li>${t("basic_rules_detail_3")}</li>
                            <li>${t("basic_rules_detail_4")}</li>
                        </ul>
                    </div>

                    <!-- 回合时间规则 -->
                    <div style="background: #fff3cd; border-radius: 8px; padding: 15px; margin-bottom: 15px;">
                        <h4 style="color: #856404; margin: 0 0 12px 0; font-size: 16px;">${t(
                          "turn_time_rules"
                        )}</h4>
                        <ul style="margin: 0; padding-left: 20px; line-height: 1.6; font-size: 14px; color: #856404;">
                            <li><strong>${t("thinking_time_rule")}</strong></li>
                            <li><strong>${t("time_warning_rule")}</strong></li>
                            <li><strong>${t(
                              "urgent_warning_rule"
                            )}</strong></li>
                            <li><strong>${t("timeout_rule")}</strong></li>
                        </ul>
                    </div>

                    <!-- 游戏操作 -->
                    <div style="background: #e3f2fd; border-radius: 8px; padding: 15px; margin-bottom: 15px;">
                        <h4 style="color: #1976d2; margin: 0 0 12px 0; font-size: 16px;">${t(
                          "game_operations"
                        )}</h4>
                        <ul style="margin: 0; padding-left: 20px; line-height: 1.6; font-size: 14px; color: #1976d2;">
                            <li><strong>${t("place_stone")}</strong></li>
                            <li><strong>${t("undo_move")}</strong></li>
                            <li><strong>${t("new_game_op")}</strong></li>
                            <li><strong>${t("return_op")}</strong></li>
                        </ul>
                    </div>

                    <!-- 积分系统 -->
                    <div style="background: #d4edda; border-radius: 8px; padding: 15px; margin-bottom: 15px;">
                        <h4 style="color: #155724; margin: 0 0 12px 0; font-size: 16px;">${t(
                          "score_system"
                        )}</h4>
                        <ul style="margin: 0; padding-left: 20px; line-height: 1.6; font-size: 14px; color: #155724;">
                            <li><strong>${t("initial_score")}</strong></li>
                            <li><strong>${t("win_score")}</strong></li>
                            <li><strong>${t("draw_score")}</strong></li>
                            <li><strong>${t("lose_score")}</strong></li>
                            <li><strong>${t("quit_score")}</strong></li>
                        </ul>
                        <div style="margin-top: 10px; padding: 8px; background: #c3e6cb; border-radius: 4px; font-size: 13px; color: #155724;">
                            ${t("monthly_reset_system")}<br>
                            ${t("monthly_reset_desc")}<br>
                            ${t("historical_data_preserved")}<br>
                            ${t("monthly_ranking_only")}
                        </div>
                        <div style="margin-top: 8px; padding: 8px; background: #fff3cd; border-radius: 4px; font-size: 13px; color: #856404;">
                            ${t("anti_farming")}
                        </div>
                    </div>

                    <!-- 月度奖励规则 -->
                    <div style="background: #fff3cd; border-radius: 8px; padding: 15px; margin-bottom: 15px; border: 2px solid #ffeaa7;">
                        <h4 style="color: #856404; margin: 0 0 12px 0; font-size: 16px;">${t(
                          "monthly_rewards"
                        )}</h4>
                        <div style="color: #856404; font-size: 14px; line-height: 1.6;">
                            <div style="background: white; border-radius: 6px; padding: 12px; margin-bottom: 12px;">
                                <h5 style="color: #d63384; margin: 0 0 8px 0; font-size: 14px;">${t(
                                  "reward_pool_allocation"
                                )}</h5>
                                <ul style="margin: 0; padding-left: 20px; font-size: 13px;">
                                    <li>${t("reward_settlement")}</li>
                                    <li>${t("reward_pool_percentage")}</li>
                                    <li>${t("reward_example")}</li>
                                </ul>
                            </div>

                            <div style="background: white; border-radius: 6px; padding: 12px; margin-bottom: 12px;">
                                <h5 style="color: #d63384; margin: 0 0 8px 0; font-size: 14px;">${t(
                                  "top_three_distribution"
                                )}</h5>
                                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; font-size: 13px;">
                                    <div style="text-align: center; background: #fff3cd; padding: 8px; border-radius: 4px;">
                                        <div style="font-weight: bold; color: #ff6b35;">${t(
                                          "first_place"
                                        )}</div>
                                        <div style="color: #856404;">50%</div>
                                    </div>
                                    <div style="text-align: center; background: #e2e3e5; padding: 8px; border-radius: 4px;">
                                        <div style="font-weight: bold; color: #6c757d;">${t(
                                          "second_place"
                                        )}</div>
                                        <div style="color: #6c757d;">30%</div>
                                    </div>
                                    <div style="text-align: center; background: #f8d7da; padding: 8px; border-radius: 4px;">
                                        <div style="font-weight: bold; color: #721c24;">${t(
                                          "third_place"
                                        )}</div>
                                        <div style="color: #721c24;">20%</div>
                                    </div>
                                </div>
                            </div>

                            <div style="background: white; border-radius: 6px; padding: 12px;">
                                <h5 style="color: #d63384; margin: 0 0 8px 0; font-size: 14px;">${t(
                                  "distribution_method"
                                )}</h5>
                                <ul style="margin: 0; padding-left: 20px; font-size: 13px;">
                                    <li>${t("wallet_distribution")}</li>
                                    <li>${t("valid_wallet_required")}</li>
                                    <li>${t("next_day_distribution")}</li>
                                    <li>${t("invalid_wallet_rollover")}</li>
                                </ul>
                            </div>

                            <div style="margin-top: 12px; padding: 8px; background: #d1ecf1; border-radius: 4px; font-size: 12px; color: #0c5460; text-align: center;">
                                ${t("reward_example_calculation")}<br>
                                ${t("first_place_reward")} | ${t(
            "second_place_reward"
          )} | ${t("third_place_reward")}
                            </div>
                        </div>
                    </div>

                    <!-- 排行榜规则 -->
                    <div style="background: #f3e5f5; border-radius: 8px; padding: 15px; margin-bottom: 15px;">
                        <h4 style="color: #7b1fa2; margin: 0 0 12px 0; font-size: 16px;">${t(
                          "leaderboard_rules"
                        )}</h4>
                        <ul style="margin: 0; padding-left: 20px; line-height: 1.6; font-size: 14px; color: #7b1fa2;">
                            <li><strong>${t("ranking_condition")}</strong></li>
                            <li><strong>${t("ranking_basis")}</strong></li>
                            <li><strong>${t("data_statistics")}</strong></li>
                            <li><strong>${t("realtime_update")}</strong></li>
                        </ul>
                    </div>

                    <!-- 温馨提示 -->
                    <div style="background: #e8f5e8; border-radius: 8px; padding: 15px; text-align: center;">
                        <p style="margin: 0; color: #2e7d32; font-weight: 500; font-size: 14px; white-space: pre-line;">
                            ${t("warm_tips")}
                        </p>
                    </div>
                </div>
            `
        );
      }

      // 通用模态框显示函数
      function showCustomModal(title, content, callback = null) {
        // 创建模态框HTML
        const modalHTML = `
                <div id="custom-modal" style="
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.5);
                    display: flex;
                    justify-content: center;
                    align-items: flex-start;
                    padding-top: 5vh;
                    z-index: 1000;
                    padding: 20px;
                    box-sizing: border-box;
                ">
                    <div style="
                        background: white;
                        border-radius: 12px;
                        max-width: 500px;
                        width: 100%;
                        max-height: 90vh;
                        overflow: hidden;
                        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
                    ">
                        <div style="
                            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                            color: white;
                            padding: 20px;
                            display: flex;
                            justify-content: space-between;
                            align-items: center;
                        ">
                            <h3 style="margin: 0; font-size: 1.2em;">${title}</h3>
                            <button onclick="closeNewModal()" style="
                                background: none;
                                border: none;
                                color: white;
                                font-size: 1.5em;
                                cursor: pointer;
                                padding: 0;
                                width: 30px;
                                height: 30px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                border-radius: 50%;
                                transition: background 0.2s;
                            " onmouseover="this.style.background='rgba(255,255,255,0.2)'" onmouseout="this.style.background='none'">×</button>
                        </div>
                        <div style="padding: 20px; overflow-y: auto; max-height: calc(90vh - 80px);">
                            ${content}
                        </div>
                    </div>
                </div>
            `;

        // 添加到页面
        document.body.insertAdjacentHTML("beforeend", modalHTML);

        // 点击背景关闭
        document
          .getElementById("custom-modal")
          .addEventListener("click", function (e) {
            if (e.target === this) {
              closeNewModal();
            }
          });
      }

      // 关闭新的自定义模态框
      function closeNewModal() {
        const modal = document.getElementById("custom-modal");
        if (modal) {
          modal.remove();
        }
        // 停止排行榜自动刷新
        stopLeaderboardAutoRefresh();
      }



      // 更新本地游戏统计数据
      function updateLocalGameStats(result) {
        if (!userStats) {
          return;
        }

        // 更新统计数据
        userStats.totalGames = (userStats.totalGames || 0) + 1;

        if (result === "win") {
          userStats.wins = (userStats.wins || 0) + 1;
        } else if (result === "loss") {
          userStats.losses = (userStats.losses || 0) + 1;
        } else if (result === "draw") {
          userStats.draws = (userStats.draws || 0) + 1;
        }

        // 重新计算胜率
        if (userStats.totalGames > 0) {
          userStats.winRate = Math.round(
            (userStats.wins / userStats.totalGames) * 100
          );
        }

        // 保存到本地存储
        localStorage.setItem("piGomokuGameStats", JSON.stringify(userStats));

        // 同时保存到用户专属存储
        saveUserGameDataToSpecificStorage();
      }

      // 保存用户游戏数据到专属存储
      function saveUserGameDataToSpecificStorage() {
        if (!currentUser || !userStats) return;

        const userGameData = {
          userId: currentUser.piUserId || currentUser.uid,
          username: getCurrentDisplayUsername(), // 使用统一的用户名获取函数
          gameStats: userStats,
          lastUpdated: new Date().toISOString(),
        };

        const userDataKey = `piGomokuUserData_${
          currentUser.piUserId || currentUser.uid
        }`;
        localStorage.setItem(userDataKey, JSON.stringify(userGameData));

        console.log(`[数据保存] 用户数据已保存到本地存储: ${userDataKey}`, userGameData);
      }

      // 强制刷新本地排行榜数据
      function refreshLocalLeaderboardData() {
        if (currentUser && userStats) {
          // 确保当前用户数据被保存
          saveUserGameDataToSpecificStorage();

          // 重置数据刷新时间，强制下次获取排行榜时重新计算
          lastDataRefreshTime = 0;

          console.log("[排行榜] 本地数据已刷新");
        }
      }

      // 调试函数：分析localStorage中的用户数据
      function debugLocalStorageData() {
        console.log("=== localStorage 数据分析 ===");

        const userDataKeys = [];
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key && key.startsWith('piGomokuUserData_')) {
            userDataKeys.push(key);
          }
        }

        console.log(`找到 ${userDataKeys.length} 个用户数据键:`);
        userDataKeys.forEach(key => {
          try {
            const userData = JSON.parse(localStorage.getItem(key));
            console.log(`${key}:`, {
              userId: userData.userId,
              username: userData.username,
              totalGames: userData.gameStats?.totalGames,
              wins: userData.gameStats?.wins,
              winRate: userData.gameStats?.winRate
            });
          } catch (e) {
            console.error(`解析失败: ${key}`, e);
          }
        });

        console.log("当前用户:", currentUser);
        console.log("当前用户统计:", userStats);
        console.log("=== 分析结束 ===");
      }

      // 强制清理所有用户的重复数据
      function forceCleanupAllDuplicateUsers() {
        console.log("[强制清理] 开始清理所有用户的重复数据...");

        const userDataMap = new Map(); // userId -> 所有该用户的数据条目
        const keysToRemove = [];
        let totalCleaned = 0;

        // 1. 按用户ID分组收集所有数据
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);

          if (key && key.startsWith('piGomokuUserData_')) {
            try {
              const userData = JSON.parse(localStorage.getItem(key));
              if (userData && userData.userId && userData.gameStats) {
                const userId = userData.userId;

                if (!userDataMap.has(userId)) {
                  userDataMap.set(userId, []);
                }

                userDataMap.get(userId).push({
                  key: key,
                  data: userData,
                  totalGames: userData.gameStats.totalGames || 0,
                  wins: userData.gameStats.wins || 0,
                  winRate: userData.gameStats.winRate || 0,
                  lastUpdated: userData.lastUpdated || 0
                });
              } else {
                // 格式错误的数据直接删除
                keysToRemove.push(key);
                console.log(`[强制清理] 删除格式错误的数据: ${key}`);
              }
            } catch (error) {
              console.error(`[强制清理] 解析失败: ${key}`, error);
              keysToRemove.push(key);
            }
          }
        }

        // 2. 对每个用户，只保留最正确的数据
        userDataMap.forEach((entries, userId) => {
          if (entries.length > 1) {
            console.log(`[强制清理] 用户 ${userId} 有 ${entries.length} 个重复数据`);

            // 按游戏局数排序，局数相同时按时间戳排序
            entries.sort((a, b) => {
              if (b.totalGames !== a.totalGames) {
                return b.totalGames - a.totalGames; // 游戏局数多的优先
              }
              return b.lastUpdated - a.lastUpdated; // 时间新的优先
            });

            const keepEntry = entries[0];
            console.log(`[强制清理] 用户 ${userId} 保留: ${keepEntry.key} (总局数: ${keepEntry.totalGames})`);

            // 删除其他重复数据
            for (let i = 1; i < entries.length; i++) {
              const entry = entries[i];
              localStorage.removeItem(entry.key);
              keysToRemove.push(entry.key);
              totalCleaned++;
              console.log(`[强制清理] 用户 ${userId} 删除: ${entry.key} (总局数: ${entry.totalGames})`);
            }
          }
        });

        // 3. 删除格式错误的数据
        keysToRemove.forEach(key => {
          if (localStorage.getItem(key)) { // 确保还存在才删除
            localStorage.removeItem(key);
          }
        });

        console.log(`[强制清理] 清理完成！`);
        console.log(`[强制清理] - 处理了 ${userDataMap.size} 个用户`);
        console.log(`[强制清理] - 删除了 ${totalCleaned} 个重复数据条目`);
        console.log(`[强制清理] - 删除了 ${keysToRemove.length - totalCleaned} 个格式错误的数据`);

        return totalCleaned;
      }

      // 在全局作用域中暴露调试函数
      window.debugLocalStorageData = debugLocalStorageData;
      window.cleanupDuplicateUserData = cleanupDuplicateUserData;
      window.forceCleanupAllDuplicateUsers = forceCleanupAllDuplicateUsers;

      // 清理重复的用户数据
      function cleanupDuplicateUserData() {
        console.log("[数据清理] 开始清理重复的用户数据...");

        const userDataMap = new Map(); // userId -> 最新的用户数据
        const keysToRemove = [];

        // 1. 收集所有用户数据，保留游戏局数最多的数据（最可能是正确的）
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);

          if (key && key.startsWith('piGomokuUserData_')) {
            try {
              const userData = JSON.parse(localStorage.getItem(key));
              if (userData && userData.userId && userData.gameStats) {
                const userId = userData.userId;
                const totalGames = userData.gameStats.totalGames || 0;

                console.log(`[数据清理] 发现用户数据: ${userId} (${key}) - 总局数: ${totalGames}`);

                if (userDataMap.has(userId)) {
                  // 如果已存在，比较游戏局数，保留局数更多的数据
                  const existingData = userDataMap.get(userId);
                  const existingGames = existingData.gameStats.totalGames || 0;

                  if (totalGames > existingGames) {
                    // 当前数据游戏局数更多，标记旧key删除
                    keysToRemove.push(existingData.storageKey);
                    userDataMap.set(userId, { ...userData, storageKey: key });
                    console.log(`[数据清理] 用户 ${userId} 保留局数更多的数据: ${totalGames} > ${existingGames} (${key})`);
                  } else if (totalGames < existingGames) {
                    // 旧数据游戏局数更多，标记当前key删除
                    keysToRemove.push(key);
                    console.log(`[数据清理] 用户 ${userId} 删除局数较少的数据: ${totalGames} < ${existingGames} (${key})`);
                  } else {
                    // 游戏局数相同，比较时间戳
                    const existingTimestamp = existingData.lastUpdated || 0;
                    const currentTimestamp = userData.lastUpdated || 0;

                    if (currentTimestamp > existingTimestamp) {
                      keysToRemove.push(existingData.storageKey);
                      userDataMap.set(userId, { ...userData, storageKey: key });
                      console.log(`[数据清理] 用户 ${userId} 保留时间更新的数据 (${key})`);
                    } else {
                      keysToRemove.push(key);
                      console.log(`[数据清理] 用户 ${userId} 删除时间较旧的数据 (${key})`);
                    }
                  }
                } else {
                  // 首次遇到该用户
                  userDataMap.set(userId, { ...userData, storageKey: key });
                  console.log(`[数据清理] 用户 ${userId} 首次记录 (${key})`);
                }
              } else {
                // 数据格式不正确，删除
                keysToRemove.push(key);
                console.log(`[数据清理] 删除格式错误的数据: ${key}`);
              }
            } catch (error) {
              console.error(`[数据清理] 解析数据失败 ${key}:`, error);
              keysToRemove.push(key); // 损坏的数据也删除
            }
          }
        }

        // 2. 删除重复的数据
        keysToRemove.forEach(key => {
          localStorage.removeItem(key);
          console.log(`[数据清理] 删除重复数据: ${key}`);
        });

        console.log(`[数据清理] 清理完成，删除了 ${keysToRemove.length} 个重复项`);
        console.log(`[数据清理] 保留了 ${userDataMap.size} 个唯一用户的数据`);

        // 3. 输出保留的数据详情
        userDataMap.forEach((data, userId) => {
          console.log(`[数据清理] 保留用户: ${userId} - 总局数: ${data.gameStats.totalGames} - 存储键: ${data.storageKey}`);
        });

        return keysToRemove.length;
      }

      // 在页面加载时自动清理重复数据
      document.addEventListener('DOMContentLoaded', function() {
        // 延迟执行清理，确保其他初始化完成
        setTimeout(() => {
          console.log("[页面加载] 开始自动清理重复数据...");
          const cleanedCount = forceCleanupAllDuplicateUsers();
          if (cleanedCount > 0) {
            console.log(`[页面加载] 自动清理完成，删除了 ${cleanedCount} 个重复数据`);
          } else {
            console.log("[页面加载] 没有发现重复数据");
          }
        }, 1000);
      });



      // 显示游戏结果统计
      async function showGameResultStats(result, stats) {
        const resultText = {
          win: t("congratulations_win"),
          loss: t("sorry_lose"),
          draw: t("draw_result"),
        };

        // 检查是否为登录用户
        const isLoggedIn = currentUser && userStats;

        // 获取实时排名
        let currentRank = 0;
        if (isLoggedIn && currentUser.piUserId) {
          try {
            currentRank = await getUserRank(currentUser.piUserId);
          } catch (error) {
            console.error("获取用户排名失败:", error);
          }
        }

        showCustomModal(
          t("game_result"),
          `
                <div style="text-align: center;">
                    <div style="font-size: 3em; margin-bottom: 15px;">
                        ${
                          result === "win"
                            ? "🏆"
                            : result === "loss"
                            ? "😢"
                            : "🤝"
                        }
                    </div>
                    <h3 style="color: #333; margin-bottom: 20px;">${
                      resultText[result]
                    }</h3>

                    ${
                      isLoggedIn
                        ? `
                    <div style="background: #f8f9fa; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                            <div style="text-align: center;">
                                <div style="font-size: 1.5em; color: #28a745; font-weight: bold;">${
                                  stats.winRate
                                }%</div>
                                <div style="color: #666; font-size: 0.9em;">${t(
                                  "win_rate"
                                )}</div>
                                <div style="color: #666; font-size: 0.8em;">
                                    ${t(
                                      "wins_losses_format",
                                      stats.wins,
                                      stats.losses
                                    )}
                                </div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 1.5em; color: #007bff; font-weight: bold;">${
                                  stats.totalGames
                                }</div>
                                <div style="color: #666; font-size: 0.9em;">${t(
                                  "ranking_header_games"
                                )}</div>
                                <div style="color: #666; font-size: 0.8em;">
                                    ${t("monthly_games")}
                                </div>
                            </div>
                        </div>

                        <div style="text-align: center; padding-top: 15px; border-top: 1px solid #e9ecef;">
                            <div style="color: #666; font-size: 0.9em;">
                                ${t("current_rank_label")}: ${
                            currentRank > 0
                              ? t("rank_position", currentRank)
                              : t("not_listed")
                          }
                            </div>
                        </div>
                    </div>
                    `
                        : `
                    <div style="background: #fff3cd; border-radius: 8px; padding: 20px; margin-bottom: 20px; border: 2px solid #ffeaa7;">
                        <div style="font-size: 2em; margin-bottom: 10px;">🎮</div>
                        <h4 style="color: #856404; margin-bottom: 15px;">${t(
                          "guest_mode"
                        )}</h4>
                        <p style="color: #856404; margin: 0; line-height: 1.6;">
                            ${t("guest_mode_desc")}<br>
                            <strong>${t("login_benefits")}</strong><br>
                            ${t("benefit_stats")}<br>
                            ${t("benefit_leaderboard")}<br>
                            ${t("benefit_pi_service")}<br>
                            ${t("benefit_monthly_rewards")}
                        </p>
                    </div>
                    `
                    }



                    <div style="display: flex; gap: 10px; justify-content: center;">
                        <button onclick="closeNewModal(); resetAIGame()" style="background: #007bff; color: white; border: none; border-radius: 6px; padding: 10px 20px; cursor: pointer;">
                            ${t("play_again")}
                        </button>
                        ${
                          isLoggedIn
                            ? `
                        <button onclick="closeNewModal(); showRealTimeLeaderboard()" style="background: #28a745; color: white; border: none; border-radius: 6px; padding: 10px 20px; cursor: pointer;">
                            ${t("view_leaderboard")}
                        </button>
                        `
                            : `
                        <button onclick="closeNewModal(); handleSignIn()" style="background: #28a745; color: white; border: none; border-radius: 6px; padding: 10px 20px; cursor: pointer;">
                            ${t("login_now")}
                        </button>
                        `
                        }
                    </div>
                </div>
            `
        );
      }

      // 显示AI对战游戏界面 - 响应式设计适配所有屏幕
      function showSimpleGameScreen() {
        const root = document.getElementById("root");
        root.innerHTML = `
                <div style="height: 100vh; background: linear-gradient(135deg, var(--pi-primary) 0%, var(--pi-secondary) 100%); display: flex; flex-direction: column; align-items: center; padding: 2px; box-sizing: border-box; overflow: hidden;" class="game-container">
                    <!-- 游戏头部 - 极度紧凑布局 -->
                    <header style="width: 100%; display: flex; justify-content: flex-start; align-items: center; margin-bottom: 1px;">
                        <button onclick="backToLogin()" class="btn btn-outline btn-sm" style="height: auto; min-height: auto; padding: 4px 8px; line-height: 1.2; font-size: 14px;">
                            ${t("return_to_menu")}
                        </button>
                    </header>

                    <!-- 游戏标题 - 极度紧凑 -->
                    <h1 style="color: white; margin: 0 0 1px 0; font-size: clamp(24px, 5vw, 30px); text-align: center;">${t(
                      "ai_battle_title"
                    )}</h1>

                    <!-- 玩家信息 - 极度紧凑布局 -->
                    <div style="text-align: center; margin-bottom: 0; color: white;">
                        <div style="display: flex; justify-content: center; align-items: center; gap: clamp(10px, 3vw, 15px); margin-bottom: 0;">
                            <div style="display: flex; align-items: center; gap: 6px; background: rgba(255,255,255,0.1); padding: 6px 12px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.3);">
                                <div class="stone black" style="width: 20px; height: 20px; margin: 0;"></div>
                                <strong style="font-size: clamp(16px, 3.5vw, 20px);">${t(
                                  "player_label"
                                )}</strong>
                            </div>
                            <div style="color: white; font-size: clamp(18px, 3.5vw, 22px); font-weight: 600;">${t(
                              "vs_label"
                            )}</div>
                            <div style="display: flex; align-items: center; gap: 6px; background: rgba(255,255,255,0.1); padding: 6px 12px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.3);">
                                <div class="stone white" style="width: 20px; height: 20px; margin: 0;"></div>
                                <strong style="font-size: clamp(16px, 3.5vw, 20px);">${t(
                                  "ai_label"
                                )}</strong>
                            </div>
                        </div>
                        <div style="font-size: clamp(16px, 3.5vw, 20px); font-weight: 600; margin-top: 2px; margin-bottom: 0;" id="current-player-display">
                            ${t("your_turn")}
                        </div>
                        <!-- 回合计时器 -->
                        <div style="font-size: clamp(14px, 3vw, 16px); margin-top: 4px; color: #ffffff;" id="turn-timer-display">
                            ${t("thinking_time", "60")}
                        </div>
                    </div>

                    <!-- 棋盘容器 - 极度紧凑间距 -->
                    <div class="game-board" style="display: flex; align-items: flex-start; justify-content: center; margin: 0; padding-top: 2px;">
                        <div class="board-container">
                            <div class="board-grid responsive-board" id="ai-game-board">
                                <!-- 15x15 棋盘格子将通过JavaScript生成 -->
                            </div>
                        </div>
                    </div>

                    <!-- 游戏控制按钮 - 固定在底部 -->
                    <div style="display: flex; justify-content: center; gap: 12px; margin-top: 8px;">
                        <button onclick="undoAIMove()" class="btn btn-warning btn-sm" id="undo-btn" style="min-width: 80px; padding: 8px 16px;">
                            ${t("undo_button")}
                        </button>
                        <button onclick="resetAIGame()" class="btn btn-primary btn-sm" style="min-width: 80px; padding: 8px 16px;">
                            ${t("new_game_button")}
                        </button>
                    </div>
                </div>
            `;

        // 初始化AI游戏
        initAIGame();
      }

      // AI游戏相关变量
      let aiGameBoard = Array(15)
        .fill()
        .map(() => Array(15).fill(null));
      let aiCurrentPlayer = "black"; // 玩家是黑子，AI是白子
      let aiGameHistory = [];
      let aiGameActive = true;

      // 回合超时相关变量
      let turnTimer = null;
      let turnTimeLeft = 0;
      let turnTimerDisplay = null;
      const TURN_TIME_LIMIT = 60; // 60秒回合时间限制
      const WARNING_TIME = 30; // 30秒开始警告

      // 音效管理器 - 使用您的自定义音效文件
      class SoundManager {
        constructor() {
          this.sounds = {};
          this.enabled = true;
          this.volume = 0.5; // 音量控制
          this.initSounds();
        }

        initSounds() {
          // 预加载您的音效文件，设置不同音效的音量
          const soundFiles = {
            gameStart: { src: "./public/sounds/game-start.mp3", volume: 0.5 },
            move: { src: "./public/sounds/move.mp3", volume: 0.8 }, // 提高落子音效音量
            victory: { src: "./public/sounds/victory.mp3", volume: 0.5 },
          };

          // 创建Audio对象并预加载
          for (const [key, config] of Object.entries(soundFiles)) {
            try {
              const audio = new Audio(config.src);
              audio.volume = config.volume;
              audio.preload = "auto";

              // 添加错误处理
              audio.addEventListener("error", (e) => {
                console.log(`音效文件加载失败: ${config.src}`, e);
              });

              // 添加加载成功事件
              audio.addEventListener("canplaythrough", () => {
                console.log(`音效文件加载成功: ${config.src}`);
              });

              this.sounds[key] = audio;
            } catch (e) {
              console.log(`音效初始化失败: ${key}`, e);
            }
          }
        }

        // 播放音效的通用方法
        playSound(soundName) {
          if (!this.enabled || !this.sounds[soundName]) {
            return;
          }

          try {
            const audio = this.sounds[soundName];
            // 重置播放位置
            audio.currentTime = 0;
            // 播放音效
            const playPromise = audio.play();

            // 处理播放Promise（现代浏览器要求）
            if (playPromise !== undefined) {
              playPromise.catch((error) => {
                console.log(`音效播放失败: ${soundName}`, error);
              });
            }
          } catch (e) {
            console.log(`音效播放错误: ${soundName}`, e);
          }
        }

        playMove() {
          this.playSound("move");
        }

        playVictory() {
          this.playSound("victory");
        }

        playGameStart() {
          this.playSound("gameStart");
        }

        // 设置音量
        setVolume(volume) {
          this.volume = Math.max(0, Math.min(1, volume));
          // 保持不同音效的相对音量比例
          const volumeRatios = {
            gameStart: 0.5,
            move: 0.8,
            victory: 0.5
          };

          for (const [key, audio] of Object.entries(this.sounds)) {
            const ratio = volumeRatios[key] || 0.5;
            audio.volume = this.volume * ratio;
          }
        }

        // 启用/禁用音效
        toggle() {
          this.enabled = !this.enabled;
          return this.enabled;
        }
      }

      // 创建音效管理器实例
      let soundManager = new SoundManager();

      // 自定义弹窗函数
      function showCustomAlert(title, message, callback) {
        const modal = document.createElement("div");
        modal.className = "custom-modal";
        modal.innerHTML = `
                <div class="custom-modal-content">
                    <div class="custom-modal-title">${title}</div>
                    <div class="custom-modal-message">${message}</div>
                    <div class="custom-modal-buttons">
                        <button class="custom-modal-btn primary" onclick="closeCustomModal()">${t(
                          "confirm"
                        )}</button>
                    </div>
                </div>
            `;
        document.body.appendChild(modal);

        // 保存回调函数
        window.customModalCallback = callback;
      }

      function showCustomConfirm(title, message, onConfirm, onCancel) {
        const modal = document.createElement("div");
        modal.className = "custom-modal";
        modal.innerHTML = `
                <div class="custom-modal-content">
                    <div class="custom-modal-title">${title}</div>
                    <div class="custom-modal-message">${message}</div>
                    <div class="custom-modal-buttons">
                        <button class="custom-modal-btn primary" onclick="confirmCustomModal()">${t(
                          "confirm"
                        )}</button>
                        <button class="custom-modal-btn secondary" onclick="cancelCustomModal()">${t(
                          "cancel"
                        )}</button>
                    </div>
                </div>
            `;
        document.body.appendChild(modal);

        // 保存回调函数
        window.customModalConfirm = onConfirm;
        window.customModalCancel = onCancel;
      }

      function closeCustomModal() {
        const modal = document.querySelector(".custom-modal");
        if (modal) {
          modal.remove();
          if (window.customModalCallback) {
            window.customModalCallback();
            window.customModalCallback = null;
          }
        }
      }

      function confirmCustomModal() {
        const modal = document.querySelector(".custom-modal");
        if (modal) {
          modal.remove();
          if (window.customModalConfirm) {
            window.customModalConfirm();
            window.customModalConfirm = null;
            window.customModalCancel = null;
          }
        }
      }

      function cancelCustomModal() {
        const modal = document.querySelector(".custom-modal");
        if (modal) {
          modal.remove();
          if (window.customModalCancel) {
            window.customModalCancel();
          }
          window.customModalConfirm = null;
          window.customModalCancel = null;
        }
      }

      // 初始化AI游戏
      function initAIGame() {
        const board = document.getElementById("ai-game-board");
        board.innerHTML = "";

        // 设置响应式棋盘尺寸
        setupResponsiveBoard();

        // 创建15x15棋盘
        for (let row = 0; row < 15; row++) {
          for (let col = 0; col < 15; col++) {
            const cell = document.createElement("div");
            cell.className = "board-cell";
            cell.dataset.row = row;
            cell.dataset.col = col;
            cell.addEventListener("click", () => makeAIMove(row, col));
            board.appendChild(cell);
          }
        }

        // 重置游戏状态
        aiGameBoard = Array(15)
          .fill()
          .map(() => Array(15).fill(null));
        aiCurrentPlayer = "black";
        aiGameHistory = [];
        aiGameActive = true;
        window.gameStartTime = Date.now(); // 记录游戏开始时间

        // 清除之前的计时器
        stopTurnTimer();

        updateAIGameStatus();

        // 播放游戏开始音效
        setTimeout(() => {
          soundManager.playGameStart();
        }, 300);

        // 手机端清除阴影
        setTimeout(() => {
          clearAllStoneShadows();
        }, 100);
      }

      // 设置响应式棋盘尺寸
      function setupResponsiveBoard() {
        const board = document.getElementById("ai-game-board");
        if (!board) return;

        // 根据屏幕尺寸动态计算棋盘大小
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;

        // 计算可用高度：总高度减去头部、标题、玩家信息、按钮等区域
        // 预留空间：返回按钮(40px) + 标题(35px) + 玩家信息(80px) + 按钮区域(60px) + 边距(20px)
        const reservedHeight = 235;
        const availableHeight = screenHeight - reservedHeight;
        const availableWidth = screenWidth - 16; // 减去左右边距

        let cellSize;
        if (screenWidth >= 1200) {
          cellSize = 28;
        } else if (screenWidth >= 992) {
          cellSize = 26;
        } else if (screenWidth >= 768) {
          cellSize = 24;
        } else if (screenWidth >= 576) {
          cellSize = 22;
        } else {
          // 手机端：充分利用屏幕宽度
          // 减去边框和内边距，计算最大可用宽度
          const availableWidth = screenWidth - 16; // 8px padding * 2
          const maxCellSize = Math.floor(availableWidth / 15);
          cellSize = Math.max(20, Math.min(24, maxCellSize)); // 最小20px，最大24px
        }

        // 桌面端确保棋盘不会超出屏幕高度，但优先保持宽度
        if (screenWidth >= 768) {
          const maxBoardSizeByHeight = Math.floor(availableHeight / 15);
          if (maxBoardSizeByHeight < cellSize) {
            cellSize = Math.max(20, maxBoardSizeByHeight); // 最小保持20px
          }
        }

        // 只有当尺寸真正改变时才更新CSS变量，避免不必要的重新渲染
        const currentCellSize = getComputedStyle(
          document.documentElement
        ).getPropertyValue("--cell-size");
        const newCellSizeValue = cellSize + "px";

        if (currentCellSize !== newCellSizeValue) {
          // 设置CSS变量 - 棋子尺寸适中，留出合理空隙
          const stoneSize = Math.max(14, cellSize - 4); // 棋子比格子小4px，保持合理空隙
          document.documentElement.style.setProperty(
            "--cell-size",
            newCellSizeValue
          );
          document.documentElement.style.setProperty(
            "--stone-size",
            stoneSize + "px"
          );
        }
      }

      // 防抖函数
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // 监听窗口大小变化（使用防抖避免频繁调用）
      window.addEventListener(
        "resize",
        debounce(() => {
          if (document.getElementById("ai-game-board")) {
            setupResponsiveBoard();
          }
        }, 250)
      );

      // 玩家下棋
      function makeAIMove(row, col) {
        if (
          !aiGameActive ||
          aiGameBoard[row][col] !== null ||
          aiCurrentPlayer !== "black"
        ) {
          return;
        }

        // 停止玩家回合计时器
        stopTurnTimer();

        // 玩家下黑子
        placeAIStone(row, col, "black");
        aiGameBoard[row][col] = "black";
        aiGameHistory.push({ row, col, player: "black" });

        // 播放落子音效
        soundManager.playMove();

        // 检查玩家是否获胜
        if (checkAIWin(row, col, "black")) {
          endAIGame("black");
          return;
        }

        // 检查是否平局
        if (isAIBoardFull()) {
          endAIGame(null);
          return;
        }

        // 切换到AI
        aiCurrentPlayer = "white";
        updateAIGameStatus();

        // AI思考时间显示
        const currentPlayerDisplay = document.getElementById(
          "current-player-display"
        );
        if (currentPlayerDisplay) {
          currentPlayerDisplay.textContent = t("opponent_turn");
        }

        // AI延迟下棋（给用户一些反应时间）
        setTimeout(() => {
          makeAIAutoMove();
        }, 800);
      }

      // AI自动下棋
      function makeAIAutoMove() {
        if (!aiGameActive || aiCurrentPlayer !== "white") return;

        const aiMove = getAIBestMove();
        if (aiMove) {
          placeAIStone(aiMove.row, aiMove.col, "white");
          aiGameBoard[aiMove.row][aiMove.col] = "white";
          aiGameHistory.push({
            row: aiMove.row,
            col: aiMove.col,
            player: "white",
          });

          // 播放落子音效
          soundManager.playMove();

          // 检查AI是否获胜
          if (checkAIWin(aiMove.row, aiMove.col, "white")) {
            endAIGame("white");
            return;
          }

          // 检查是否平局
          if (isAIBoardFull()) {
            endAIGame(null);
            return;
          }

          // 切换回玩家
          aiCurrentPlayer = "black";
          updateAIGameStatus();
        }
      }

      // 强制清除棋子阴影的函数 - 手机端专用
      function clearStoneShadows(stone) {
        if (stone) {
          stone.style.boxShadow = "none";
          stone.style.filter = "none";
          stone.style.webkitFilter = "none";
          stone.style.textShadow = "none";
          stone.style.webkitBoxShadow = "none";
          stone.style.mozBoxShadow = "none";

          // 强制重绘
          stone.offsetHeight;
        }
      }

      // 全局清除所有棋子阴影 - 手机端专用
      function clearAllStoneShadows() {
        if (window.innerWidth <= 768) {
          const allStones = document.querySelectorAll(".stone");
          allStones.forEach((stone) => {
            clearStoneShadows(stone);
          });

          // 也清除棋盘格子的阴影
          const allCells = document.querySelectorAll(".board-cell");
          allCells.forEach((cell) => {
            cell.style.boxShadow = "none";
            cell.style.filter = "none";
            cell.style.webkitFilter = "none";
            cell.style.webkitBoxShadow = "none";
            cell.style.mozBoxShadow = "none";
          });
        }
      }

      // 在棋盘上放置棋子
      function placeAIStone(row, col, player) {
        // 移除所有之前的最新落子标识（确保彻底清除）
        const allPreviousLatest = document.querySelectorAll(
          "#ai-game-board .stone.latest"
        );
        allPreviousLatest.forEach((stone) => {
          stone.classList.remove("latest");
          // 手机端强制清除阴影
          if (window.innerWidth <= 768) {
            clearStoneShadows(stone);
          }
        });

        const cell = document.querySelector(
          `#ai-game-board [data-row="${row}"][data-col="${col}"]`
        );

        // 给格子添加occupied类，防止hover效果
        cell.classList.add("occupied");

        const stone = document.createElement("div");
        stone.className = `stone ${player} latest`;
        cell.appendChild(stone);

        // 手机端强制清除新棋子的阴影
        if (window.innerWidth <= 768) {
          setTimeout(() => {
            clearStoneShadows(stone);
          }, 0);

          // 动画结束后再次清除
          setTimeout(() => {
            clearStoneShadows(stone);
          }, 300);
        }
      }

      // AI配置
      const AI_CONFIG = {
        MAX_DEPTH: 6, // 搜索深度
        MAX_TIME: 3000, // 最大思考时间(毫秒)
        CANDIDATE_LIMIT: 20, // 候选位置数量限制
      };

      // 评估分数常量
      const SCORES = {
        WIN: 100000,
        LOSE: -100000,
        ALIVE_FOUR: 10000,
        RUSH_FOUR: 1000,
        ALIVE_THREE: 1000,
        SLEEP_THREE: 100,
        ALIVE_TWO: 100,
        SLEEP_TWO: 10,
        ONE: 1,
      };

      // 强化AI算法 - 使用Minimax + Alpha-Beta剪枝
      function getAIBestMove() {
        const startTime = Date.now();

        // 首先检查是否有立即获胜的机会
        const winMove = findWinningMove("white");
        if (winMove) return winMove;

        // 检查是否需要立即防守
        const blockMove = findWinningMove("black");
        if (blockMove) return blockMove;

        // 获取候选位置
        const candidates = getCandidateMoves();
        if (candidates.length === 0) {
          return { row: 7, col: 7 }; // 中心位置
        }

        let bestMove = candidates[0];
        let bestScore = -Infinity;

        // 使用Minimax算法搜索最佳位置
        for (const move of candidates) {
          // 时间限制检查
          if (Date.now() - startTime > AI_CONFIG.MAX_TIME) break;

          aiGameBoard[move.row][move.col] = "white";
          const score = minimax(
            AI_CONFIG.MAX_DEPTH - 1,
            false,
            -Infinity,
            Infinity,
            startTime
          );
          aiGameBoard[move.row][move.col] = null;

          if (score > bestScore) {
            bestScore = score;
            bestMove = move;
          }
        }

        return bestMove;
      }

      // Minimax算法实现
      function minimax(depth, isMaximizing, alpha, beta, startTime) {
        // 时间限制检查
        if (Date.now() - startTime > AI_CONFIG.MAX_TIME) {
          return evaluateBoard();
        }

        // 深度限制或游戏结束
        if (depth === 0) {
          return evaluateBoard();
        }

        // 检查游戏是否结束
        const gameResult = checkGameEnd();
        if (gameResult !== null) {
          if (gameResult === "white") return SCORES.WIN;
          if (gameResult === "black") return SCORES.LOSE;
          return 0; // 平局
        }

        const candidates = getCandidateMoves();
        if (candidates.length === 0) return evaluateBoard();

        if (isMaximizing) {
          let maxScore = -Infinity;
          for (const move of candidates) {
            aiGameBoard[move.row][move.col] = "white";
            const score = minimax(depth - 1, false, alpha, beta, startTime);
            aiGameBoard[move.row][move.col] = null;

            maxScore = Math.max(maxScore, score);
            alpha = Math.max(alpha, score);
            if (beta <= alpha) break; // Alpha-Beta剪枝
          }
          return maxScore;
        } else {
          let minScore = Infinity;
          for (const move of candidates) {
            aiGameBoard[move.row][move.col] = "black";
            const score = minimax(depth - 1, true, alpha, beta, startTime);
            aiGameBoard[move.row][move.col] = null;

            minScore = Math.min(minScore, score);
            beta = Math.min(beta, score);
            if (beta <= alpha) break; // Alpha-Beta剪枝
          }
          return minScore;
        }
      }

      // 寻找获胜位置
      function findWinningMove(player) {
        for (let row = 0; row < 15; row++) {
          for (let col = 0; col < 15; col++) {
            if (aiGameBoard[row][col] === null) {
              aiGameBoard[row][col] = player;
              if (checkAIWinOnBoard(aiGameBoard, row, col, player)) {
                aiGameBoard[row][col] = null;
                return { row, col };
              }
              aiGameBoard[row][col] = null;
            }
          }
        }
        return null;
      }

      // 获取候选位置（只搜索有意义的位置）
      function getCandidateMoves() {
        const candidates = [];
        const visited = new Set();

        // 如果棋盘为空，返回中心位置
        if (aiGameHistory.length === 0) {
          return [{ row: 7, col: 7 }];
        }

        // 在已有棋子周围2格范围内寻找候选位置
        for (let row = 0; row < 15; row++) {
          for (let col = 0; col < 15; col++) {
            if (aiGameBoard[row][col] !== null) {
              // 在该棋子周围2格范围内添加候选位置
              for (let dr = -2; dr <= 2; dr++) {
                for (let dc = -2; dc <= 2; dc++) {
                  const newRow = row + dr;
                  const newCol = col + dc;
                  const key = `${newRow},${newCol}`;

                  if (
                    newRow >= 0 &&
                    newRow < 15 &&
                    newCol >= 0 &&
                    newCol < 15 &&
                    aiGameBoard[newRow][newCol] === null &&
                    !visited.has(key)
                  ) {
                    visited.add(key);
                    candidates.push({
                      row: newRow,
                      col: newCol,
                      score: evaluatePosition(newRow, newCol),
                    });
                  }
                }
              }
            }
          }
        }

        // 按评估分数排序，取前N个候选位置
        candidates.sort((a, b) => b.score - a.score);
        return candidates.slice(0, AI_CONFIG.CANDIDATE_LIMIT);
      }

      // 检查游戏是否结束
      function checkGameEnd() {
        // 检查是否有玩家获胜
        for (let row = 0; row < 15; row++) {
          for (let col = 0; col < 15; col++) {
            if (aiGameBoard[row][col] !== null) {
              if (
                checkAIWinOnBoard(aiGameBoard, row, col, aiGameBoard[row][col])
              ) {
                return aiGameBoard[row][col];
              }
            }
          }
        }

        // 检查是否平局
        if (isAIBoardFull()) {
          return "draw";
        }

        return null;
      }

      // 检查是否获胜（在指定棋盘上）
      function checkAIWinOnBoard(board, row, col, player) {
        const directions = [
          [0, 1],
          [1, 0],
          [1, 1],
          [1, -1],
        ];

        for (let [dx, dy] of directions) {
          let count = 1;

          // 正方向
          for (let i = 1; i < 5; i++) {
            const newRow = row + dx * i;
            const newCol = col + dy * i;
            if (newRow < 0 || newRow >= 15 || newCol < 0 || newCol >= 15) break;
            if (board[newRow][newCol] !== player) break;
            count++;
          }

          // 反方向
          for (let i = 1; i < 5; i++) {
            const newRow = row - dx * i;
            const newCol = col - dy * i;
            if (newRow < 0 || newRow >= 15 || newCol < 0 || newCol >= 15) break;
            if (board[newRow][newCol] !== player) break;
            count++;
          }

          if (count >= 5) return true;
        }

        return false;
      }

      // 检查是否获胜（在主棋盘上）
      function checkAIWin(row, col, player) {
        return checkAIWinOnBoard(aiGameBoard, row, col, player);
      }

      // 智能评估函数
      function evaluateBoard() {
        let score = 0;

        // 评估所有方向的连子情况
        for (let row = 0; row < 15; row++) {
          for (let col = 0; col < 15; col++) {
            if (aiGameBoard[row][col] !== null) {
              score += evaluatePositionForPlayer(
                row,
                col,
                aiGameBoard[row][col]
              );
            }
          }
        }

        return score;
      }

      // 评估单个位置的价值
      function evaluatePosition(row, col) {
        let score = 0;

        // 模拟放置白子和黑子，计算价值
        aiGameBoard[row][col] = "white";
        score += evaluatePositionForPlayer(row, col, "white");
        aiGameBoard[row][col] = "black";
        score -= evaluatePositionForPlayer(row, col, "black") * 1.1; // 防守稍微重要一些
        aiGameBoard[row][col] = null;

        // 中心位置加分
        const centerDistance = Math.abs(row - 7) + Math.abs(col - 7);
        score += (14 - centerDistance) * 2;

        return score;
      }

      // 评估特定玩家在特定位置的价值
      function evaluatePositionForPlayer(row, col, player) {
        let score = 0;
        const directions = [
          [0, 1],
          [1, 0],
          [1, 1],
          [1, -1],
        ];

        for (const [dx, dy] of directions) {
          const pattern = getLinePattern(row, col, dx, dy, player);
          score += evaluatePattern(pattern, player);
        }

        return score;
      }

      // 获取某个方向的连子模式
      function getLinePattern(row, col, dx, dy, player) {
        let pattern = [];

        // 向负方向扫描4格
        for (let i = -4; i <= 4; i++) {
          const newRow = row + dx * i;
          const newCol = col + dy * i;

          if (newRow < 0 || newRow >= 15 || newCol < 0 || newCol >= 15) {
            pattern.push("X"); // 边界
          } else if (aiGameBoard[newRow][newCol] === player) {
            pattern.push("O"); // 己方棋子
          } else if (aiGameBoard[newRow][newCol] === null) {
            pattern.push("."); // 空位
          } else {
            pattern.push("X"); // 对方棋子或边界
          }
        }

        return pattern.join("");
      }

      // 评估连子模式
      function evaluatePattern(pattern, player) {
        const multiplier = player === "white" ? 1 : -1;

        // 五连
        if (pattern.includes("OOOOO")) {
          return SCORES.WIN * multiplier;
        }

        // 活四 (.OOOO.)
        if (pattern.includes(".OOOO.")) {
          return SCORES.ALIVE_FOUR * multiplier;
        }

        // 冲四 (XOOOO. 或 .OOOOX)
        if (pattern.includes("XOOOO.") || pattern.includes(".OOOOX")) {
          return SCORES.RUSH_FOUR * multiplier;
        }

        // 活三 (.OOO. 且两边都有空位延伸)
        if (pattern.includes(".OOO.")) {
          return SCORES.ALIVE_THREE * multiplier;
        }

        // 眠三 (XOOO. 或 .OOOX)
        if (pattern.includes("XOOO.") || pattern.includes(".OOOX")) {
          return SCORES.SLEEP_THREE * multiplier;
        }

        // 活二 (.OO. 且两边都有空位延伸)
        if (pattern.includes(".OO.")) {
          return SCORES.ALIVE_TWO * multiplier;
        }

        // 眠二 (XOO. 或 .OOX)
        if (pattern.includes("XOO.") || pattern.includes(".OOX")) {
          return SCORES.SLEEP_TWO * multiplier;
        }

        // 单子
        if (pattern.includes("O")) {
          return SCORES.ONE * multiplier;
        }

        return 0;
      }

      // 检查棋盘是否已满
      function isAIBoardFull() {
        for (let row = 0; row < 15; row++) {
          for (let col = 0; col < 15; col++) {
            if (aiGameBoard[row][col] === null) {
              return false;
            }
          }
        }
        return true;
      }

      // 更新游戏状态显示
      function updateAIGameStatus() {
        const currentPlayerDisplay = document.getElementById(
          "current-player-display"
        );

        if (currentPlayerDisplay) {
          if (aiCurrentPlayer === "black") {
            currentPlayerDisplay.textContent = t("your_turn");
            startTurnTimer(); // 开始玩家回合计时
          } else {
            currentPlayerDisplay.textContent = t("opponent_turn");
            stopTurnTimer(); // 停止计时器（AI回合）
          }
        }
      }

      // 开始回合计时器
      function startTurnTimer() {
        // 清除之前的计时器
        stopTurnTimer();

        // 只在玩家回合启动计时器
        if (aiCurrentPlayer !== "black" || !aiGameActive) return;

        turnTimeLeft = TURN_TIME_LIMIT;
        updateTimerDisplay();

        turnTimer = setInterval(() => {
          turnTimeLeft--;
          updateTimerDisplay();

          // 时间到，玩家超时
          if (turnTimeLeft <= 0) {
            handlePlayerTimeout();
          }
        }, 1000);
      }

      // 停止回合计时器
      function stopTurnTimer() {
        if (turnTimer) {
          clearInterval(turnTimer);
          turnTimer = null;
        }
        // 显示AI回合状态，保持布局稳定
        const timerDisplay = document.getElementById("turn-timer-display");
        if (timerDisplay) {
          timerDisplay.style.display = "block";
          timerDisplay.style.color = "#ffffff";
          timerDisplay.style.opacity = "1";
          timerDisplay.innerHTML = t("ai_thinking");
        }
      }

      // 更新计时器显示
      function updateTimerDisplay() {
        const timerDisplay = document.getElementById("turn-timer-display");
        if (!timerDisplay) return;

        timerDisplay.style.display = "block";

        // 根据剩余时间改变显示样式
        if (turnTimeLeft > WARNING_TIME) {
          // 正常时间：白色
          timerDisplay.style.color = "#ffffff";
          timerDisplay.innerHTML = t("thinking_time", turnTimeLeft);
        } else if (turnTimeLeft > 10) {
          // 警告时间：黄色
          timerDisplay.style.color = "#ffc107";
          timerDisplay.innerHTML = t("remaining_time", turnTimeLeft);
        } else {
          // 紧急时间：红色闪烁
          timerDisplay.style.color = "#dc3545";
          timerDisplay.innerHTML = t("timeout_warning", turnTimeLeft);

          // 最后10秒闪烁效果
          if (turnTimeLeft % 2 === 0) {
            timerDisplay.style.opacity = "0.5";
          } else {
            timerDisplay.style.opacity = "1";
          }
        }
      }

      // 处理玩家超时
      function handlePlayerTimeout() {
        if (turnTimer) {
          clearInterval(turnTimer);
          turnTimer = null;
        }

        if (!aiGameActive) return;

        // 结束游戏，记录为失败
        aiGameActive = false;

        // 检查用户是否还在游戏界面
        const isInGameScreen =
          document.getElementById("current-player-display") !== null;

        if (isInGameScreen) {
          // 用户还在游戏界面，显示超时信息
          const currentPlayerDisplay = document.getElementById(
            "current-player-display"
          );
          if (currentPlayerDisplay) {
            currentPlayerDisplay.textContent = t("timeout");
          }

          // 显示超时信息
          const timerDisplay = document.getElementById("turn-timer-display");
          if (timerDisplay) {
            timerDisplay.style.display = "block";
            timerDisplay.style.color = "#dc3545";
            timerDisplay.style.opacity = "1";
            timerDisplay.innerHTML = t("timeout");
          }
        }

        // 记录超时失败
        const gameData = {
          totalMoves: aiGameHistory.length,
          gameMode: "ai",
          difficulty: 7,
          duration: Date.now() - (window.gameStartTime || Date.now()),
          timeoutReason: "player_timeout", // 玩家超时
        };

        // 延迟一下显示结果，让用户看到超时提示
        setTimeout(() => {
          // 重新检查用户是否还在游戏界面（因为可能在1.5秒内离开了）
          const stillInGameScreen =
            document.getElementById("current-player-display") !== null;

          if (currentUser && userStats) {
            if (stillInGameScreen) {
              // 用户在游戏界面，显示正常的游戏结果弹窗
              recordGameResult("loss", gameData);
            } else {
              // 用户已离开游戏界面，静默记录不显示弹窗
              recordGameResultSilent("loss", gameData);
            }
          } else {
            // 未登录用户，只在游戏界面显示提示
            if (stillInGameScreen) {
              showCustomAlert(t("game_over"), t("timeout_game_over"));
            }
          }
        }, 1500);
      }

      // 结束游戏
      function endAIGame(winner) {
        aiGameActive = false;

        // 停止计时器
        if (turnTimer) {
          clearInterval(turnTimer);
          turnTimer = null;
        }

        const currentPlayerDisplay = document.getElementById(
          "current-player-display"
        );

        // 显示游戏结束状态
        const timerDisplay = document.getElementById("turn-timer-display");
        if (timerDisplay) {
          timerDisplay.style.display = "block";
          timerDisplay.style.opacity = "1";
          if (winner === "black") {
            timerDisplay.style.color = "#28a745";
            timerDisplay.innerHTML = t("you_win");
          } else if (winner === "white") {
            timerDisplay.style.color = "#dc3545";
            timerDisplay.innerHTML = t("you_lose");
          } else {
            timerDisplay.style.color = "#ffc107";
            timerDisplay.innerHTML = t("draw");
          }
        }

        // 播放胜利音效
        setTimeout(() => {
          soundManager.playVictory();
        }, 200);

        // 记录游戏结果到后端
        let gameResult;
        if (winner === "black") {
          gameResult = "win";
          currentPlayerDisplay.textContent = t("you_win");
        } else if (winner === "white") {
          gameResult = "loss";
          currentPlayerDisplay.textContent = t("you_lose");
        } else {
          gameResult = "draw";
          currentPlayerDisplay.textContent = t("draw");
        }

        // 记录游戏数据
        const gameData = {
          totalMoves: aiGameHistory.length,
          gameMode: "ai",
          difficulty: 7,
          duration: Date.now() - (window.gameStartTime || Date.now()),
        };

        // 如果用户已登录，记录游戏结果
        if (currentUser && userStats) {
          recordGameResult(gameResult, gameData);
        } else {
          // 如果用户已登录但userStats为空，尝试初始化
          if (currentUser && !userStats) {
            initializeUserStatsFromLocal();
            // 重新检查并记录
            if (userStats) {
              recordGameResult(gameResult, gameData);
              return;
            }
          }

          // 未登录用户或初始化失败，显示简单结果
          setTimeout(() => {
            const resultText = {
              win: t("you_win"),
              loss: t("you_lose"),
              draw: t("draw"),
            };
            showCustomAlert(t("game_over"), resultText[gameResult]);
          }, 500);
        }
      }

      // 悔棋功能 - 临时移除扣币逻辑
      async function undoAIMove() {
        if (aiGameHistory.length < 2 || !aiGameActive) {
          return;
        }

        // 由于后端服务暂未部署，直接执行悔棋
        performUndo();
      }

      // 执行悔棋操作
      function performUndo() {
        // 悔棋两步（玩家和AI的棋子）
        for (let i = 0; i < 2 && aiGameHistory.length > 0; i++) {
          const lastMove = aiGameHistory.pop();
          aiGameBoard[lastMove.row][lastMove.col] = null;

          // 移除UI中的棋子
          const cell = document.querySelector(
            `#ai-game-board [data-row="${lastMove.row}"][data-col="${lastMove.col}"]`
          );
          const stone = cell.querySelector(".stone");
          if (stone) {
            stone.remove();
          }
          // 移除occupied类，恢复hover效果
          cell.classList.remove("occupied");
        }

        // 清除所有latest标记
        const allLatestStones = document.querySelectorAll(
          "#ai-game-board .stone.latest"
        );
        allLatestStones.forEach((stone) => stone.classList.remove("latest"));

        // 如果还有棋子，将最后一个棋子标记为latest
        if (aiGameHistory.length > 0) {
          const lastMove = aiGameHistory[aiGameHistory.length - 1];
          const lastCell = document.querySelector(
            `#ai-game-board [data-row="${lastMove.row}"][data-col="${lastMove.col}"]`
          );
          const lastStone = lastCell.querySelector(".stone");
          if (lastStone) {
            lastStone.classList.add("latest");
          }
        }

        // 重置为玩家回合
        aiCurrentPlayer = "black";
        aiGameActive = true;
        updateAIGameStatus();
      }

      // 重新开始游戏
      async function resetAIGame() {
        // 检查当前游戏是否正在进行中
        const isGameInProgress = aiGameActive && aiGameHistory.length > 0;

        if (isGameInProgress) {
          // 游戏进行中，需要支付费用
          if (currentUser && userStats) {
            // 登录用户必须支付
            try {
              // 先检查余额
              const balanceResponse = await fetch(
                `${API_BASE_URL}/api/payment/balance?userId=${currentUser.uid}`
              );
              const balanceData = await balanceResponse.json();

              if (balanceData.success && balanceData.balance.current >= 0.1) {
                // 余额充足，显示确认对话框
                showCustomConfirm(
                  t("restart_game"),
                  t("abandon_game_warning"),
                  async () => {
                    // 确认重新开始，扣费并执行
                    const consumeResponse = await fetch(
                      `${API_BASE_URL}/api/payment/consume`,
                      {
                        method: "POST",
                        headers: {
                          "Content-Type": "application/json",
                        },
                        body: JSON.stringify({
                          userId: currentUser.uid,
                          amount: 0.1,
                          purpose: "newgame",
                          gameData: {
                            moveCount: aiGameHistory.length,
                            gameMode: "ai",
                            reason: "restart_in_progress",
                          },
                        }),
                      }
                    );

                    const consumeData = await consumeResponse.json();
                    if (consumeData.success) {
                      // 扣费成功，记录失败并开始新游戏
                      recordGameAbandon();
                      initAIGame();
                      showCustomAlert(
                        t("success"),
                        t(
                          "undo_success_detail",
                          consumeData.newBalance.toFixed(2)
                        )
                      );
                    } else {
                      showCustomAlert(
                        t("error_title"),
                        consumeData.message || t("undo_failed_message")
                      );
                    }
                  },
                  () => {
                    // 取消操作
                  }
                );
              } else {
                // 余额不足，提示用户选择是否充值
                const currentBalance = balanceData.success
                  ? balanceData.balance.current.toFixed(2)
                  : "0.00";
                showCustomConfirm(
                  t("insufficient_balance_title"),
                  t("insufficient_balance_undo", currentBalance),
                  () => {
                    // 用户选择充值
                    showRechargeDialog(t("recharge_prompt"));
                  },
                  () => {
                    // 用户选择不充值，继续游戏但不能重新开始
                    showCustomAlert(t("hint"), t("continue_game_tip"));
                  }
                );
              }
            } catch (error) {
              console.error("新游戏支付检查失败:", error);
              showCustomAlert(t("error_title"), t("network_error_retry"));
            }
          } else {
            // 未登录用户，免费重新开始（但不参与排行榜）
            showCustomConfirm(
              t("abandon_current_game"),
              t("abandon_game_warning"),
              () => {
                recordGameAbandon();
                initAIGame();
              },
              () => {
                // 取消时不做任何操作
              }
            );
          }
        } else {
          // 游戏未开始或已结束，直接重新开始
          showCustomConfirm(
            t("restart_game"),
            t("restart_game_confirm"),
            () => {
              initAIGame();
            },
            () => {
              // 取消时不做任何操作
            }
          );
        }
      }

      // 记录游戏放弃
      function recordGameAbandon() {
        if (!currentUser || !userStats) return;

        // 记录游戏数据
        const gameData = {
          totalMoves: aiGameHistory.length,
          gameMode: "ai",
          difficulty: 7,
          duration: Date.now() - (window.gameStartTime || Date.now()),
          abandonReason: "player_restart", // 玩家主动重新开始
        };

        // 记录为失败
        recordGameResult("loss", gameData);
      }

      // 返回登录界面
      function backToLogin() {
        // 检查当前游戏是否正在进行中
        const isGameInProgress = aiGameActive && aiGameHistory.length > 0;

        if (isGameInProgress) {
          // 游戏进行中，询问是否放弃当前游戏
          showCustomConfirm(
            t("abandon_current_game"),
            t("abandon_game_return_warning"),
            () => {
              // 记录当前游戏为失败（放弃）
              recordGameAbandonAndReturn();
            },
            () => {
              // 取消时不做任何操作
            }
          );
          return;
        }

        // 游戏未开始或已结束，直接返回
        performBackToLogin();
      }

      // 记录游戏放弃并返回
      function recordGameAbandonAndReturn() {
        if (
          currentUser &&
          userStats &&
          aiGameActive &&
          aiGameHistory.length > 0
        ) {
          // 记录游戏数据
          const gameData = {
            totalMoves: aiGameHistory.length,
            gameMode: "ai",
            difficulty: 7,
            duration: Date.now() - (window.gameStartTime || Date.now()),
            abandonReason: "player_exit", // 玩家主动退出
          };

          // 记录为失败（不显示结果弹窗）
          recordGameResultSilent("loss", gameData);
        }

        // 返回主界面
        performBackToLogin();
      }

      // 静默记录游戏结果（不显示弹窗）
      async function recordGameResultSilent(result, gameData = {}) {
        if (!currentUser || !userStats) return;

        // 先更新本地数据
        updateLocalGameStats(result);

        try {
          // 确保使用与个人中心一致的用户名
          const displayUsername = getCurrentDisplayUsername();

          // 同步更新本地userStats的用户名
          if (userStats) {
            userStats.username = displayUsername;
          }

          const response = await fetch(`${API_BASE_URL}/api/games`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              playerUid: currentUser.piUserId || currentUser.uid,
              result: result === 'loss' ? 'lose' : result, // 'win', 'lose', 'draw' - 后端期望的格式
              moves: gameData.moves || [],
              duration: gameData.duration || 0,
            }),
          });

          if (response.ok) {
            const data = await response.json();
            userStats = data.userStats; // 更新本地统计数据
          } else {
            console.error("记录游戏结果失败:", response.statusText);
            // 如果后端失败，至少保存本地数据
            saveUserGameData();
          }
        } catch (error) {
          console.error("记录游戏结果失败:", error);
          // 如果后端失败，至少保存本地数据
          saveUserGameData();
        }
      }

      // 执行返回登录界面
      function performBackToLogin() {
        // 直接切换到主界面，避免页面重新加载的延迟
        const root = document.getElementById("root");
        root.innerHTML = `
                <div class="login-screen">
                    <div class="container">
                        <div class="login-content">
                            <div class="login-card card">
                                <!-- 语言切换器 -->
                                <div class="language-selector">
                                    <span class="globe-icon">🌍</span>
                                    <select id="language-selector-game" onchange="changeLanguage(this.value)">
                                        <option value="zh" data-i18n="lang_zh">中文</option>
                                        <option value="en" data-i18n="lang_en">English</option>
                                        <option value="ko" data-i18n="lang_ko">한국어</option>
                                        <option value="ja" data-i18n="lang_ja">日本語</option>
                                        <option value="vi" data-i18n="lang_vi">Tiếng Việt</option>
                                    </select>
                                </div>

                                <div class="card-header text-center">
                                    <div class="title-with-icon">
                                        <div class="board-icon">
                                            <div class="stones-container">
                                                <div class="stone-jar black">
                                                    <div class="stone"></div>
                                                </div>
                                                <div class="stone-jar white">
                                                    <div class="stone"></div>
                                                </div>
                                            </div>
                                        </div>
                                        <h1 class="game-title" data-i18n="game_title">${t(
                                          "game_title"
                                        )}</h1>
                                    </div>
                                    <p class="game-subtitle" data-i18n="game_subtitle">
                                        ${t("game_subtitle")}
                                    </p>
                                </div>

                                <div class="card-content">
                                    <div class="game-modes">
                                        <div class="game-mode-row">
                                            <button class="game-mode-btn online-mode" onclick="handleOnlineMatch()">
                                                <span class="mode-icon">🌐</span>
                                                <span class="mode-text" data-i18n="online_match">${t(
                                                  "online_match"
                                                )}</span>
                                            </button>
                                        </div>
                                        <div class="game-mode-row">
                                            <button class="game-mode-btn" onclick="showGlobalRanking()">
                                                <span class="mode-icon">🏆</span>
                                                <span class="mode-text" data-i18n="global_ranking">${t(
                                                  "global_ranking"
                                                )}</span>
                                            </button>
                                        </div>
                                        <div class="game-mode-row">
                                            <button class="game-mode-btn ai-mode" onclick="handleAIGame()">
                                                <span class="mode-icon">🧠</span>
                                                <span class="mode-text" data-i18n="ai_battle">${t(
                                                  "ai_battle"
                                                )}</span>
                                            </button>
                                        </div>
                                        <div class="game-mode-row">
                                            <button class="game-mode-btn" onclick="showPersonalCenter()">
                                                <span class="mode-icon">👤</span>
                                                <span class="mode-text" data-i18n="personal_center">${t(
                                                  "personal_center"
                                                )}</span>
                                            </button>
                                        </div>
                                        <div class="game-mode-row">
                                            <button class="game-mode-btn" onclick="showGameInstructions()">
                                                <span class="mode-icon">❓</span>
                                                <span class="mode-text" data-i18n="game_instructions">${t(
                                                  "game_instructions"
                                                )}</span>
                                            </button>
                                        </div>
                                    </div>

                                    <div class="error-message" id="error-message" style="display: none;">
                                        <p id="error-text" data-i18n="error_message">❌ 错误信息</p>
                                    </div>
                                </div>

                                <div class="card-footer">
                                    <button id="login-btn" class="btn btn-primary btn-lg pi-login-btn" onclick="handleSignIn()">
                                        <span class="pi-icon">π</span>
                                        <span data-i18n="login_with_pi">${t(
                                          "login_with_pi"
                                        )}</span>
                                    </button>
                                    <p class="login-note" data-i18n="login_note">
                                        ${t("login_note")}
                                    </p>

                                    <!-- 隐私政策和服务条款链接 -->
                                    <div class="legal-links" style="margin-top: 20px; text-align: center;">
                                        <a href="public/privacy-policy.html" target="_blank" style="color: #c77dff; text-decoration: none; margin: 0 10px; font-size: 14px;" data-i18n="privacy_policy">隐私政策</a>
                                        <span style="color: #ffffff80;">|</span>
                                        <a href="public/terms-of-service.html" target="_blank" style="color: #c77dff; text-decoration: none; margin: 0 10px; font-size: 14px;" data-i18n="terms_of_service">服务条款</a>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;

        // 重新初始化页面状态
        initializePage();

        // 立即调整副标题字体大小，不使用延迟
        adjustSubtitleFontSize();

        // 确保按钮状态正确更新
        updateMainPageButtonState();
      }

      // 显示充值对话框
      function showRechargeDialog(message) {
        showCustomModal(
          t("recharge_dialog_title"),
          `
            <div style="text-align: center;">
              <div style="margin-bottom: 20px;">
                <div style="font-size: 2em; margin-bottom: 10px;">💳</div>
                <p style="color: #666; margin-bottom: 15px;">${message}</p>
              </div>

              <div style="background: #f8f9fa; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                <h4 style="color: #333; margin-bottom: 15px;">${t(
                  "recharge_amount_selection"
                )}</h4>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                  <button onclick="createRechargeOrder(1)" style="background: #28a745; color: white; border: none; border-radius: 6px; padding: 12px; cursor: pointer;">
                    1 π
                  </button>
                  <button onclick="createRechargeOrder(5)" style="background: #17a2b8; color: white; border: none; border-radius: 6px; padding: 12px; cursor: pointer;">
                    5 π
                  </button>
                  <button onclick="createRechargeOrder(10)" style="background: #ffc107; color: black; border: none; border-radius: 6px; padding: 12px; cursor: pointer;">
                    10 π
                  </button>
                  <button onclick="createRechargeOrder(20)" style="background: #dc3545; color: white; border: none; border-radius: 6px; padding: 12px; cursor: pointer;">
                    20 π
                  </button>
                </div>
                <div style="margin-top: 10px;">
                  <input type="number" id="custom-amount" placeholder="${t(
                    "custom_amount_placeholder"
                  )}" min="0.1" step="0.1" style="width: 120px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-right: 10px;">
                  <button onclick="createCustomRechargeOrder()" style="background: #6c757d; color: white; border: none; border-radius: 4px; padding: 8px 12px; cursor: pointer;">
                    ${t("custom_recharge")}
                  </button>
                </div>
              </div>

              <div style="text-align: center;">
                <button onclick="closeNewModal()" style="background: #6c757d; color: white; border: none; border-radius: 6px; padding: 10px 20px; cursor: pointer;">
                  ${t("cancel")}
                </button>
              </div>
            </div>
          `
        );
      }

      // 创建充值订单
      async function createRechargeOrder(amount) {
        if (!currentUser) {
          showCustomAlert(t("error_title"), t("please_login_first"));
          return;
        }

        try {
          const response = await fetch(`${API_BASE_URL}/api/payment/create`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              userId: currentUser.uid,
              amount: amount,
              purpose: "recharge",
            }),
          });

          const data = await response.json();
          if (data.success) {
            showPaymentDialog(data.order);
          } else {
            showCustomAlert(t("create_order_failed"), data.message);
          }
        } catch (error) {
          console.error("创建充值订单失败:", error);
          showCustomAlert(t("error_title"), t("network_error_retry"));
        }
      }

      // 创建自定义金额充值订单
      function createCustomRechargeOrder() {
        const amountInput = document.getElementById("custom-amount");
        const amount = parseFloat(amountInput.value);

        if (!amount || amount < 0.1) {
          showCustomAlert(t("error_title"), t("custom_amount_error"));
          return;
        }

        createRechargeOrder(amount);
      }

      // 显示支付对话框
      function showPaymentDialog(order) {
        showCustomModal(
          t("payment_dialog_title"),
          `
            <div style="text-align: center;">
              <div style="margin-bottom: 20px;">
                <div style="font-size: 2em; margin-bottom: 10px;">π</div>
                <h3 style="color: #333; margin-bottom: 10px;">${t(
                  "recharge_amount_display",
                  order.amount
                )}</h3>
                <p style="color: #666; font-size: 14px;">${t(
                  "order_id_display",
                  order.orderId
                )}</p>
              </div>

              <div style="background: #f8f9fa; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                <h4 style="color: #333; margin-bottom: 15px;">${t(
                  "payment_method"
                )}</h4>

                <div style="background: white; border-radius: 6px; padding: 15px; margin-bottom: 15px; border: 2px solid #e9ecef;">
                  <h5 style="color: #333; margin-bottom: 10px;">${t(
                    "pi_wallet_transfer"
                  )}</h5>
                  <p style="color: #666; font-size: 14px; margin-bottom: 10px;">
                    ${t("transfer_instruction")}
                  </p>
                  <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; font-family: monospace; font-size: 12px; word-break: break-all; margin-bottom: 10px;">
                    ${order.receiverAddress}
                  </div>
                  <p style="color: #dc3545; font-size: 13px; margin-bottom: 10px;">
                    ${t("transfer_amount_warning", order.amount)}
                  </p>
                  <p style="color: #666; font-size: 13px;">
                    ${t("transfer_memo", order.qrCodeData.memo)}
                  </p>
                </div>

                <div style="margin-bottom: 15px;">
                  <input type="text" id="transaction-hash" placeholder="${t(
                    "transaction_hash_placeholder"
                  )}" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace; font-size: 14px;">
                  <p style="color: #666; font-size: 12px; margin-top: 5px;">
                    ${t("transaction_hash_instruction")}
                  </p>
                </div>
              </div>

              <div style="display: flex; gap: 10px; justify-content: center;">
                <button onclick="verifyPayment('${
                  order.orderId
                }')" style="background: #28a745; color: white; border: none; border-radius: 6px; padding: 10px 20px; cursor: pointer;">
                  ${t("verify_payment")}
                </button>
                <button onclick="closeNewModal()" style="background: #6c757d; color: white; border: none; border-radius: 6px; padding: 10px 20px; cursor: pointer;">
                  ${t("cancel")}
                </button>
              </div>

              <p style="color: #666; font-size: 12px; margin-top: 15px;">
                ${t("order_validity")}
              </p>
            </div>
          `
        );
      }

      // 验证支付
      async function verifyPayment(orderId) {
        const transactionHashInput =
          document.getElementById("transaction-hash");
        const transactionHash = transactionHashInput.value.trim();

        if (!transactionHash) {
          showCustomAlert(t("error_title"), t("please_enter_transaction_hash"));
          return;
        }

        try {
          const response = await fetch(`${API_BASE_URL}/api/payment/verify`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              orderId: orderId,
              transactionHash: transactionHash,
            }),
          });

          const data = await response.json();
          if (data.success) {
            closeNewModal();
            showCustomAlert(
              t("recharge_success"),
              t(
                "recharge_success_message",
                data.order.amount,
                data.newBalance.toFixed(2)
              )
            );
          } else {
            showCustomAlert(t("verification_failed"), data.message);
          }
        } catch (error) {
          console.error("验证支付失败:", error);
          showCustomAlert(t("error_title"), t("network_error_retry"));
        }
      }

      // Pi Network iframe环境强力修复语言选择器位置
      function forceFixLanguageSelectorPosition() {
        const languageSelector = document.querySelector(".language-selector");
        if (languageSelector) {
          // 检测是否在iframe中
          const isInIframe = window.self !== window.top;
          const isPiNetwork =
            window.location.hostname.includes("minepi.com") ||
            document.referrer.includes("minepi.com") ||
            isInIframe;

          // 强制应用最高优先级样式
          const styles = {
            position: "fixed",
            top: "15px",
            right: "15px",
            zIndex: "2147483647", // 最大z-index值
            transform: "translate3d(0, 0, 0)",
            willChange: "transform",
            pointerEvents: "auto",
            margin: "0",
            left: "auto",
            bottom: "auto",
          };

          Object.assign(languageSelector.style, styles);

          // 添加重要性标记
          languageSelector.style.setProperty("position", "fixed", "important");
          languageSelector.style.setProperty("top", "15px", "important");
          languageSelector.style.setProperty("right", "15px", "important");
          languageSelector.style.setProperty(
            "z-index",
            "2147483647",
            "important"
          );

          if (isPiNetwork) {
            document.body.classList.add("pi-network-iframe");
          }
        }
      }

      // 强制刷新缓存检查
      function checkCacheVersion() {
        const currentVersion = "2025-06-11-22:30";
        const cachedVersion = localStorage.getItem("appVersion");

        if (cachedVersion !== currentVersion) {
          localStorage.setItem("appVersion", currentVersion);
          // 如果版本不匹配，强制刷新
          if (cachedVersion && "serviceWorker" in navigator) {
            navigator.serviceWorker
              .getRegistrations()
              .then(function (registrations) {
                for (let registration of registrations) {
                  registration.unregister();
                }
              });
          }
        }
      }

      // 页面加载完成后初始化
      document.addEventListener("DOMContentLoaded", function () {
        checkCacheVersion();
        initializePage();

        // 强力修复语言选择器位置
        forceFixLanguageSelectorPosition();

        // 定时重复修复，确保在Pi Network iframe中正确显示
        setTimeout(() => {
          forceFixLanguageSelectorPosition();
        }, 500);

        setTimeout(() => {
          forceFixLanguageSelectorPosition();
        }, 1000);

        setTimeout(() => {
          forceFixLanguageSelectorPosition();
        }, 2000);

        // 手机端阴影清除
        clearAllStoneShadows();

        // 监听窗口大小变化，重新清除阴影和调整字体
        window.addEventListener("resize", function () {
          setTimeout(() => {
            clearAllStoneShadows();
            adjustSubtitleFontSize();
          }, 100);
        });

        // 监听设备方向变化
        window.addEventListener("orientationchange", function () {
          setTimeout(() => {
            clearAllStoneShadows();
          }, 200);
        });
      });

      // 强制刷新缓存检查
      function checkCacheVersion() {
        const currentVersion = "2025-06-11-22:30";
        const cachedVersion = localStorage.getItem("appVersion");

        if (cachedVersion !== currentVersion) {
          localStorage.setItem("appVersion", currentVersion);
          // 如果版本不匹配，强制刷新
          if (cachedVersion && "serviceWorker" in navigator) {
            navigator.serviceWorker
              .getRegistrations()
              .then(function (registrations) {
                for (let registration of registrations) {
                  registration.unregister();
                }
              });
          }
        }
      }

      // 页面加载完成后初始化
      document.addEventListener("DOMContentLoaded", function () {
        checkCacheVersion();
        initializePage();

        // 强力修复语言选择器位置
        forceFixLanguageSelectorPosition();

        // 更新主页按钮状态
        updateMainPageButtonState();

        // 清除所有棋子阴影
        setTimeout(() => {
          clearAllStoneShadows();
        }, 200);
      });
    </script>
  </body>
</html>
 